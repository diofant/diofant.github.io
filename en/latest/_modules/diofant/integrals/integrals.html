

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diofant.integrals.integrals &mdash; Diofant 0.11.0a6.dev29+gf7bbde2 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"CommonHTML": {"linebreaks": {"automatic": true}}, "HTML-CSS": {"linebreaks": {"automatic": true}}, "SVG": {"linebreaks": {"automatic": true}}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../internals/index.html">Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../aboutus.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Diofant</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>diofant.integrals.integrals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diofant.integrals.integrals</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">..concrete.expr_with_limits</span> <span class="k">import</span> <span class="n">AddWithLimits</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="k">import</span> <span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span>
                    <span class="n">Wild</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">sympify</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..core.compatibility</span> <span class="k">import</span> <span class="n">is_sequence</span>
<span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">piecewise_fold</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">..logic</span> <span class="k">import</span> <span class="n">false</span><span class="p">,</span> <span class="n">true</span>
<span class="kn">from</span> <span class="nn">..matrices</span> <span class="k">import</span> <span class="n">MatrixBase</span>
<span class="kn">from</span> <span class="nn">..polys</span> <span class="k">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">PolynomialError</span>
<span class="kn">from</span> <span class="nn">..series</span> <span class="k">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">limit</span>
<span class="kn">from</span> <span class="nn">..simplify.fu</span> <span class="k">import</span> <span class="n">sincos_to_sum</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">filldedent</span>
<span class="kn">from</span> <span class="nn">.meijerint</span> <span class="k">import</span> <span class="n">meijerint_definite</span><span class="p">,</span> <span class="n">meijerint_indefinite</span>
<span class="kn">from</span> <span class="nn">.trigonometry</span> <span class="k">import</span> <span class="n">trigintegrate</span>


<div class="viewcode-block" id="Integral"><a class="viewcode-back" href="../../../modules/integrals.html#diofant.integrals.integrals.Integral">[docs]</a><span class="k">class</span> <span class="nc">Integral</span><span class="p">(</span><span class="n">AddWithLimits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents unevaluated integral.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an unevaluated integral.</span>

<span class="sd">        Arguments are an integrand followed by one or more limits.</span>

<span class="sd">        If no limits are given and there is only one free symbol in the</span>
<span class="sd">        expression, that symbol will be used, otherwise an error will be</span>
<span class="sd">        raised.</span>

<span class="sd">        &gt;&gt;&gt; Integral(x)</span>
<span class="sd">        Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; Integral(y)</span>
<span class="sd">        Integral(y, y)</span>

<span class="sd">        When limits are provided, they are interpreted as follows (using</span>
<span class="sd">        ``x`` as though it were the variable of integration):</span>

<span class="sd">            (x,) or x - indefinite integral</span>
<span class="sd">            (x, a) - &quot;evaluate at&quot; integral is an abstract antiderivative</span>
<span class="sd">            (x, a, b) - definite integral</span>

<span class="sd">        The ``as_dummy`` method can be used to see which symbols cannot be</span>
<span class="sd">        targeted by subs: those with a preppended underscore cannot be</span>
<span class="sd">        changed with ``subs``. (Also, the integration variables themselves --</span>
<span class="sd">        the first element of a limit -- can never be changed by subs.)</span>

<span class="sd">        &gt;&gt;&gt; i = Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; at = Integral(x, (x, x))</span>
<span class="sd">        &gt;&gt;&gt; i.as_dummy()</span>
<span class="sd">        Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; at.as_dummy()</span>
<span class="sd">        Integral(_x, (_x, x))</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This will help other classes define their own definitions</span>
        <span class="c1"># of behaviour with Integral.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s1">&#39;_eval_Integral&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">_eval_Integral</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">AddWithLimits</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the symbols that will exist when the</span>
<span class="sd">        integral is evaluated. This is useful if one is trying to</span>
<span class="sd">        determine whether an integral depends on a certain</span>
<span class="sd">        symbol or not.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; Integral(x, (x, y, 1)).free_symbols</span>
<span class="sd">        {y}</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.concrete.expr_with_limits.ExprWithLimits.function</span>
<span class="sd">        diofant.concrete.expr_with_limits.ExprWithLimits.limits</span>
<span class="sd">        diofant.concrete.expr_with_limits.ExprWithLimits.variables</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AddWithLimits</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_is_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="n">Dummy</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This is a very naive and quick test, not intended to do the integral to</span>
        <span class="c1"># answer whether it is zero or not, e.g. Integral(sin(x), (x, 0, 2*pi))</span>
        <span class="c1"># is zero but this routine should return None for that case. But, like</span>
        <span class="c1"># Mul, there are trivial situations for which the integral will be</span>
        <span class="c1"># zero so we check for those.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">got_false</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">z</span> <span class="o">==</span> <span class="n">true</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">z</span> <span class="o">==</span> <span class="n">false</span><span class="p">:</span>
                    <span class="n">got_false</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_nonzero</span><span class="p">:</span>
                    <span class="n">got_false</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">free</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="c1"># take integration symbol out of free since it will be replaced</span>
            <span class="c1"># with the free symbols in the limits</span>
            <span class="n">free</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># add in the new symbols</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">free</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">is_nonzero</span> <span class="ow">and</span> <span class="n">got_false</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Integral.transform"><a class="viewcode-back" href="../../../modules/integrals.html#diofant.integrals.integrals.Integral.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a change of variables from `x` to `u` using the relationship</span>
<span class="sd">        given by `x` and `u` which will define the transformations `f` and `F`</span>
<span class="sd">        (which are inverses of each other) as follows:</span>

<span class="sd">        1) If `x` is a Symbol (which is a variable of integration) then `u`</span>
<span class="sd">           will be interpreted as some function, f(u), with inverse F(u).</span>
<span class="sd">           This, in effect, just makes the substitution of x with f(x).</span>

<span class="sd">        2) If `u` is a Symbol then `x` will be interpreted as some function,</span>
<span class="sd">           F(x), with inverse f(u). This is commonly referred to as</span>
<span class="sd">           u-substitution.</span>

<span class="sd">        Once f and F have been identified, the transformation is made as</span>
<span class="sd">        follows:</span>

<span class="sd">        .. math:: \int_a^b x \mathrm{d}x \rightarrow \int_{F(a)}^{F(b)} f(x)</span>
<span class="sd">                  \frac{\mathrm{d}}{\mathrm{d}x}</span>

<span class="sd">        where `F(x)` is the inverse of `f(x)` and the limits and integrand have</span>
<span class="sd">        been corrected so as to retain the same value after integration.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The mappings, F(x) or f(u), must lead to a unique integral. Linear</span>
<span class="sd">        or rational linear expression, `2*x`, `1/x` and `sqrt(x)`, will</span>
<span class="sd">        always work; quadratic expressions like `x**2 - 1` are acceptable</span>
<span class="sd">        as long as the resulting integrand does not depend on the sign of</span>
<span class="sd">        the solutions (see examples).</span>

<span class="sd">        The integral will be returned unchanged if `x` is not a variable of</span>
<span class="sd">        integration.</span>

<span class="sd">        `x` must be (or contain) only one of of the integration variables. If</span>
<span class="sd">        `u` has more than one free symbol then it should be sent as a tuple</span>
<span class="sd">        (`u`, `uvar`) where `uvar` identifies which variable is replacing</span>
<span class="sd">        the integration variable.</span>
<span class="sd">        XXX can it contain another integration variable?</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from diofant.abc import u</span>

<span class="sd">        &gt;&gt;&gt; i = Integral(x*cos(x**2 - 1), (x, 0, 1))</span>

<span class="sd">        transform can change the variable of integration</span>

<span class="sd">        &gt;&gt;&gt; i.transform(x, u)</span>
<span class="sd">        Integral(u*cos(u**2 - 1), (u, 0, 1))</span>

<span class="sd">        transform can perform u-substitution as long as a unique</span>
<span class="sd">        integrand is obtained:</span>

<span class="sd">        &gt;&gt;&gt; i.transform(x**2 - 1, u)</span>
<span class="sd">        Integral(cos(u)/2, (u, -1, 0))</span>

<span class="sd">        This attempt fails because x = +/-sqrt(u + 1) and the</span>
<span class="sd">        sign does not cancel out of the integrand:</span>

<span class="sd">        &gt;&gt;&gt; Integral(cos(x**2 - 1), (x, 0, 1)).transform(x**2 - 1, u)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError:</span>
<span class="sd">        The mapping between F(x) and f(u) did not give a unique integrand.</span>

<span class="sd">        transform can do a substitution. Here, the previous</span>
<span class="sd">        result is transformed back into the original expression</span>
<span class="sd">        using &quot;u-substitution&quot;:</span>

<span class="sd">        &gt;&gt;&gt; ui = _</span>
<span class="sd">        &gt;&gt;&gt; _.transform(sqrt(u + 1), x) == i</span>
<span class="sd">        True</span>

<span class="sd">        We can accomplish the same with a regular substitution:</span>

<span class="sd">        &gt;&gt;&gt; ui.transform(u, x**2 - 1) == i</span>
<span class="sd">        True</span>

<span class="sd">        If the `x` does not contain a symbol of integration then</span>
<span class="sd">        the integral will be returned unchanged. Integral `i` does</span>
<span class="sd">        not have an integration variable `a` so no change is made:</span>

<span class="sd">        &gt;&gt;&gt; i.transform(a, x) == i</span>
<span class="sd">        True</span>

<span class="sd">        When `u` has more than one free symbol the symbol that is</span>
<span class="sd">        replacing `x` must be identified by passing `u` as a tuple:</span>

<span class="sd">        &gt;&gt;&gt; Integral(x, (x, 0, 1)).transform(x, (u + a, u))</span>
<span class="sd">        Integral(a + u, (u, -a, -a + 1))</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (x, 0, 1)).transform(x, (u + a, a))</span>
<span class="sd">        Integral(a + u, (a, -u, -u + 1))</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.concrete.expr_with_limits.ExprWithLimits.variables : Lists the integration variables</span>
<span class="sd">        diofant.concrete.expr_with_limits.ExprWithLimits.as_dummy : Replace integration variables with dummy ones</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..solvers</span> <span class="k">import</span> <span class="n">solve</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">posify</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="n">xfree</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xfree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;F(x) can only contain one of: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">xvar</span> <span class="o">=</span> <span class="n">xfree</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="n">xfree</span> <span class="k">else</span> <span class="n">d</span>

        <span class="k">if</span> <span class="n">xvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="n">ufree</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ufree</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                When f(u) has more than one free symbol, the one replacing x</span>
<span class="s1">                must be identified: pass f(u) as (f(u), u)&#39;&#39;&#39;</span><span class="p">))</span>
            <span class="n">uvar</span> <span class="o">=</span> <span class="n">ufree</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">uvar</span> <span class="o">=</span> <span class="n">u</span>
            <span class="k">if</span> <span class="n">uvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                Expecting a tuple (expr, symbol) where symbol identified</span>
<span class="s1">                a free symbol in expr, but symbol is not in expr&#39;s free</span>
<span class="s1">                symbols.&#39;&#39;&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uvar</span><span class="p">,</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                Expecting a tuple (expr, symbol) but didn&#39;t get</span>
<span class="s1">                a symbol; got </span><span class="si">%s</span><span class="s1">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">uvar</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">u</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">u</span><span class="p">})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;either x or u must be a symbol&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">uvar</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">uvar</span><span class="p">:</span> <span class="n">d</span><span class="p">}),</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">uvar</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">uvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            u must contain the same variable as in x</span>
<span class="s1">            or a variable that is not already an integration variable&#39;&#39;&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xvar</span><span class="p">:</span> <span class="n">d</span><span class="p">})]</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">soln</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no solution for solve(F(x) - f(u), x)&#39;</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">xvar</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">uvar</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">uvar</span><span class="p">:</span> <span class="n">d</span><span class="p">})]</span>
            <span class="n">pdiff</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">puvar</span> <span class="o">=</span> <span class="n">uvar</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">puvar</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solve</span><span class="p">(</span><span class="n">pdiff</span><span class="p">,</span> <span class="n">puvar</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">soln</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no solution for solve(F(x) - f(u), u)&#39;</span><span class="p">)</span>
            <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xvar</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]</span>

        <span class="n">newfuncs</span> <span class="o">=</span> <span class="p">{(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xvar</span><span class="p">:</span> <span class="n">fi</span><span class="p">})</span><span class="o">*</span><span class="n">fi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">uvar</span><span class="p">})</span>
                    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newfuncs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            The mapping between F(x) and f(u) did not give</span>
<span class="s1">            a unique integrand.&#39;&#39;&#39;</span><span class="p">))</span>
        <span class="n">newfunc</span> <span class="o">=</span> <span class="n">newfuncs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_calc_limit_1</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            replace d with a, using subs if possible, otherwise limit</span>
<span class="sd">            where sign of b is considered</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">wok</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">wok</span> <span class="ow">is</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">wok</span><span class="o">.</span><span class="n">is_finite</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_finite</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">limit</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">F</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">wok</span>

        <span class="k">def</span> <span class="nf">_calc_limit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            replace d with a, using subs if possible, otherwise limit</span>
<span class="sd">            where sign of b is considered</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">avals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">_calc_limit_1</span><span class="p">(</span><span class="n">Fi</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">Fi</span> <span class="ow">in</span> <span class="n">F</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                The mapping between F(x) and f(u) did not</span>
<span class="s1">                give a unique limit.&#39;&#39;&#39;</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">avals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">newlimits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_calc_limit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">_calc_limit</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
                        <span class="n">newfunc</span> <span class="o">=</span> <span class="o">-</span><span class="n">newfunc</span>
                    <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uvar</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">_calc_limit</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uvar</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uvar</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">newfunc</span><span class="p">,</span> <span class="o">*</span><span class="n">newlimits</span><span class="p">)</span></div>

<div class="viewcode-block" id="Integral.doit"><a class="viewcode-back" href="../../../modules/integrals.html#diofant.integrals.integrals.Integral.doit">[docs]</a>    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the integration using any hints given.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from diofant.abc import i</span>
<span class="sd">        &gt;&gt;&gt; Integral(x**i, (i, 1, 3)).doit()</span>
<span class="sd">        Piecewise((2, Eq(log(x), 0)), (x**3/log(x) - x/log(x), true))</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.integrals.trigonometry.trigintegrate</span>
<span class="sd">        diofant.integrals.heurisch.heurisch</span>
<span class="sd">        diofant.integrals.rationaltools.ratint</span>
<span class="sd">        diofant.integrals.integrals.Integral.as_sum : Approximate the integral using a sum</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;integrals&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">deep</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;deep&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">meijerg</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;meijerg&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">conds</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;conds&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">)</span>
        <span class="n">risch</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;risch&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">conds</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;separate&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;conds must be one of &quot;separate&quot;, &quot;piecewise&quot;, &#39;</span>
                             <span class="s1">&#39;&quot;none&quot;, got: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">conds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">risch</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;risch=True is only allowed for indefinite integrals.&#39;</span><span class="p">)</span>

        <span class="c1"># check for the trivial zero</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># now compute and check the function</span>
        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># There is no trivial answer, so continue</span>

        <span class="n">undone_limits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ulj = free symbols of any undone limits&#39; upper and lower limits</span>
        <span class="n">ulj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="c1"># compute uli, the free symbols in the</span>
            <span class="c1"># Upper and Lower limits of limit I</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">uli</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">xab</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">uli</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">uli</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
            <span class="c1"># this integral can be done as long as there is no blocking</span>
            <span class="c1"># limit that has been undone. An undone limit is blocking if</span>
            <span class="c1"># it contains an integration variable that is in this limit&#39;s</span>
            <span class="c1"># upper or lower free symbols or vice versa</span>
            <span class="k">if</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">ulj</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">uli</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">undone_limits</span><span class="p">):</span>
                <span class="n">undone_limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>
                <span class="n">ulj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">uli</span><span class="p">)</span>
                <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">function</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">xab</span><span class="p">]))</span>
                <span class="n">factored_function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factored_function</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">factored_function</span>
                <span class="k">continue</span>

            <span class="c1"># There are a number of tradeoffs in using the Meijer G method.</span>
            <span class="c1"># It can sometimes be a lot faster than other methods, and</span>
            <span class="c1"># sometimes slower. And there are certain types of integrals for</span>
            <span class="c1"># which it is more likely to work than others.</span>
            <span class="c1"># These heuristics are incorporated in deciding what integration</span>
            <span class="c1"># methods to try, in what order.</span>
            <span class="c1"># See the integrate() docstring for details.</span>
            <span class="k">def</span> <span class="nf">try_meijerg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">meijerg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">meijerint_definite</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="kn">from</span> <span class="nn">.meijerint</span> <span class="k">import</span> <span class="n">_debug</span>
                        <span class="n">_debug</span><span class="p">(</span><span class="s1">&#39;NotImplementedError from meijerint_definite&#39;</span><span class="p">)</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">,</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">res</span>
                        <span class="k">if</span> <span class="n">conds</span> <span class="o">==</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">:</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">cond</span><span class="p">),</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span> <span class="kc">True</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">conds</span> <span class="o">==</span> <span class="s1">&#39;separate&#39;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;conds=separate not supported in &#39;</span>
                                                 <span class="s1">&#39;multiple integrals&#39;</span><span class="p">)</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">cond</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="n">meijerg1</span> <span class="o">=</span> <span class="n">meijerg</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="ow">and</span> \
                    <span class="ow">not</span> <span class="n">function</span><span class="o">.</span><span class="n">is_Poly</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="ow">or</span>
                     <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">try_meijerg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">ret</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">meijerg1</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># If the special meijerg code did not succeed in finding a definite</span>
            <span class="c1"># integral, then the code using meijerint_indefinite will not either</span>
            <span class="c1"># (it might find an antiderivative, but the answer is likely to be</span>
            <span class="c1">#  nonsensical).</span>
            <span class="c1"># Thus if we are requested to only use Meijer G-function methods,</span>
            <span class="c1"># we give up at this stage. Otherwise we just disable G-function</span>
            <span class="c1"># methods.</span>
            <span class="k">if</span> <span class="n">meijerg1</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">meijerg</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">antideriv</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Rewrite to Piecewise if possible</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="ow">and</span>
                            <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">extended_real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">r</span><span class="p">})</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">)</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">piecewise_fold</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>

                <span class="n">antideriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span>
                    <span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">meijerg</span><span class="o">=</span><span class="n">meijerg</span><span class="p">,</span> <span class="n">risch</span><span class="o">=</span><span class="n">risch</span><span class="p">,</span>
                    <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">antideriv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meijerg1</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">try_meijerg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">ret</span>
                        <span class="k">continue</span>

            <span class="k">if</span> <span class="n">antideriv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">undone_limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>
                <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">function</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">xab</span><span class="p">]))</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
                <span class="n">factored_function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factored_function</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">factored_function</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">antideriv</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

                    <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">is_Poly</span><span class="p">:</span>
                        <span class="n">gens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">antideriv</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                        <span class="n">antideriv</span> <span class="o">=</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>

                        <span class="n">function</span> <span class="o">=</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">_eval_interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">antideriv</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">and</span>
                          <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">_eval_interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                         <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">antideriv</span><span class="p">)])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">def</span> <span class="nf">is_indef_int</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                            <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span>
                                    <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">limits</span><span class="p">))</span>

                        <span class="k">def</span> <span class="nf">eval_factored</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                            <span class="c1"># _eval_interval for integrals with</span>
                            <span class="c1"># (constant) factors</span>
                            <span class="c1"># a single indefinite integral is assumed</span>
                            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">is_indef_int</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_eval_interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

                        <span class="n">integrals</span><span class="p">,</span> <span class="n">others</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">antideriv</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_indef_int</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">f</span><span class="p">)):</span>
                                <span class="n">integrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">others</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                        <span class="n">uneval</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">eval_factored</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">integrals</span><span class="p">])</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">evalued</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">others</span><span class="p">)</span><span class="o">.</span><span class="n">_eval_interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                            <span class="n">function</span> <span class="o">=</span> <span class="n">uneval</span> <span class="o">+</span> <span class="n">evalued</span>
                        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                            <span class="c1"># This can happen if _eval_interval depends in a</span>
                            <span class="c1"># complicated way on limits that cannot be computed</span>
                            <span class="n">undone_limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>
                            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">function</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">xab</span><span class="p">]))</span>
                            <span class="n">factored_function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factored_function</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                                <span class="n">function</span> <span class="o">=</span> <span class="n">factored_function</span>
        <span class="k">return</span> <span class="n">function</span></div>

    <span class="k">def</span> <span class="nf">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the derivative of the current Integral object by</span>
<span class="sd">        differentiating under the integral sign [1], using the Fundamental</span>
<span class="sd">        Theorem of Calculus [2] when possible.</span>

<span class="sd">        Whenever an Integral is encountered that is equivalent to zero or</span>
<span class="sd">        has an integrand that is independent of the variable of integration</span>
<span class="sd">        those integrals are performed. All others are returned as Integral</span>
<span class="sd">        instances which can be resolved with doit() (provided they are integrable).</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        * https://en.wikipedia.org/wiki/Differentiation_under_the_integral_sign</span>
<span class="sd">        * https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; i = Integral(x + y, y, (y, 1, x))</span>
<span class="sd">        &gt;&gt;&gt; i.diff(x)</span>
<span class="sd">        Integral(x + y, (y, x)) + Integral(1, y, (y, 1, x))</span>
<span class="sd">        &gt;&gt;&gt; i.doit().diff(x) == i.diff(x).doit()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; i.diff(y)</span>
<span class="sd">        0</span>

<span class="sd">        The previous must be true since there is no y in the evaluated integral:</span>

<span class="sd">        &gt;&gt;&gt; i.free_symbols</span>
<span class="sd">        {x}</span>
<span class="sd">        &gt;&gt;&gt; i.doit()</span>
<span class="sd">        2*x**3/3 - x/2 - 1/6</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># differentiate under the integral sign; we do not</span>
        <span class="c1"># check for regularity conditions (TODO), see issue sympy/sympy#4215</span>

        <span class="c1"># get limits and the function</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>

        <span class="c1"># the order matters if variables of integration appear in the limits</span>
        <span class="c1"># so work our way in from the outside to the inside.</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">limits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limit</span>
            <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">limits</span><span class="p">:</span>  <span class="c1"># f is the argument to an integral</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">limits</span><span class="p">))</span>

        <span class="c1"># assemble the pieces</span>
        <span class="k">def</span> <span class="nf">_do</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ab</span><span class="p">):</span>
            <span class="n">dab_dsym</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dab_dsym</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">l</span>
                          <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">limits</span><span class="p">]</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">ab</span><span class="p">})</span><span class="o">*</span><span class="n">dab_dsym</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">+=</span> <span class="n">_do</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">-=</span> <span class="n">_do</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
            <span class="c1"># the dummy variable *is* also the real-world variable</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span>
            <span class="n">rv</span> <span class="o">+=</span> <span class="n">arg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the dummy variable might match sym but it&#39;s</span>
            <span class="c1"># only a dummy and the actual variable is determined</span>
            <span class="c1"># by the limits, so mask off the variable of integration</span>
            <span class="c1"># while differentiating</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">u</span><span class="p">})</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">u</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>
            <span class="n">rv</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">_eval_integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">meijerg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">risch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;piecewise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the anti-derivative to the function f(x).</span>

<span class="sd">        The following algorithms are applied (roughly in this order):</span>

<span class="sd">        1. Simple heuristics (based on pattern matching and integral table):</span>

<span class="sd">           - most frequently used functions (e.g. polynomials, products of trig functions)</span>

<span class="sd">        2. Integration of rational functions:</span>

<span class="sd">           - A complete algorithm for integrating rational functions is</span>
<span class="sd">             implemented (the Lazard-Rioboo-Trager algorithm).  The algorithm</span>
<span class="sd">             also uses the partial fraction decomposition algorithm</span>
<span class="sd">             implemented in apart() as a preprocessor to make this process</span>
<span class="sd">             faster.  Note that the integral of a rational function is always</span>
<span class="sd">             elementary, but in general, it may include a RootSum.</span>

<span class="sd">        3. Full Risch algorithm:</span>

<span class="sd">           - The Risch algorithm is a complete decision</span>
<span class="sd">             procedure for integrating elementary functions, which means that</span>
<span class="sd">             given any elementary function, it will either compute an</span>
<span class="sd">             elementary antiderivative, or else prove that none exists.</span>
<span class="sd">             Currently, part of transcendental case is implemented, meaning</span>
<span class="sd">             elementary integrals containing exponentials, logarithms, and</span>
<span class="sd">             (soon!) trigonometric functions can be computed.  The algebraic</span>
<span class="sd">             case, e.g., functions containing roots, is much more difficult</span>
<span class="sd">             and is not implemented yet.</span>

<span class="sd">           - If the routine fails (because the integrand is not elementary, or</span>
<span class="sd">             because a case is not implemented yet), it continues on to the</span>
<span class="sd">             next algorithms below.  If the routine proves that the integrals</span>
<span class="sd">             is nonelementary, it still moves on to the algorithms below,</span>
<span class="sd">             because we might be able to find a closed-form solution in terms</span>
<span class="sd">             of special functions.  If risch=True, however, it will stop here.</span>

<span class="sd">        4. The Meijer G-Function algorithm:</span>

<span class="sd">           - This algorithm works by first rewriting the integrand in terms of</span>
<span class="sd">             very general Meijer G-Function (meijerg in Diofant), integrating</span>
<span class="sd">             it, and then rewriting the result back, if possible.  This</span>
<span class="sd">             algorithm is particularly powerful for definite integrals (which</span>
<span class="sd">             is actually part of a different method of Integral), since it can</span>
<span class="sd">             compute closed-form solutions of definite integrals even when no</span>
<span class="sd">             closed-form indefinite integral exists.  But it also is capable</span>
<span class="sd">             of computing many indefinite integrals as well.</span>

<span class="sd">           - Another advantage of this method is that it can use some results</span>
<span class="sd">             about the Meijer G-Function to give a result in terms of a</span>
<span class="sd">             Piecewise expression, which allows to express conditionally</span>
<span class="sd">             convergent integrals.</span>

<span class="sd">           - Setting meijerg=True will cause integrate() to use only this</span>
<span class="sd">             method.</span>

<span class="sd">        5. The Heuristic Risch algorithm:</span>

<span class="sd">           - This is a heuristic version of the Risch algorithm, meaning that</span>
<span class="sd">             it is not deterministic.  This is tried as a last resort because</span>
<span class="sd">             it can be very slow.  It is still used because not enough of the</span>
<span class="sd">             full Risch algorithm is implemented, so that there are still some</span>
<span class="sd">             integrals that can only be computed using this method.  The goal</span>
<span class="sd">             is to implement enough of the Risch and Meijer G-function methods</span>
<span class="sd">             so that this can be deleted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.deltafunctions</span> <span class="k">import</span> <span class="n">deltaintegrate</span>
        <span class="kn">from</span> <span class="nn">.heurisch</span> <span class="k">import</span> <span class="n">heurisch</span><span class="p">,</span> <span class="n">heurisch_wrapper</span>
        <span class="kn">from</span> <span class="nn">.rationaltools</span> <span class="k">import</span> <span class="n">ratint</span>
        <span class="kn">from</span> <span class="nn">.risch</span> <span class="k">import</span> <span class="n">risch_integrate</span>

        <span class="k">if</span> <span class="n">risch</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">risch_integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="c1"># if it is a poly(x) then let the polynomial integrate itself (fast)</span>
        <span class="c1">#</span>
        <span class="c1"># It is important to make this check first, otherwise the other code</span>
        <span class="c1"># will return a diofant expression instead of a Polynomial.</span>
        <span class="c1">#</span>
        <span class="c1"># see Polynomial for details.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Poly</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Piecewise antiderivatives need to call special integrate.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># let&#39;s cut it short if `f` does not depend on `x`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="n">x</span>

        <span class="c1"># try to convert to poly(x) and then integrate if successful (fast)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">poly</span><span class="o">.</span><span class="n">integrate</span><span class="p">()</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">risch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">risch_integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">separate_integral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                    <span class="c1"># There was a nonelementary integral. Try integrating it.</span>
                    <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># since Integral(f=g1+g2+...) == Integral(g1) + Integral(g2) + ...</span>
        <span class="c1"># we are going to handle Add terms separately,</span>
        <span class="c1"># if `f` is not Add -- we only have one term</span>

        <span class="c1"># Note that in general, this is a bad idea, because Integral(g1) +</span>
        <span class="c1"># Integral(g2) might not be computable, even if Integral(g1 + g2) is.</span>
        <span class="c1"># For example, Integral(x**x + x**x*log(x)).  But many heuristics only</span>
        <span class="c1"># work term-wise.  So we compute this step last, after trying</span>
        <span class="c1"># risch_integrate.  We also try risch_integrate again in this loop,</span>
        <span class="c1"># because maybe the integral is a sum of an elementary part and a</span>
        <span class="c1"># nonelementary part (like erf(x) + exp(x)).  risch_integrate() is</span>
        <span class="c1"># quite fast, so this is acceptable.</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="c1"># g(x) = const</span>
            <span class="k">if</span> <span class="n">g</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># g(x) = expr + O(x**n)</span>
            <span class="n">order_term</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">removeO</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">order_term</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)))</span>
                    <span class="k">continue</span>

                <span class="c1"># NOTE: if there is O(x**n) and we fail to integrate then there is</span>
                <span class="c1"># no point in trying other methods because they will fail anyway.</span>
                <span class="k">return</span>

            <span class="c1">#               c</span>
            <span class="c1"># g(x) = (a*x+b)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

                <span class="n">M</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">conds</span> <span class="o">!=</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">h1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                        <span class="n">h2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">h1</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                    <span class="k">continue</span>

            <span class="c1">#        poly(x)</span>
            <span class="c1"># g(x) = -------</span>
            <span class="c1">#        poly(x)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">ratint</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="c1"># g(x) = Mul(trig)</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">trigintegrate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># g(x) has at least a DiracDelta term</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">deltaintegrate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Try risch again.</span>
                <span class="k">if</span> <span class="n">risch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">risch_integrate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">separate_integral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
                        <span class="k">continue</span>

                <span class="c1"># fall back to heurisch</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">conds</span> <span class="o">==</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">heurisch_wrapper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">hints</span><span class="o">=</span><span class="p">[])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">heurisch</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">hints</span><span class="o">=</span><span class="p">[])</span>
                <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
                    <span class="c1"># XXX: this exception means there is a bug in the</span>
                    <span class="c1"># implementation of heuristic Risch integration</span>
                    <span class="c1"># algorithm.</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">meijerg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># rewrite using G functions</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">meijerint_indefinite</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">.meijerint</span> <span class="k">import</span> <span class="n">_debug</span>
                    <span class="n">_debug</span><span class="p">(</span><span class="s1">&#39;NotImplementedError from meijerint_definite&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="c1"># if we failed maybe it was because we had</span>
            <span class="c1"># a product that could have been expanded,</span>
            <span class="c1"># so let&#39;s try an expansion of the whole</span>
            <span class="c1"># thing before giving up; we don&#39;t try this</span>
            <span class="c1"># at the outset because there are things</span>
            <span class="c1"># that cannot be solved unless they are</span>
            <span class="c1"># NOT expanded e.g., x**x*(1+log(x)). There</span>
            <span class="c1"># should probably be a checker somewhere in this</span>
            <span class="c1"># routine to look for such cases and try to do</span>
            <span class="c1"># collection on the expressions if they are already</span>
            <span class="c1"># in an expanded form</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">h</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">sincos_to_sum</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="c1"># Note: risch will be identical on the expanded</span>
                    <span class="c1"># expression, but maybe it will be able to pick out parts,</span>
                    <span class="c1"># like x*(exp(x) + erf(x)).</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">meijerg</span><span class="o">=</span><span class="n">meijerg</span><span class="p">,</span> <span class="n">risch</span><span class="o">=</span><span class="n">risch</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">parts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
        <span class="n">symb</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">symb</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">lseries</span><span class="p">(</span><span class="n">symb</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">integrate</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
        <span class="n">symb</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">symb</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">symb</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">+</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">order</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>

<div class="viewcode-block" id="Integral.as_sum"><a class="viewcode-back" href="../../../modules/integrals.html#diofant.integrals.integrals.Integral.as_sum">[docs]</a>    <span class="k">def</span> <span class="nf">as_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;midpoint&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximates the definite integral by a sum.</span>

<span class="sd">        method ... one of: left, right, midpoint, trapezoid</span>

<span class="sd">        These are all basically the rectangle method [1], the only difference</span>
<span class="sd">        is where the function value is taken in each interval to define the</span>
<span class="sd">        rectangle.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        * https://en.wikipedia.org/wiki/Rectangle_method</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; e = Integral(sin(x), (x, 3, 7))</span>
<span class="sd">        &gt;&gt;&gt; e</span>
<span class="sd">        Integral(sin(x), (x, 3, 7))</span>

<span class="sd">        For demonstration purposes, this interval will only be split into 2</span>
<span class="sd">        regions, bounded by [3, 5] and [5, 7].</span>

<span class="sd">        The left-hand rule uses function evaluations at the left of each</span>
<span class="sd">        interval:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;left&#39;)</span>
<span class="sd">        2*sin(5) + 2*sin(3)</span>

<span class="sd">        The midpoint rule uses evaluations at the center of each interval:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;midpoint&#39;)</span>
<span class="sd">        2*sin(4) + 2*sin(6)</span>

<span class="sd">        The right-hand rule uses function evaluations at the right of each</span>
<span class="sd">        interval:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;right&#39;)</span>
<span class="sd">        2*sin(5) + 2*sin(7)</span>

<span class="sd">        The trapezoid rule uses function evaluations on both sides of the</span>
<span class="sd">        intervals. This is equivalent to taking the average of the left and</span>
<span class="sd">        right hand rule results:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;trapezoid&#39;)</span>
<span class="sd">        2*sin(5) + sin(3) + sin(7)</span>
<span class="sd">        &gt;&gt;&gt; (e.as_sum(2, &#39;left&#39;) + e.as_sum(2, &#39;right&#39;))/2 == _</span>
<span class="sd">        True</span>

<span class="sd">        All but the trapexoid method may be used when dealing with a function</span>
<span class="sd">        with a discontinuity. Here, the discontinuity at x = 0 can be avoided</span>
<span class="sd">        by using the midpoint or right-hand method:</span>

<span class="sd">        &gt;&gt;&gt; e = Integral(1/sqrt(x), (x, 0, 1))</span>
<span class="sd">        &gt;&gt;&gt; e.as_sum(5).evalf(4)</span>
<span class="sd">        1.730</span>
<span class="sd">        &gt;&gt;&gt; e.as_sum(10).evalf(4)</span>
<span class="sd">        1.809</span>
<span class="sd">        &gt;&gt;&gt; e.doit().evalf(4)  # the actual value is 2</span>
<span class="sd">        2.000</span>

<span class="sd">        The left- or trapezoid method will encounter the discontinuity and</span>
<span class="sd">        return oo:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(5, &#39;left&#39;)</span>
<span class="sd">        oo</span>
<span class="sd">        &gt;&gt;&gt; e.as_sum(5, &#39;trapezoid&#39;)</span>
<span class="sd">        oo</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.integrals.integrals.Integral.doit : Perform the integration using any hints</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Multidimensional midpoint rule not implemented yet&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a definite integral.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">oo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Infinite summation not yet implemented&quot;</span><span class="p">)</span>
        <span class="n">sym</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">,</span> <span class="n">upper_limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper_limit</span> <span class="o">-</span> <span class="n">lower_limit</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;trapezoid&#39;</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">upper_limit</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">sym</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">*</span><span class="n">dx</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;midpoint&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unknown method </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dx</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">upper_limit</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">sym</span><span class="p">:</span> <span class="n">xi</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">*</span><span class="n">dx</span></div></div>


<div class="viewcode-block" id="integrate"><a class="viewcode-back" href="../../../modules/integrals.html#diofant.integrals.integrals.integrate">[docs]</a><span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;integrate(f, var, ...)</span>

<span class="sd">    Compute definite or indefinite integral of one or more variables</span>
<span class="sd">    using Risch-Norman algorithm and table lookup. This procedure is</span>
<span class="sd">    able to handle elementary algebraic and transcendental functions</span>
<span class="sd">    and also a huge class of special functions, including Airy,</span>
<span class="sd">    Bessel, Whittaker and Lambert.</span>

<span class="sd">    var can be:</span>

<span class="sd">    - a symbol                   -- indefinite integration</span>
<span class="sd">    - a tuple (symbol, a)        -- indefinite integration with result</span>
<span class="sd">                                    given with `a` replacing `symbol`</span>
<span class="sd">    - a tuple (symbol, a, b)     -- definite integration</span>

<span class="sd">    Several variables can be specified, in which case the result is</span>
<span class="sd">    multiple integration. (If var is omitted and the integrand is</span>
<span class="sd">    univariate, the indefinite integral in that variable will be performed.)</span>

<span class="sd">    Indefinite integrals are returned without terms that are independent</span>
<span class="sd">    of the integration variables. (see examples)</span>

<span class="sd">    Definite improper integrals often entail delicate convergence</span>
<span class="sd">    conditions. Pass conds=&#39;piecewise&#39;, &#39;separate&#39; or &#39;none&#39; to have</span>
<span class="sd">    these returned, respectively, as a Piecewise function, as a separate</span>
<span class="sd">    result (i.e. result will be a tuple), or not at all (default is</span>
<span class="sd">    &#39;piecewise&#39;).</span>

<span class="sd">    **Strategy**</span>

<span class="sd">    Diofant uses various approaches to definite integration. One method is to</span>
<span class="sd">    find an antiderivative for the integrand, and then use the fundamental</span>
<span class="sd">    theorem of calculus. Various functions are implemented to integrate</span>
<span class="sd">    polynomial, rational and trigonometric functions, and integrands</span>
<span class="sd">    containing DiracDelta terms.</span>

<span class="sd">    Diofant also implements the part of the Risch algorithm, which is a decision</span>
<span class="sd">    procedure for integrating elementary functions, i.e., the algorithm can</span>
<span class="sd">    either find an elementary antiderivative, or prove that one does not</span>
<span class="sd">    exist.  There is also a (very successful, albeit somewhat slow) general</span>
<span class="sd">    implementation of the heuristic Risch algorithm.  This algorithm will</span>
<span class="sd">    eventually be phased out as more of the full Risch algorithm is</span>
<span class="sd">    implemented. See the docstring of Integral._eval_integral() for more</span>
<span class="sd">    details on computing the antiderivative using algebraic methods.</span>

<span class="sd">    The option risch=True can be used to use only the (full) Risch algorithm.</span>
<span class="sd">    This is useful if you want to know if an elementary function has an</span>
<span class="sd">    elementary antiderivative.  If the indefinite Integral returned by this</span>
<span class="sd">    function is an instance of NonElementaryIntegral, that means that the</span>
<span class="sd">    Risch algorithm has proven that integral to be non-elementary.  Note that</span>
<span class="sd">    by default, additional methods (such as the Meijer G method outlined</span>
<span class="sd">    below) are tried on these integrals, as they may be expressible in terms</span>
<span class="sd">    of special functions, so if you only care about elementary answers, use</span>
<span class="sd">    risch=True.  Also note that an unevaluated Integral returned by this</span>
<span class="sd">    function is not necessarily a NonElementaryIntegral, even with risch=True,</span>
<span class="sd">    as it may just be an indication that the particular part of the Risch</span>
<span class="sd">    algorithm needed to integrate that function is not yet implemented.</span>

<span class="sd">    Another family of strategies comes from re-writing the integrand in</span>
<span class="sd">    terms of so-called Meijer G-functions. Indefinite integrals of a</span>
<span class="sd">    single G-function can always be computed, and the definite integral</span>
<span class="sd">    of a product of two G-functions can be computed from zero to</span>
<span class="sd">    infinity. Various strategies are implemented to rewrite integrands</span>
<span class="sd">    as G-functions, and use this information to compute integrals (see</span>
<span class="sd">    the ``meijerint`` module).</span>

<span class="sd">    In general, the algebraic methods work best for computing</span>
<span class="sd">    antiderivatives of (possibly complicated) combinations of elementary</span>
<span class="sd">    functions. The G-function methods work best for computing definite</span>
<span class="sd">    integrals from zero to infinity of moderately complicated</span>
<span class="sd">    combinations of special functions, or indefinite integrals of very</span>
<span class="sd">    simple combinations of special functions.</span>

<span class="sd">    The strategy employed by the integration code is as follows:</span>

<span class="sd">    - If computing a definite integral, and both limits are real,</span>
<span class="sd">      and at least one limit is +- oo, try the G-function method of</span>
<span class="sd">      definite integration first.</span>

<span class="sd">    - Try to find an antiderivative, using all available methods, ordered</span>
<span class="sd">      by performance (that is try fastest method first, slowest last; in</span>
<span class="sd">      particular polynomial integration is tried first, Meijer</span>
<span class="sd">      G-functions second to last, and heuristic Risch last).</span>

<span class="sd">    - If still not successful, try G-functions irrespective of the</span>
<span class="sd">      limits.</span>

<span class="sd">    The option meijerg=True, False, None can be used to, respectively:</span>
<span class="sd">    always use G-function methods and no others, never use G-function</span>
<span class="sd">    methods, or use all available methods (in order as described above).</span>
<span class="sd">    It defaults to None.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; integrate(x*y, x)</span>
<span class="sd">    x**2*y/2</span>

<span class="sd">    &gt;&gt;&gt; integrate(log(x), x)</span>
<span class="sd">    x*log(x) - x</span>

<span class="sd">    &gt;&gt;&gt; integrate(log(x), (x, 1, a))</span>
<span class="sd">    a*log(a) - a + 1</span>

<span class="sd">    &gt;&gt;&gt; integrate(x)</span>
<span class="sd">    x**2/2</span>

<span class="sd">    Terms that are independent of x are dropped by indefinite integration:</span>

<span class="sd">    &gt;&gt;&gt; integrate(sqrt(1 + x), (x, 0, x))</span>
<span class="sd">    2*(x + 1)**(3/2)/3 - 2/3</span>
<span class="sd">    &gt;&gt;&gt; integrate(sqrt(1 + x), x)</span>
<span class="sd">    2*(x + 1)**(3/2)/3</span>

<span class="sd">    &gt;&gt;&gt; integrate(x*y)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: specify integration variables to integrate x*y</span>

<span class="sd">    Note that ``integrate(x)`` syntax is meant only for convenience</span>
<span class="sd">    in interactive sessions and should be avoided in library code.</span>

<span class="sd">    &gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo)) # same as conds=&#39;piecewise&#39;</span>
<span class="sd">    Piecewise((gamma(a + 1), -re(a) &lt; 1),</span>
<span class="sd">        (Integral(E**(-x)*x**a, (x, 0, oo)), true))</span>

<span class="sd">    &gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo), conds=&#39;none&#39;)</span>
<span class="sd">    gamma(a + 1)</span>

<span class="sd">    &gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo), conds=&#39;separate&#39;)</span>
<span class="sd">    (gamma(a + 1), -re(a) &lt; 1)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    diofant.integrals.integrals.Integral</span>
<span class="sd">    diofant.integrals.integrals.Integral.doit</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">meijerg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;meijerg&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;conds&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">)</span>
    <span class="n">risch</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;risch&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">integral</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integral</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">integral</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">meijerg</span><span class="o">=</span><span class="n">meijerg</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">,</span>
                             <span class="n">risch</span><span class="o">=</span><span class="n">risch</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">integral</span></div>


<div class="viewcode-block" id="line_integrate"><a class="viewcode-back" href="../../../modules/integrals.html#diofant.integrals.integrals.line_integrate">[docs]</a><span class="k">def</span> <span class="nf">line_integrate</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">curve</span><span class="p">,</span> <span class="nb">vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;line_integrate(field, Curve, variables)</span>

<span class="sd">    Compute the line integral.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; C = Curve([E**t + 1, E**t - 1], (t, 0, ln(2)))</span>
<span class="sd">    &gt;&gt;&gt; line_integrate(x + y, C, [x, y])</span>
<span class="sd">    3*sqrt(2)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    diofant.integrals.integrals.integrate</span>
<span class="sd">    diofant.integrals.integrals.Integral</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..geometry</span> <span class="k">import</span> <span class="n">Curve</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">F</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Expecting function specifying field as first argument.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="n">Curve</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting Curve entity as second argument.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting ordered iterable for variables.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Field variable size does not match curve dimension.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">curve</span><span class="o">.</span><span class="n">parameter</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Curve parameter clashes with field parameters.&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate derivatives for line parameter functions</span>
    <span class="c1"># F(r) -&gt; F(r(t)) and finally F(r(t)*r&#39;(t))</span>
    <span class="n">Ft</span> <span class="o">=</span> <span class="n">F</span>
    <span class="n">dldt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">_dn</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">_f</span><span class="p">,</span> <span class="n">curve</span><span class="o">.</span><span class="n">parameter</span><span class="p">)</span>
        <span class="c1"># ...arc length</span>
        <span class="n">dldt</span> <span class="o">=</span> <span class="n">dldt</span> <span class="o">+</span> <span class="p">(</span><span class="n">_dn</span> <span class="o">*</span> <span class="n">_dn</span><span class="p">)</span>
        <span class="n">Ft</span> <span class="o">=</span> <span class="n">Ft</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">var</span><span class="p">:</span> <span class="n">_f</span><span class="p">})</span>
    <span class="n">Ft</span> <span class="o">=</span> <span class="n">Ft</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dldt</span><span class="p">)</span>

    <span class="n">integral</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="n">Ft</span><span class="p">,</span> <span class="n">curve</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">integral</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2006-2018 SymPy Development Team, 2013-2019 Sergey B Kirpichev

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>