

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diofant.solvers.solvers &mdash; Diofant 0.10.1.dev253+g4a5e049 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Diofant
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../internals/index.html">Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../aboutus.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Diofant</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>diofant.solvers.solvers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diofant.solvers.solvers</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contain solvers for all kinds of equations,</span>
<span class="sd">algebraic or transcendental.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">GeneratorType</span>

<span class="kn">from</span> <span class="nn">..core</span> <span class="k">import</span> <span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">Equality</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Ge</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span>
                    <span class="n">Integer</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">expand_log</span><span class="p">,</span>
                    <span class="n">expand_mul</span><span class="p">,</span> <span class="n">expand_multinomial</span><span class="p">,</span> <span class="n">expand_power_exp</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span>
                    <span class="n">nfloat</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">preorder_traversal</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">zoo</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..core.assumptions</span> <span class="k">import</span> <span class="n">check_assumptions</span>
<span class="kn">from</span> <span class="nn">..core.compatibility</span> <span class="k">import</span> <span class="p">(</span><span class="n">default_sort_key</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span>
                                  <span class="n">ordered</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..core.function</span> <span class="k">import</span> <span class="n">AppliedUndef</span>
<span class="kn">from</span> <span class="nn">..core.logic</span> <span class="k">import</span> <span class="n">fuzzy_and</span>
<span class="kn">from</span> <span class="nn">..core.relational</span> <span class="k">import</span> <span class="n">Relational</span>
<span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="p">(</span><span class="n">Abs</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">acos</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">asin</span><span class="p">,</span> <span class="n">atan</span><span class="p">,</span>
                         <span class="n">atan2</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">piecewise_fold</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span>
                         <span class="n">sqrt</span><span class="p">,</span> <span class="n">tan</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..functions.elementary.hyperbolic</span> <span class="k">import</span> <span class="n">HyperbolicFunction</span>
<span class="kn">from</span> <span class="nn">..functions.elementary.trigonometric</span> <span class="k">import</span> <span class="n">TrigonometricFunction</span>
<span class="kn">from</span> <span class="nn">..matrices</span> <span class="k">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">zeros</span>
<span class="kn">from</span> <span class="nn">..polys</span> <span class="k">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">roots</span>
<span class="kn">from</span> <span class="nn">..polys.polyerrors</span> <span class="k">import</span> <span class="n">PolynomialError</span>
<span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">logcombine</span><span class="p">,</span> <span class="n">nsimplify</span><span class="p">,</span> <span class="n">posify</span><span class="p">,</span> <span class="n">powdenest</span><span class="p">,</span>
                        <span class="n">powsimp</span><span class="p">,</span> <span class="n">simplify</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..simplify.fu</span> <span class="k">import</span> <span class="n">TR1</span>
<span class="kn">from</span> <span class="nn">..simplify.sqrtdenest</span> <span class="k">import</span> <span class="n">unrad</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">filldedent</span>
<span class="kn">from</span> <span class="nn">..utilities.iterables</span> <span class="k">import</span> <span class="n">uniq</span>
<span class="kn">from</span> <span class="nn">.polysys</span> <span class="k">import</span> <span class="n">solve_linear_system</span><span class="p">,</span> <span class="n">solve_poly_system</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="s1">&#39;solve&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_linear&#39;</span><span class="p">,</span> <span class="s1">&#39;minsolve_linear_system&#39;</span><span class="p">,</span> <span class="s1">&#39;checksol&#39;</span>


<span class="k">def</span> <span class="nf">denoms</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return (recursively) set of all denominators that appear in eq</span>
<span class="sd">    that contain any symbol in iterable ``symbols``; if ``symbols`` is</span>
<span class="sd">    None (default) then all denominators will be returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; denoms(x/y)</span>
<span class="sd">    {y}</span>
<span class="sd">    &gt;&gt;&gt; denoms(x/(y*z))</span>
<span class="sd">    {y, z}</span>
<span class="sd">    &gt;&gt;&gt; denoms(3/x + y/z)</span>
<span class="sd">    {x, z}</span>
<span class="sd">    &gt;&gt;&gt; denoms(x/2 + y/z)</span>
<span class="sd">    {2, z}</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">denom</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">den</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">den</span><span class="p">):</span>
            <span class="n">dens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dens</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">:</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">free</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">):</span>
            <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>


<div class="viewcode-block" id="checksol"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#diofant.solvers.solvers.checksol">[docs]</a><span class="k">def</span> <span class="nf">checksol</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks whether sol is a solution of equations f.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; checksol(x**4 - 1, {x: 1})</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**4 - 1, {x: 0})</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**2 + y**2 - 5**2, {x: 3, y: 4})</span>
<span class="sd">    True</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    bool or None</span>
<span class="sd">        Return True, if solution satisfy all equations</span>
<span class="sd">        in ``f``.  Return False, if a solution doesn&#39;t</span>
<span class="sd">        satisfy any equation.  Else (i.e. one or more checks</span>
<span class="sd">        are inconclusive), return None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : Expr or iterable of Expr&#39;s</span>
<span class="sd">        Equations to substitute solutions in.</span>
<span class="sd">    sol : dict of Expr&#39;s</span>
<span class="sd">        Mapping of symbols to values.</span>
<span class="sd">    \*\*flags : dict</span>
<span class="sd">        A dictionary of following parameters:</span>

<span class="sd">        minimal : bool, optional</span>
<span class="sd">            Do a very fast, minimal testing.  Default is False.</span>
<span class="sd">        warn : bool, optional</span>
<span class="sd">            Show a warning if :func:`~diofant.solvers.solvers.checksol`</span>
<span class="sd">            could not conclude.  Default is False.</span>
<span class="sd">        simplify : bool, optional</span>
<span class="sd">            Simplify solution before substituting into function and</span>
<span class="sd">            simplify the function before trying specific simplifications.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        force : bool, optional</span>
<span class="sd">           Make positive all symbols without assumptions regarding</span>
<span class="sd">           sign.  Default is False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minimal</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;minimal&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting dictionary but got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sol</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">sol</span><span class="p">)):</span>
        <span class="c1"># if f(y) == 0, x=3 does not set f(y) to zero...nor does it not</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">is_zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>

    <span class="n">illegal</span> <span class="o">=</span> <span class="p">{</span><span class="n">nan</span><span class="p">,</span> <span class="n">zoo</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">illegal</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">was</span> <span class="o">=</span> <span class="n">f</span>
    <span class="n">attempt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">illegal</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">val</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">sol</span><span class="p">),</span> <span class="n">simplify</span><span class="o">=</span><span class="ow">not</span> <span class="n">minimal</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># there are free symbols -- simple expansion might work</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minimal</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
                    <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="c1"># start over without the failed expanded form, possibly</span>
            <span class="c1"># with a simplified solution</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="c1"># expansion may work now, so try again and check</span>
                <span class="n">exval</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">exval</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">exval</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="c1"># we can decide now</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">exval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if there are no radicals and no functions then this can&#39;t be</span>
            <span class="c1"># zero anymore -- can it?</span>
            <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">saw_pow_func</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">saw_pow_func</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="c1"># don&#39;t do a zero check with the positive assumptions in place</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">is_nonzero</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">)</span>
        <span class="n">was</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Warning: could not verify solution </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">sol</span><span class="p">)</span></div>


<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#diofant.solvers.solvers.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Algebraically solves equation or system of equations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : Expr, Equality or iterable of above</span>
<span class="sd">        All expressions are assumed to be equal to 0.</span>

<span class="sd">    \*symbols : tuple</span>
<span class="sd">        If none symbols given (empty tuple), free symbols</span>
<span class="sd">        of expressions will be used.</span>

<span class="sd">    \*\*flags : dict</span>
<span class="sd">        A dictionary of following parameters:</span>

<span class="sd">        check : bool, optional</span>
<span class="sd">            If False, don&#39;t do any testing of solutions.  Default is</span>
<span class="sd">            True, i.e. the solutions are checked and those that doesn&#39;t</span>
<span class="sd">            satisfy given assumptions on symbols solved for or make any</span>
<span class="sd">            denominator zero - are automatically excluded.</span>
<span class="sd">        warn : bool, optional</span>
<span class="sd">            Show a warning if :func:`~diofant.solvers.solvers.checksol`</span>
<span class="sd">            could not conclude.  Default is False.</span>
<span class="sd">        simplify : bool, optional</span>
<span class="sd">            Enable simplification (default) for all but polynomials of</span>
<span class="sd">            order 3 or greater before returning them and (if check is</span>
<span class="sd">            not False) use the general simplify function on the solutions</span>
<span class="sd">            and the expression obtained when they are substituted into the</span>
<span class="sd">            function which should be zero.</span>
<span class="sd">        rational : bool or None, optional</span>
<span class="sd">            If True, recast Floats as Rational.  If None (default),</span>
<span class="sd">            Floats will be recast as rationals but the answer will be</span>
<span class="sd">            recast as Floats.  If the flag is False then nothing</span>
<span class="sd">            will be done to the Floats.</span>
<span class="sd">        cubics, quartics, quintics : bool, optional</span>
<span class="sd">            Return explicit solutions (with radicals, which can be quite</span>
<span class="sd">            long) when, respectively, cubic, quartic or quintic expressions</span>
<span class="sd">            are encountered.  Default is True.  If False,</span>
<span class="sd">            :class:`~diofant.polys.rootoftools.RootOf` instances will</span>
<span class="sd">            be returned instead.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    Single equation:</span>

<span class="sd">    &gt;&gt;&gt; solve(x**2 - y**2)</span>
<span class="sd">    [{x: -y}, {x: y}]</span>
<span class="sd">    &gt;&gt;&gt; solve(x**2 - 1)</span>
<span class="sd">    [{x: -1}, {x: 1}]</span>

<span class="sd">    We could restrict solutions by using assumptions:</span>

<span class="sd">    &gt;&gt;&gt; p = Symbol(&quot;p&quot;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; solve(p**2 - 1)</span>
<span class="sd">    [{p: 1}]</span>

<span class="sd">    Several equations:</span>

<span class="sd">    &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - 15))</span>
<span class="sd">    [{x: -3, y: 1}]</span>
<span class="sd">    &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - z))</span>
<span class="sd">    [{x: -5*z/21 + 4/7, y: z/21 + 2/7}]</span>

<span class="sd">    No solution:</span>

<span class="sd">    &gt;&gt;&gt; solve([x + 3, x - 3])</span>
<span class="sd">    []</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    When an object other than a Symbol is given as a symbol, it is</span>
<span class="sd">    isolated algebraically and an implicit solution may be obtained.</span>
<span class="sd">    This is mostly provided as a convenience to save one from replacing</span>
<span class="sd">    the object with a Symbol and solving for that Symbol. It will only</span>
<span class="sd">    work if the specified object can be replaced with a Symbol using the</span>
<span class="sd">    subs method.</span>

<span class="sd">    &gt;&gt;&gt; solve(f(x) - x, f(x))</span>
<span class="sd">    [{f(x): x}]</span>
<span class="sd">    &gt;&gt;&gt; solve(f(x).diff(x) - f(x) - x, f(x).diff(x))</span>
<span class="sd">    [{Derivative(f(x), x): x + f(x)}]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    diofant.solvers.recurr.rsolve : solving recurrence equations</span>
<span class="sd">    diofant.solvers.ode.dsolve : solving differential equations</span>
<span class="sd">    diofant.solvers.inequalities.reduce_inequalities : solving inequalities</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_sympified_list</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">w</span> <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">w</span><span class="p">]))</span>
    <span class="n">bare_f</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">ordered_symbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbols</span> <span class="ow">and</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span>
                       <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">))</span> <span class="ow">or</span>
                        <span class="n">is_sequence</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">include</span><span class="o">=</span><span class="n">GeneratorType</span><span class="p">)))</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">symbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">_sympified_list</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">])</span>

    <span class="c1"># preprocess equation(s)</span>
    <span class="c1">###########################################################################</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;ImmutableMatrix&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">args</span><span class="p">]:</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">fi</span><span class="o">.</span><span class="n">rhs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="o">-</span><span class="n">fi</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Relational</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only expressions or equalities &quot;</span>
                             <span class="s2">&quot;supported, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fi</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Poly</span><span class="p">):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>

        <span class="c1"># rewrite hyperbolics in terms of exp</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">HyperbolicFunction</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>

        <span class="c1"># replace min/max:</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">Min</span><span class="p">,</span> <span class="n">Max</span><span class="p">)),</span>
                            <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">))</span>

        <span class="c1"># if we have a Matrix, we need to iterate over its elements again</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
            <span class="n">bare_f</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">f</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c1"># if we can split it into real and imaginary parts then do so</span>
        <span class="n">freei</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="n">freei</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">is_imaginary</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">freei</span><span class="p">):</span>
            <span class="n">fr</span><span class="p">,</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="c1"># accept as long as new re, im, arg or atan2 are not introduced</span>
            <span class="n">had</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">atan2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fr</span> <span class="ow">and</span> <span class="n">fi</span> <span class="ow">and</span> <span class="n">fr</span> <span class="o">!=</span> <span class="n">fi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">atan2</span><span class="p">)</span> <span class="o">-</span> <span class="n">had</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">fi</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
                    <span class="n">bare_f</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fr</span><span class="p">,</span> <span class="n">fi</span><span class="p">]</span>

    <span class="c1"># preprocess symbol(s)</span>
    <span class="c1">###########################################################################</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="c1"># get symbols from equations</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">):</span>
                        <span class="n">symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>  <span class="c1"># don&#39;t go any deeper</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="c1"># supply dummy symbols so solve(3) behaves like solve(3, x)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)):</span>
            <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Dummy</span><span class="p">())</span>

        <span class="n">ordered_symbols</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iterable</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># real/imag handling -----------------------------</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">piece</span> <span class="o">=</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">Ge</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span class="kc">True</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="c1"># Abs</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Abs</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_imaginary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;solving </span><span class="si">%s</span><span class="s1"> when the argument &#39;</span>
                                          <span class="s1">&#39;is not real or imaginary.&#39;</span> <span class="o">%</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">reps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">piece</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="k">else</span>
                         <span class="n">piece</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">I</span><span class="p">)))</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

        <span class="c1"># arg</span>
        <span class="n">_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)]</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="n">atan</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">re</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_arg</span><span class="p">})</span>

        <span class="c1"># save changes</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span>

    <span class="c1"># see if re(s) or im(s) appear</span>
    <span class="n">irf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">is_imaginary</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># neither re(x) nor im(x) will appear</span>
        <span class="c1"># if re(s) or im(s) appear, the auxiliary equation must be present</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">):</span>
            <span class="n">irf</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">irf</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">irf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">rhs</span><span class="p">})</span>
            <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>
            <span class="n">symbols</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
            <span class="n">bare_f</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># end of real/imag handling  -----------------------------</span>

    <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ordered_symbols</span><span class="p">:</span>
        <span class="c1"># we do this to make the results returned canonical in case f</span>
        <span class="c1"># contains a system of nonlinear equations; all other cases should</span>
        <span class="c1"># be unambiguous</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

    <span class="c1"># we can solve for non-symbol entities by replacing them with Dummy symbols</span>
    <span class="n">symbols_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">symbol_swapped</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="n">s_new</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symbol_swapped</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">s_new</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;X</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">symbols_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_new</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">symbol_swapped</span><span class="p">:</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">symbols_new</span><span class="p">))</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols_new</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">swap_sym</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># this is needed in the next two events</span>
    <span class="n">symset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>

    <span class="c1"># mask off any Object that we aren&#39;t going to invert: Derivative,</span>
    <span class="c1"># Integral, etc... so that solving for anything that they contain will</span>
    <span class="c1"># give an implicit solution</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">non_inverts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">):</span>
                <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">symset</span> <span class="ow">or</span>
                  <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">or</span>
                  <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">))</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">symset</span><span class="p">:</span>
                    <span class="n">non_inverts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">seen</span>
    <span class="n">non_inverts</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="n">Dummy</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">non_inverts</span><span class="p">}</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>

    <span class="n">non_inverts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">non_inverts</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

    <span class="c1"># rationalize Floats</span>
    <span class="n">floats</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">):</span>
                <span class="n">floats</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Any embedded piecewise functions need to be brought out to the</span>
    <span class="c1"># top level so that the appropriate strategy gets selected.</span>
    <span class="c1"># However, this is necessary only if one of the piecewise</span>
    <span class="c1"># functions depends on one of the symbols we are solving for.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">)):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">piecewise_fold</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># try to get a solution</span>
    <span class="c1">###########################################################################</span>
    <span class="k">if</span> <span class="n">bare_f</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="p">[{</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">s</span><span class="p">}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">flags</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">_solve_system</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># postprocessing</span>
    <span class="c1">###########################################################################</span>
    <span class="c1"># Restore masked-off objects</span>
    <span class="k">if</span> <span class="n">non_inverts</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>

    <span class="c1"># Restore original &quot;symbols&quot; if a dictionary is returned.</span>
    <span class="c1"># This is not necessary for</span>
    <span class="c1">#   - the single univariate equation case</span>
    <span class="c1">#     since the symbol will have been removed from the solution;</span>
    <span class="c1">#</span>
    <span class="c1"># ** unless there were Derivatives with the symbols, but those were handled</span>
    <span class="c1">#    above.</span>
    <span class="k">if</span> <span class="n">symbol_swapped</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">solution</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solution</span><span class="p">):</span>
                <span class="n">solution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># Get assumptions about symbols, to filter solutions.</span>
    <span class="c1"># Note that if assumptions about a solution can&#39;t be verified, it is still</span>
    <span class="c1"># returned.</span>
    <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># restore floats</span>
    <span class="k">if</span> <span class="n">floats</span> <span class="ow">and</span> <span class="n">solution</span> <span class="ow">and</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">nfloat</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">solution</span><span class="p">:</span>  <span class="c1"># assumption checking</span>
        <span class="k">def</span> <span class="nf">test_assumptions</span><span class="p">(</span><span class="n">sol</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fuzzy_and</span><span class="p">([</span><span class="n">check_assumptions</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">sym</span><span class="p">],</span> <span class="o">**</span><span class="n">sym</span><span class="o">.</span><span class="n">_assumptions</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">])</span>

        <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span> <span class="k">if</span> <span class="n">test_assumptions</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">]</span>

        <span class="n">warn</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">got_None</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">test_assumptions</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">warn</span> <span class="ow">and</span> <span class="n">got_None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                </span><span class="se">\t</span><span class="s2">Warning: assumptions concerning following solution(s)</span>
<span class="s2">                can&#39;t be checked:&quot;&quot;&quot;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">&#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">got_None</span><span class="p">)))</span>

    <span class="c1">#</span>
    <span class="c1"># done</span>
    <span class="c1">###########################################################################</span>

    <span class="c1"># Make sure that a list of solutions is ordered in a canonical way.</span>
    <span class="n">solution</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">solution</span></div>


<span class="k">def</span> <span class="nf">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a checked solution for f in terms of one or more of the</span>
<span class="sd">    symbols. A list (possibly empty) should be returned.</span>

<span class="sd">    If no method is implemented to solve the equation, a NotImplementedError</span>
<span class="sd">    will be raised. In the case that conversion of an expression to a Poly</span>
<span class="sd">    gives None a ValueError will be raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">not_impl_msg</span> <span class="o">=</span> <span class="s2">&quot;No algorithms are implemented to solve equation </span><span class="si">%s</span><span class="s2">&quot;</span>

    <span class="c1"># /!\ capture this flag then set it to False so that no checking in</span>
    <span class="c1"># recursive calls will be done; only the final answer is checked</span>
    <span class="n">checkdens</span> <span class="o">=</span> <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;check&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># build up solutions if f is a Mul</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="c1"># all solutions have been checked but now we must</span>
            <span class="c1"># check that the solutions do not set denominators</span>
            <span class="c1"># in any factor to zero</span>
            <span class="n">dens</span> <span class="o">=</span> <span class="n">denoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">symbol</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span>
                      <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">checksol</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">s</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">den</span> <span class="ow">in</span>
                          <span class="n">dens</span><span class="p">)]</span>
        <span class="c1"># set flags for quick exit at end</span>
        <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">elif</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Piecewise</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">piecewise_fold</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">)</span> <span class="ow">or</span> <span class="n">cond</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">symbol</span><span class="p">:</span> <span class="n">candidate</span><span class="p">})</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">false</span><span class="p">:</span>
                    <span class="c1"># Only include solutions that do not match the condition</span>
                    <span class="c1"># of any previous pieces.</span>
                    <span class="n">matches_other_piece</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">other_n</span><span class="p">,</span> <span class="p">(</span><span class="n">other_expr</span><span class="p">,</span> <span class="n">other_cond</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no branch</span>
                        <span class="k">if</span> <span class="n">other_n</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">other_cond</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">symbol</span><span class="p">:</span> <span class="n">candidate</span><span class="p">})</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">:</span>
                                <span class="n">matches_other_piece</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">break</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">matches_other_piece</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Relational</span><span class="p">):</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">canonical</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                            <span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="p">))</span>
        <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># first see if it really depends on symbol and whether there</span>
        <span class="c1"># is a linear solution</span>
        <span class="n">f_num</span><span class="p">,</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_linear</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f_num</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">f_num</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="c1"># no need to check but simplify if desired</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">sol</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># no solution was obtained</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># there is no failure message</span>

        <span class="c1"># Poly is generally robust enough to convert anything to</span>
        <span class="c1"># a polynomial and tell us the different generators that it</span>
        <span class="c1"># contains, so we will inspect the generators identified by</span>
        <span class="c1"># polys to figure out what to do.</span>

        <span class="c1"># try to identify a single generator that will allow us to solve this</span>
        <span class="c1"># as a polynomial, followed (perhaps) by a change of variables if the</span>
        <span class="c1"># generator is not a symbol</span>

        <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">gens</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">_as_base_q</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return (b**e, q) for x = b**(p*e/q) where p/q is the leading</span>
<span class="sd">            Rational of the exponent of x, e.g. exp(-2*x/3) -&gt; (exp(x), 3)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">denominator</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>  <span class="c1"># c could be a Float</span>
                <span class="k">return</span> <span class="n">b</span><span class="o">**</span><span class="n">ee</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">denominator</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If there is more than one generator, it could be that the</span>
            <span class="c1"># generators have the same base but different powers, e.g.</span>
            <span class="c1">#   &gt;&gt;&gt; Poly(exp(x) + 1/exp(x))</span>
            <span class="c1">#   Poly(exp(-x) + exp(x), exp(-x), exp(x), domain=&#39;ZZ&#39;)</span>
            <span class="c1">#</span>
            <span class="c1"># If unrad was not disabled then there should be no rational</span>
            <span class="c1"># exponents appearing as in</span>
            <span class="c1">#   &gt;&gt;&gt; Poly(sqrt(x) + sqrt(sqrt(x)))</span>
            <span class="c1">#   Poly(sqrt(x) + x**(1/4), sqrt(x), x**(1/4), domain=&#39;ZZ&#39;)</span>

            <span class="n">bases</span><span class="p">,</span> <span class="n">qs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_as_base_q</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]))</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qs</span><span class="p">):</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Function</span><span class="p">}</span>

                <span class="n">trig</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="k">if</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">TrigonometricFunction</span><span class="p">)}</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">funcs</span> <span class="o">-</span> <span class="n">trig</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">trig</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">newf</span> <span class="o">=</span> <span class="n">TR1</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">tan</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">newf</span> <span class="o">!=</span> <span class="n">f_num</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">newf</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

                <span class="c1"># just a simple case - see if replacement of single function</span>
                <span class="c1"># clears all symbol-dependent functions, e.g.</span>
                <span class="c1"># log(x) - log(log(x) - 1) - 3 can be solved even though it has</span>
                <span class="c1"># two generators.</span>

                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">funcs</span><span class="p">:</span>
                    <span class="n">funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">funcs</span><span class="p">))</span>  <span class="c1"># put shallowest function first</span>
                    <span class="n">f1</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                    <span class="c1"># perform the substitution</span>
                    <span class="n">ftry</span> <span class="o">=</span> <span class="n">f_num</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">f1</span><span class="p">:</span> <span class="n">t</span><span class="p">})</span>

                    <span class="c1"># if no Functions left, we can proceed with usual solve</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ftry</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
                        <span class="n">cv_sols</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ftry</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                        <span class="n">cv_inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">f1</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">sols</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">cv_sols</span><span class="p">:</span>
                            <span class="n">sols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_inv</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">t</span><span class="p">:</span> <span class="n">sol</span><span class="p">}))</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">sols</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;multiple generators </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">gens</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># e.g. case where gens are exp(x), exp(-x)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Pow</span><span class="p">):</span>
                    <span class="c1"># this will be resolved by factor in _tsolve but we might</span>
                    <span class="c1"># as well try a simple expansion here to get things in</span>
                    <span class="c1"># order so something like the following will work now without</span>
                    <span class="c1"># having to factor:</span>
                    <span class="c1">#</span>
                    <span class="c1"># &gt;&gt;&gt; eq = (exp(I*(-x-2))+exp(I*(x+2)))</span>
                    <span class="c1"># &gt;&gt;&gt; eq.subs({exp(x): y})  # fails</span>
                    <span class="c1"># exp(I*(-x - 2)) + exp(I*(x + 2))</span>
                    <span class="c1"># &gt;&gt;&gt; eq.expand().subs({exp(x): y})  # works</span>
                    <span class="c1"># y**I*exp(2*I) + y**(-I)*exp(-2*I)</span>
                    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">ftry</span> <span class="o">=</span> <span class="n">f_num</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">,</span> <span class="n">_expand</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">u</span><span class="p">:</span> <span class="n">t</span><span class="p">})</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">ftry</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                    <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ftry</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="n">sols</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                            <span class="n">sols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">t</span><span class="p">:</span> <span class="n">sol</span><span class="p">}))</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">sols</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># There is only one generator that we are interested in, but</span>
            <span class="c1"># there may have been more than one generator identified by</span>
            <span class="c1"># polys (e.g. for symbols other than the one we are interested</span>
            <span class="c1"># in) so recast the poly in terms of our generator of interest.</span>
            <span class="c1"># Also use composite=True with f_num since Poly won&#39;t update</span>
            <span class="c1"># poly as documented in issue sympy/sympy#8810.</span>

            <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extension</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># if we aren&#39;t on the tsolve-pass, use roots</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tsolve&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">deg</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
                <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">solvers</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                           <span class="p">(</span><span class="s1">&#39;cubics&#39;</span><span class="p">,</span> <span class="s1">&#39;quartics&#39;</span><span class="p">,</span> <span class="s1">&#39;quintics&#39;</span><span class="p">)}</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">roots</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">**</span><span class="n">solvers</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">deg</span><span class="p">:</span>
                    <span class="c1"># e.g. roots(32*x**5 + 400*x**4 + 2032*x**3 +</span>
                    <span class="c1">#            5000*x**2 + 6250*x + 3189) -&gt; {}</span>
                    <span class="c1"># so all_roots is used and RootOf instances are</span>
                    <span class="c1"># returned *unless* the system is multivariate</span>
                    <span class="c1"># or high-order EX domain.</span>
                    <span class="n">soln</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">all_roots</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">soln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>

                <span class="n">u</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">gen</span>
                <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">symbol</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                        <span class="n">iv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">({</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">t</span><span class="p">:</span> <span class="n">s</span><span class="p">})</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iv</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">}))</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="c1"># perhaps _tsolve can handle f_num</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># only dens need to be checked</span>
                <span class="k">if</span> <span class="n">soln</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># if the flag wasn&#39;t set then unset it since high-order</span>
                        <span class="c1"># results are quite long. Perhaps one could base this</span>
                        <span class="c1"># decision on a certain critical length of the</span>
                        <span class="c1"># roots. In addition, wester test M2 has an expression</span>
                        <span class="c1"># whose roots can be shown to be real with the</span>
                        <span class="c1"># unsimplified form of the solution whereas only one of</span>
                        <span class="c1"># the simplified forms appears to be real.</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">soln</span>

    <span class="c1"># fallback if above fails</span>
    <span class="c1"># -----------------------</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">:</span>
            <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">u</span>
            <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
                <span class="n">isym</span><span class="p">,</span> <span class="n">ieq</span> <span class="o">=</span> <span class="n">cov</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ieq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="p">{</span><span class="n">inv</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">isym</span><span class="p">:</span> <span class="n">xi</span><span class="p">})</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">_solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">rv</span><span class="p">))</span>
            <span class="c1"># if the flag wasn&#39;t set then unset it since unrad results</span>
            <span class="c1"># can be quite long or of very high order</span>
            <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># try _tsolve</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tsolve&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># allow tsolve to be used on next pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">soln</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">soln</span>
        <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="c1"># ----------- end of fallback ----------------------------</span>

    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">msg</span><span class="p">,</span> <span class="n">not_impl_msg</span> <span class="o">%</span> <span class="n">f</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
        <span class="c1"># we just simplified the solution so we now set the flag to</span>
        <span class="c1"># False so the simplification doesn&#39;t happen again in checksol()</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">checkdens</span><span class="p">:</span>
        <span class="c1"># reject any result that makes any denom. affirmatively 0;</span>
        <span class="c1"># if in doubt, keep it</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">denoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">symbol</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span>
                  <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">checksol</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">s</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
        <span class="c1"># keep only results if the check is not False</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span>
                  <span class="n">checksol</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">r</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_solve_system</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a checked solution for list of exprs in terms of one or more</span>
<span class="sd">    of the symbols. A list of dict&#39;s (possibly empty) should be returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="n">free</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">dep</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="c1"># find first successful solution</span>
        <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">):</span>
                        <span class="c1"># sol depends on previously solved symbols: discard it</span>
                        <span class="k">continue</span>
                    <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">sol</span><span class="p">})</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">if</span> <span class="n">got_s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[{}]</span>
    <span class="n">polynomial</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">inversions</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">checkdens</span> <span class="o">=</span> <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
        <span class="n">dens</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">denoms</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">symbols</span><span class="p">))</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">exprs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="o">+</span><span class="n">g</span><span class="p">,</span> <span class="o">-</span><span class="n">g</span><span class="p">):</span>
            <span class="n">inversions</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">poly</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">polys</span><span class="p">:</span>
        <span class="n">solved_syms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_linear</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">terms</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">monom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>

            <span class="c1"># returns a dictionary {symbols: values} or None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="p">[{}]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">solve_poly_system</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[{</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">r</span><span class="p">}</span>
                                             <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
        <span class="c1"># For each failed equation, see if we can solve for one of the</span>
        <span class="c1"># remaining symbols from that equation. If so, we update the</span>
        <span class="c1"># solution set and continue with the next failed equation,</span>
        <span class="c1"># repeating until we are done or we get an equation that can&#39;t</span>
        <span class="c1"># be solved.</span>
        <span class="k">def</span> <span class="nf">_ok_syms</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">-</span> <span class="n">solved_syms</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">legal</span>
            <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
                <span class="n">rv</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">solved_syms</span><span class="p">)</span>  <span class="c1"># set of symbols we have solved for</span>
        <span class="n">legal</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>  <span class="c1"># what we are interested in</span>

        <span class="c1"># sort so equation with the fewest potential symbols is first</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="n">failed</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ok_syms</span><span class="p">(</span><span class="n">_</span><span class="p">))):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>  <span class="c1"># used in solution checking</span>
            <span class="n">newresult</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bad_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="c1"># update eq with everything that is known so far</span>
                <span class="n">eq2</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="c1"># if check is True then we see if it satisfies this</span>
                <span class="c1"># equation, otherwise we just accept it</span>
                <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">checksol</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="n">eq2</span><span class="p">},</span> <span class="n">minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># this solution is sufficient to know whether</span>
                        <span class="c1"># it is valid or not so we either accept or</span>
                        <span class="c1"># reject it, then continue</span>
                        <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
                            <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bad_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="c1"># search for a symbol amongst those available that</span>
                <span class="c1"># can be solved for</span>
                <span class="n">ok_syms</span> <span class="o">=</span> <span class="n">_ok_syms</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ok_syms</span><span class="p">:</span>
                    <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">break</span>  <span class="c1"># skip as it&#39;s independent of desired symbols</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ok_syms</span><span class="p">:</span>
                    <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="c1"># put each solution in r and append the now-expanded</span>
                    <span class="c1"># result in the new result list; use copy since the</span>
                    <span class="c1"># solution for s in being added in-place</span>
                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">):</span>
                            <span class="c1"># sol depends on previously solved symbols: discard it</span>
                            <span class="k">continue</span>
                        <span class="n">rnew</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">rnew</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">sol</span><span class="p">})</span>
                        <span class="c1"># and add this new solution</span>
                        <span class="n">rnew</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span>
                        <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnew</span><span class="p">)</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;could not solve </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">eq2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">newresult</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="ow">in</span> <span class="n">bad_results</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">polynomial</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">default_simplify</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span>  <span class="c1"># rely on system-solvers to simplify</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="n">default_simplify</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># don&#39;t need to do so in checksol now</span>

    <span class="k">if</span> <span class="n">checkdens</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inversions</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">polynomial</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">)]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="n">r</span><span class="p">]</span>


<div class="viewcode-block" id="solve_linear"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#diofant.solvers.solvers.solve_linear">[docs]</a><span class="k">def</span> <span class="nf">solve_linear</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve equation ``f`` wrt variable ``x``.</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    tuple</span>
<span class="sd">        ``(x, solution)``, if there is a linear solution, ``(0, 1)`` if</span>
<span class="sd">        ``f`` is independent of the symbol ``x``, ``(0, 0)`` if solution set</span>
<span class="sd">        any denominator of ``f`` to zero or ``(numerator, denominator)``</span>
<span class="sd">        of ``f``, if it&#39;s a nonlinear expression wrt ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(1/x - y**2, x)</span>
<span class="sd">    (x, y**(-2))</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(x**2/y**2 - 3, x)</span>
<span class="sd">    (x**2 - 3*y**2, y**2)</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(y, x)</span>
<span class="sd">    (0, 1)</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(1/(1/x - 2), x)</span>
<span class="sd">    (0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Symbol&quot;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Derivative</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">poly</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">})</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">denoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">])):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="minsolve_linear_system"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#diofant.solvers.solvers.minsolve_linear_system">[docs]</a><span class="k">def</span> <span class="nf">minsolve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find a particular solution to a linear system.</span>

<span class="sd">    In particular, try to find a solution with the minimal possible number</span>
<span class="sd">    of non-zero variables. This is a very computationally hard problem.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    system : Matrix</span>
<span class="sd">        Nx(M+1) matrix, which means it has to be in augmented form.</span>
<span class="sd">    \*symbols : list</span>
<span class="sd">        List of M Symbols.</span>
<span class="sd">    \*\*flags : dict</span>
<span class="sd">        A dictionary of following parameters:</span>

<span class="sd">        quick : boolean, optional</span>
<span class="sd">            If True, a heuristic is used.  Otherwise (default) a naive</span>
<span class="sd">            algorithm with exponential complexity is used.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quick</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;quick&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Check if there are any non-zero solutions at all</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s0</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s0</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">s0</span>
    <span class="k">if</span> <span class="n">quick</span><span class="p">:</span>
        <span class="c1"># We just solve the system and try to heuristically find a nice</span>
        <span class="c1"># solution.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
            <span class="n">delete</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">determined</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">delete</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="n">determined</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
            <span class="c1"># NOTE sort by default_sort_key to get deterministic result</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">),</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">val</span><span class="p">})</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">determined</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We try to select n variables which we want to be non-zero.</span>
        <span class="c1"># All others will be assumed zero. We try to solve the modified system.</span>
        <span class="c1"># If there is a non-trivial solution, just set the free variables to</span>
        <span class="c1"># one. If we do this for increasing n, trying all combinations of</span>
        <span class="c1"># variables, we will find an optimal solution.</span>
        <span class="c1"># We speed up slightly by starting at one less than the number of</span>
        <span class="c1"># variables the quick method manages.</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">combinations</span>
        <span class="kn">from</span> <span class="nn">..utilities.misc</span> <span class="k">import</span> <span class="n">debug</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">bestsol</span> <span class="o">=</span> <span class="n">minsolve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="n">quick</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bestsol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;minsolve: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">thissol</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">nonzeros</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)),</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">subm</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">system</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">system</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">subm</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">subs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">symbols</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">symbols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">:</span>
                                <span class="n">s</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">s</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">thissol</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">thissol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">bestsol</span> <span class="o">=</span> <span class="n">thissol</span>
        <span class="k">return</span> <span class="n">bestsol</span></div>


<span class="c1"># these are functions that have multiple inverse values per period</span>
<span class="n">multi_inverses</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">sin</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">pi</span> <span class="o">-</span> <span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
    <span class="n">cos</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">-</span> <span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_tsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for _solve that solves a transcendental equation with respect</span>
<span class="sd">    to the given symbol. Various equations containing powers and logarithms,</span>
<span class="sd">    can be solved.</span>

<span class="sd">    There is currently no guarantee that all solutions will be returned or</span>
<span class="sd">    that a real solution will be favored over a complex one.</span>

<span class="sd">    Either a list of potential solutions will be returned or None will be</span>
<span class="sd">    returned (in the case that no method was known to get a solution</span>
<span class="sd">    for the equation). All other errors (like the inability to cast an</span>
<span class="sd">    expression as a Poly) are unhandled.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; _tsolve(3**(2*x + 5) - 4, x)</span>
<span class="sd">    [-5/2 + log(2)/log(3), (-5*log(3)/2 + log(2) + I*pi)/log(3)]</span>

<span class="sd">    &gt;&gt;&gt; _tsolve(log(x) + 2*x, x)</span>
<span class="sd">    [LambertW(2)/2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.bivariate</span> <span class="k">import</span> <span class="n">bivariate_type</span><span class="p">,</span> <span class="n">_solve_lambert</span><span class="p">,</span> <span class="n">_filtered_gens</span>

    <span class="k">if</span> <span class="s1">&#39;tsolve_saw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve_saw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve_saw&#39;</span><span class="p">]:</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve_saw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">rhs</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="c1"># it&#39;s time to try factoring; powdenest is used</span>
            <span class="c1"># to try get powers in standard form for better factoring</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rhs</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">log</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span> <span class="o">!=</span> <span class="n">eq</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="c1"># f(x)**g(x) only has solutions where f(x) == 0 and g(x) != 0 at</span>
                <span class="c1"># the same place</span>
                <span class="n">sol_base</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sol_base</span><span class="p">)</span> <span class="o">-</span>
                                    <span class="nb">set</span><span class="p">(</span><span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span> <span class="ow">and</span>
                  <span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span>
                  <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rhs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">rhs</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
            <span class="n">llhs</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">llhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">llhs</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="n">multi_inverses</span><span class="p">:</span>
            <span class="c1"># sin(x) = 1/3 -&gt; x - asin(1/3) &amp; x - (pi - asin(1/3))</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multi_inverses</span><span class="p">[</span><span class="n">lhs</span><span class="o">.</span><span class="n">func</span><span class="p">](</span><span class="n">rhs</span><span class="p">):</span>
                <span class="n">soln</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span>

        <span class="n">rewrite</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rewrite</span> <span class="o">!=</span> <span class="n">lhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">rewrite</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># maybe it is a lambert pattern</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bivariate&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># lambert forms may need some help being recognized, e.g. changing</span>
        <span class="c1"># 2**(3*x) + x**3*log(2)**3 + 3*x**2*log(2)**2 + 3*x*log(2) + 1</span>
        <span class="c1"># to 2**(3*x) + (x*log(2) + 1)**3</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">_filtered_gens</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(),</span> <span class="n">sym</span><span class="p">)</span>
        <span class="n">up_or_log</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gi</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">gi</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">E</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gi</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
                <span class="n">up_or_log</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">gi</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">gisimp</span> <span class="o">=</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">expand_power_exp</span><span class="p">(</span><span class="n">gi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">gisimp</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">gisimp</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">up_or_log</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span>
        <span class="n">eq_down</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">expand_power_exp</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">))))</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">eq_down</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eq</span> <span class="o">-</span> <span class="n">eq_down</span><span class="p">))</span>
        <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">as_poly</span><span class="p">()</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">_filtered_gens</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_solve_lambert</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c1"># maybe it&#39;s a convoluted function</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">gpu</span> <span class="o">=</span> <span class="n">bivariate_type</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">gpu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                        <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">gpu</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;bivariate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">inversion</span> <span class="o">=</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">u</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">inversion</span><span class="p">:</span>
                            <span class="n">sol</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">({</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">u</span><span class="p">:</span> <span class="n">s</span><span class="p">})</span>
                                                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inversion</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">}))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;force&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]))</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return tuple (i, d) where ``i`` is independent of ``symbols`` and ``d``</span>
<span class="sd">    contains symbols. ``i`` and ``d`` are obtained after recursively using</span>
<span class="sd">    algebraic inversion until an uninvertible ``d`` remains. If there are no</span>
<span class="sd">    free symbols then ``d`` will be zero. Some (but not necessarily all)</span>
<span class="sd">    solutions to the expression ``i - d`` will be related to the solutions of</span>
<span class="sd">    the original expression.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; _invert(x - 3)</span>
<span class="sd">    (3, x)</span>
<span class="sd">    &gt;&gt;&gt; _invert(3)</span>
<span class="sd">    (3, 0)</span>
<span class="sd">    &gt;&gt;&gt; _invert(2*cos(x) - 1)</span>
<span class="sd">    (1/2, cos(x))</span>
<span class="sd">    &gt;&gt;&gt; _invert(sqrt(x) - 3)</span>
<span class="sd">    (3, sqrt(x))</span>
<span class="sd">    &gt;&gt;&gt; _invert(sqrt(x) + y, x)</span>
<span class="sd">    (-y, sqrt(x))</span>
<span class="sd">    &gt;&gt;&gt; _invert(sqrt(x) + y, y)</span>
<span class="sd">    (-sqrt(x), y)</span>
<span class="sd">    &gt;&gt;&gt; _invert(sqrt(x) + y, x, y)</span>
<span class="sd">    (0, sqrt(x) + y)</span>

<span class="sd">    If there is more than one symbol in a power&#39;s base and the exponent</span>
<span class="sd">    is not an Integer, then the principal root will be used for the</span>
<span class="sd">    inversion:</span>

<span class="sd">    &gt;&gt;&gt; _invert(sqrt(x + y) - 2)</span>
<span class="sd">    (4, x + y)</span>
<span class="sd">    &gt;&gt;&gt; _invert(sqrt(x + y) - 2)</span>
<span class="sd">    (4, x + y)</span>

<span class="sd">    If the exponent is an integer, setting ``integer_power`` to True</span>
<span class="sd">    will force the principal root to be selected:</span>

<span class="sd">    &gt;&gt;&gt; _invert(x**2 - 4, integer_power=True)</span>
<span class="sd">    (2, x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">free</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">free</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="n">dointpow</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;integer_power&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

    <span class="n">lhs</span> <span class="o">=</span> <span class="n">eq</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">was</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">indep</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>

            <span class="c1"># dep + indep == rhs</span>
            <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c1"># this indicates we have done it all</span>
                <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">lhs</span> <span class="o">=</span> <span class="n">dep</span>
                <span class="n">rhs</span> <span class="o">-=</span> <span class="n">indep</span>

            <span class="c1"># dep * indep == rhs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this indicates we have done it all</span>
                <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">lhs</span> <span class="o">=</span> <span class="n">dep</span>
                <span class="n">rhs</span> <span class="o">/=</span> <span class="n">indep</span>

        <span class="c1"># collect like-terms in symbols</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># if it&#39;s a two-term Add with rhs = 0 and two powers we can get the</span>
        <span class="c1"># dependent terms together, e.g. 3*f(x) + 2*g(x) -&gt; f(x)/g(x) = -2/3</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ordered</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="n">ai</span><span class="p">,</span> <span class="n">ad</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">bi</span><span class="p">,</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_Pow</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">bd</span><span class="p">)):</span>
                <span class="n">a_base</span><span class="p">,</span> <span class="n">a_exp</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="n">b_base</span><span class="p">,</span> <span class="n">b_exp</span> <span class="o">=</span> <span class="n">bd</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">a_base</span> <span class="o">==</span> <span class="n">b_base</span><span class="p">:</span>
                    <span class="c1"># a = -b</span>
                    <span class="n">lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">ad</span><span class="o">/</span><span class="n">bd</span><span class="p">))</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">bi</span><span class="o">/</span><span class="n">ai</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rat</span> <span class="o">=</span> <span class="n">ad</span><span class="o">/</span><span class="n">bd</span>
                    <span class="n">_lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">ad</span><span class="o">/</span><span class="n">bd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_lhs</span> <span class="o">!=</span> <span class="n">rat</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">_lhs</span>
                        <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">bi</span><span class="o">/</span><span class="n">ai</span>
            <span class="k">if</span> <span class="n">ai</span><span class="o">*</span><span class="n">bi</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Function</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">bd</span><span class="p">))</span> <span class="ow">and</span> \
                        <span class="n">ad</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">bd</span><span class="o">.</span><span class="n">func</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># should be able to solve</span>
                        <span class="c1"># f(x, y) == f(2, 3) -&gt; x == 2</span>
                        <span class="c1"># f(x, x + y) == f(2, 3) -&gt; x == 2 or x == 3 - y</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;equal function with more than 1 argument&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_Pow</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="s1">&#39;inverse&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#                    -1</span>
                <span class="c1"># f(x) = g  -&gt;  x = f  (g)</span>
                <span class="c1">#</span>
                <span class="c1"># /!\ inverse should not be defined if there are multiple values</span>
                <span class="c1"># for the function -- these are handled in _tsolve</span>
                <span class="c1">#</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">inverse</span><span class="p">()(</span><span class="n">rhs</span><span class="p">)</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">atan2</span><span class="p">):</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">E</span><span class="p">:</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span>

        <span class="k">if</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">lhs</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">rhs</span>

        <span class="c1"># base**a = b -&gt; base = b**(1/a) if</span>
        <span class="c1">#    a is an Integer and dointpow=True (this gives real branch of root)</span>
        <span class="c1">#    a is not an Integer and the equation is multivariate and the</span>
        <span class="c1">#      base has more than 1 symbol in it</span>
        <span class="c1"># The rationale for this is that right now the multi-system solvers</span>
        <span class="c1"># doesn&#39;t try to resolve generators to see, for example, if the whole</span>
        <span class="c1"># system is written in terms of sqrt(x + y) so it will just fail, so we</span>
        <span class="c1"># do that step here.</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">dointpow</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">base</span>

        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2006-2018 SymPy Development Team, 2013-2019 Sergey B Kirpichev

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>