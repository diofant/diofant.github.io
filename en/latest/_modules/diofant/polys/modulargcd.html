

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diofant.polys.modulargcd &mdash; Diofant 0.10.1.dev237+g6e97e3d documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Diofant
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../internals/index.html">Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../aboutus.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Diofant</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>diofant.polys.modulargcd</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diofant.polys.modulargcd</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">..core</span> <span class="k">import</span> <span class="n">Dummy</span>
<span class="kn">from</span> <span class="nn">..ntheory</span> <span class="k">import</span> <span class="n">nextprime</span>
<span class="kn">from</span> <span class="nn">..ntheory.modular</span> <span class="k">import</span> <span class="n">crt</span><span class="p">,</span> <span class="n">integer_rational_reconstruction</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">rings</span>
<span class="kn">from</span> <span class="nn">.galoistools</span> <span class="k">import</span> <span class="n">gf_div</span><span class="p">,</span> <span class="n">gf_from_dict</span><span class="p">,</span> <span class="n">gf_gcd</span><span class="p">,</span> <span class="n">gf_gcdex</span><span class="p">,</span> <span class="n">gf_lcm</span>
<span class="kn">from</span> <span class="nn">.polyerrors</span> <span class="k">import</span> <span class="n">ModularGCDFailed</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="s1">&#39;modgcd&#39;</span><span class="p">,</span> <span class="s1">&#39;func_field_modgcd&#39;</span><span class="p">,</span> <span class="s1">&#39;trial_division&#39;</span><span class="p">,</span>


<span class="k">def</span> <span class="nf">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in trivial cases, i.e. when one</span>
<span class="sd">    or both polynomials are zero.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">f</span> <span class="ow">or</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">g</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="o">-</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">LC</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">_gf_gcd</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the GCD of two univariate polynomials in `\mathbb{Z}_p[x]`.&quot;&quot;&quot;</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">while</span> <span class="n">gp</span><span class="p">:</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">lcinv</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">gp</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">degrem</span> <span class="o">&lt;</span> <span class="n">deg</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem</span> <span class="o">-</span> <span class="n">gp</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="n">degrem</span> <span class="o">-</span> <span class="n">deg</span><span class="p">,))</span><span class="o">*</span><span class="p">(</span><span class="n">lcinv</span> <span class="o">*</span> <span class="n">rem</span><span class="o">.</span><span class="n">LC</span><span class="p">))</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">gp</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">rem</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">fp</span><span class="o">*</span><span class="n">dom</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_primitive</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the content and the primitive part of a polynomial in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{k-2}, y] \cong \mathbb{Z}_p[y][x_0, \ldots, x_{k-2}]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        integer polynomial in `\mathbb{Z}_p[x0, \ldots, x{k-2}, y]`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        modulus of `f`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    contf : PolyElement</span>
<span class="sd">        integer polynomial in `\mathbb{Z}_p[y]`, content of `f`</span>
<span class="sd">    ppf : PolyElement</span>
<span class="sd">        primitive part of `f`, i.e. `\frac{f}{contf}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; p = 3</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - y**2 - y</span>
<span class="sd">    &gt;&gt;&gt; _primitive(f, p)</span>
<span class="sd">    (y**2 + y, x**2 - 1)</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x*y*z - y**2*z**2</span>
<span class="sd">    &gt;&gt;&gt; _primitive(f, p)</span>
<span class="sd">    (z, x*y - y**2*z)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="n">coeffs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">monom</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">coeff</span>

    <span class="n">cont</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="n">gf_gcd</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">gf_from_dict</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="p">)</span>

    <span class="n">yring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">contf</span> <span class="o">=</span> <span class="n">yring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">contf</span><span class="p">,</span> <span class="n">f</span><span class="o">//</span><span class="n">contf</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_deg</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the degree of a multivariate polynomial</span>
<span class="sd">    `f \in K[x_0, \ldots, x_{k-2}, y] \cong K[y][x_0, \ldots, x_{k-2}]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `K[x_0, \ldots, x_{k-2}, y]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    degf : Integer tuple</span>
<span class="sd">        degree of `f` in `x_0, \ldots, x_{k-2}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _deg(f)</span>
<span class="sd">    (2,)</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _deg(f)</span>
<span class="sd">    (2, 2)</span>

<span class="sd">    &gt;&gt;&gt; f = x*y*z - y**2*z**2</span>
<span class="sd">    &gt;&gt;&gt; _deg(f)</span>
<span class="sd">    (1, 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>
    <span class="n">degf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">degf</span><span class="p">:</span>
            <span class="n">degf</span> <span class="o">=</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">degf</span>


<span class="k">def</span> <span class="nf">_LC</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the leading coefficient of a multivariate polynomial</span>
<span class="sd">    `f \in K[x_0, \ldots, x_{k-2}, y] \cong K[y][x_0, \ldots, x_{k-2}]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `K[x_0, \ldots, x_{k-2}, y]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    lcf : PolyElement</span>
<span class="sd">        polynomial in `K[y]`, leading coefficient of `f`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _LC(f)</span>
<span class="sd">    y**2 + y</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _LC(f)</span>
<span class="sd">    1</span>

<span class="sd">    &gt;&gt;&gt; f = x*y*z - y**2*z**2</span>
<span class="sd">    &gt;&gt;&gt; _LC(f)</span>
<span class="sd">    z</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>
    <span class="n">yring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">yring</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">degf</span> <span class="o">=</span> <span class="n">_deg</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">lcf</span> <span class="o">=</span> <span class="n">yring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">degf</span><span class="p">:</span>
            <span class="n">lcf</span> <span class="o">+=</span> <span class="n">coeff</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="n">monom</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lcf</span>


<span class="k">def</span> <span class="nf">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make the variable `x_i` the leading one in a multivariate polynomial `f`.&quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">fswap</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">monomswap</span> <span class="o">=</span> <span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span> <span class="o">+</span> <span class="n">monom</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">monom</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">fswap</span><span class="p">[</span><span class="n">monomswap</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
    <span class="k">return</span> <span class="n">fswap</span>


<span class="k">def</span> <span class="nf">_chinese_remainder_reconstruction</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a polynomial `h_{pq}` in</span>
<span class="sd">    `\mathbb{Z}_{p q}[x_0, \ldots, x_{k-1}]` such that</span>

<span class="sd">    .. math ::</span>

<span class="sd">        h_{pq} = h_p \; \mathrm{mod} \, p</span>

<span class="sd">        h_{pq} = h_q \; \mathrm{mod} \, q</span>

<span class="sd">    for relatively prime integers `p` and `q` and polynomials</span>
<span class="sd">    `h_p` and `h_q` in `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]` and</span>
<span class="sd">    `\mathbb{Z}_q[x_0, \ldots, x_{k-1}]` respectively.</span>

<span class="sd">    The coefficients of the polynomial `h_{pq}` are computed with the</span>
<span class="sd">    Chinese Remainder Theorem. The symmetric representation in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`,</span>
<span class="sd">    `\mathbb{Z}_q[x_0, \ldots, x_{k-1}]` and</span>
<span class="sd">    `\mathbb{Z}_{p q}[x_0, \ldots, x_{k-1}]` is used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    hp : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_p`</span>
<span class="sd">    hq : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_q`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        modulus of `h_p`, relatively prime to `q`</span>
<span class="sd">    q : Integer</span>
<span class="sd">        modulus of `h_q`, relatively prime to `p`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; p = 3</span>
<span class="sd">    &gt;&gt;&gt; q = 5</span>

<span class="sd">    &gt;&gt;&gt; hp = x**3*y - x**2 - 1</span>
<span class="sd">    &gt;&gt;&gt; hq = -x**3*y - 2*x*y**2 + 2</span>

<span class="sd">    &gt;&gt;&gt; hpq = _chinese_remainder_reconstruction(hp, hq, p, q)</span>
<span class="sd">    &gt;&gt;&gt; hpq</span>
<span class="sd">    4*x**3*y + 5*x**2 + 3*x*y**2 + 2</span>

<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(p) == hp</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(q) == hq</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; p = 6</span>
<span class="sd">    &gt;&gt;&gt; q = 5</span>

<span class="sd">    &gt;&gt;&gt; hp = 3*x**4 - y**3*z + z</span>
<span class="sd">    &gt;&gt;&gt; hq = -2*x**4 + z</span>

<span class="sd">    &gt;&gt;&gt; hpq = _chinese_remainder_reconstruction(hp, hq, p, q)</span>
<span class="sd">    &gt;&gt;&gt; hpq</span>
<span class="sd">    3*x**4 + 5*y**3*z + z</span>

<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(p) == hp</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(q) == hq</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hpmonoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">monoms</span><span class="p">())</span>
    <span class="n">hqmonoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">hq</span><span class="o">.</span><span class="n">monoms</span><span class="p">())</span>
    <span class="n">monoms</span> <span class="o">=</span> <span class="n">hpmonoms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">hqmonoms</span><span class="p">)</span>
    <span class="n">hpmonoms</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">monoms</span><span class="p">)</span>
    <span class="n">hqmonoms</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">monoms</span><span class="p">)</span>

    <span class="n">zero</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span>

    <span class="n">hpq</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">rings</span><span class="o">.</span><span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">crt_</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">crt_</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">crt</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span> <span class="p">[</span><span class="n">cp</span><span class="p">,</span> <span class="n">cq</span><span class="p">],</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">monoms</span><span class="p">:</span>
        <span class="n">hpq</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">crt_</span><span class="p">(</span><span class="n">hp</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">hq</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">hpmonoms</span><span class="p">:</span>
        <span class="n">hpq</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">crt_</span><span class="p">(</span><span class="n">hp</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">zero</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">hqmonoms</span><span class="p">:</span>
        <span class="n">hpq</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">crt_</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">hq</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hpq</span>


<span class="k">def</span> <span class="nf">_interpolate</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">hpeval</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ground</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a polynomial `h_p` in `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`</span>
<span class="sd">    from a list of evaluation points in `\mathbb{Z}_p` and a list of</span>
<span class="sd">    polynomials in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{i-1}, x_{i+1}, \ldots, x_{k-1}]`, which</span>
<span class="sd">    are the images of `h_p` evaluated in the variable `x_i`.</span>

<span class="sd">    It is also possible to reconstruct a parameter of the ground domain,</span>
<span class="sd">    i.e. if `h_p` is a polynomial over `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`.</span>
<span class="sd">    In this case, one has to set ``ground=True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    evalpoints : list of Integer objects</span>
<span class="sd">        list of evaluation points in `\mathbb{Z}_p`</span>
<span class="sd">    hpeval : list of PolyElement objects</span>
<span class="sd">        list of polynomials in (resp. over)</span>
<span class="sd">        `\mathbb{Z}_p[x_0, \ldots, x_{i-1}, x_{i+1}, \ldots, x_{k-1}]`,</span>
<span class="sd">        images of `h_p` evaluated in the variable `x_i`</span>
<span class="sd">    ring : PolynomialRing</span>
<span class="sd">        `h_p` will be an element of this ring</span>
<span class="sd">    i : Integer</span>
<span class="sd">        index of the variable which has to be reconstructed</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `h_p`</span>
<span class="sd">    ground : Boolean</span>
<span class="sd">        indicates whether `x_i` is in the ground domain, default is</span>
<span class="sd">        ``False``</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    hp : PolyElement</span>
<span class="sd">        interpolated polynomial in (resp. over)</span>
<span class="sd">        `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hp</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="n">ground</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">hpa</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">hpeval</span><span class="p">):</span>
        <span class="n">numer</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">one</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">evalpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">numer</span> <span class="o">*=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">b</span>
            <span class="n">denom</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">numer</span><span class="o">*</span><span class="n">denom</span>
        <span class="n">hp</span> <span class="o">+=</span> <span class="n">hpa</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>

    <span class="k">return</span> <span class="n">hp</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_modgcd_p</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degbound</span><span class="p">,</span> <span class="n">contbound</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in</span>
<span class="sd">    `\mathbb{Z}_p[x0, \ldots, x{k-1}]`.</span>

<span class="sd">    The algorithm reduces the problem step by step by evaluating the</span>
<span class="sd">    polynomials `f` and `g` at `x_{k-1} = a` for suitable</span>
<span class="sd">    `a \in \mathbb{Z}_p` and then calls itself recursively to compute the GCD</span>
<span class="sd">    in `\mathbb{Z}_p[x_0, \ldots, x_{k-2}]`. If these recursive calls are</span>
<span class="sd">    successful for enough evaluation points, the GCD in `k` variables is</span>
<span class="sd">    interpolated, otherwise the algorithm returns ``None``. Every time a GCD</span>
<span class="sd">    or a content is computed, their degrees are compared with the bounds. If</span>
<span class="sd">    a degree greater then the bound is encountered, then the current call</span>
<span class="sd">    returns ``None`` and a new evaluation point has to be chosen. If at some</span>
<span class="sd">    point the degree is smaller, the correspondent bound is updated and the</span>
<span class="sd">    algorithm fails.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_p`</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_p`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `f` and `g`</span>
<span class="sd">    degbound : list of Integer objects</span>
<span class="sd">        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`</span>
<span class="sd">        and `g` in the variable `x_i`</span>
<span class="sd">    contbound : list of Integer objects</span>
<span class="sd">        ``contbound[i]`` is an upper bound for the degree of the content of</span>
<span class="sd">        the GCD in `\mathbb{Z}_p[x_i][x_0, \ldots, x_{i-1}]`,</span>
<span class="sd">        ``contbound[0]`` is not used can therefore be chosen</span>
<span class="sd">        arbitrarily.</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of the polynomials `f` and `g` or ``None``</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    * :cite:`Monagan2000Brown`</span>
<span class="sd">    * :cite:`Brown1971gcd`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">degh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">degh</span> <span class="o">&gt;</span> <span class="n">degbound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">degh</span> <span class="o">&lt;</span> <span class="n">degbound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">degbound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">degh</span>
            <span class="k">raise</span> <span class="n">ModularGCDFailed</span>

        <span class="k">return</span> <span class="n">h</span>

    <span class="n">degyf</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">degyg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">contf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">contg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">conth</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">contf</span><span class="p">,</span> <span class="n">contg</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># polynomial in Z_p[y]</span>

    <span class="n">degcontf</span> <span class="o">=</span> <span class="n">contf</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degcontg</span> <span class="o">=</span> <span class="n">contg</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degconth</span> <span class="o">=</span> <span class="n">conth</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">degconth</span> <span class="o">&gt;</span> <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">degconth</span> <span class="o">&lt;</span> <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">degconth</span>
        <span class="k">raise</span> <span class="n">ModularGCDFailed</span>

    <span class="n">lcf</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">lcg</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">lcf</span><span class="p">,</span> <span class="n">lcg</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># polynomial in Z_p[y]</span>

    <span class="n">evaltest</span> <span class="o">=</span> <span class="n">delta</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">evaltest</span> <span class="o">*=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">_LC</span><span class="p">(</span><span class="n">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">_LC</span><span class="p">(</span><span class="n">_swap</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">degdelta</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">degyf</span> <span class="o">-</span> <span class="n">degcontf</span><span class="p">,</span> <span class="n">degyg</span> <span class="o">-</span> <span class="n">degcontg</span><span class="p">,</span>
            <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">degdelta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evalpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">evaltest</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">deltaa</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span>

        <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">ga</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># polynomials in Z_p[x_0, ..., x_{k-2}]</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="n">_modgcd_p</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">ga</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degbound</span><span class="p">,</span> <span class="n">contbound</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">ha</span><span class="o">.</span><span class="n">is_ground</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">conth</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">h</span>

        <span class="n">ha</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha</span><span class="o">*</span><span class="n">deltaa</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">evalpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">heval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">_interpolate</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">heval</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">conth</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="n">degyh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">degyh</span> <span class="o">&lt;=</span> <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">degyh</span> <span class="o">&lt;</span> <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">degyh</span>
                <span class="k">raise</span> <span class="n">ModularGCDFailed</span>

            <span class="k">return</span> <span class="n">h</span>

    <span class="k">return</span>


<div class="viewcode-block" id="modgcd"><a class="viewcode-back" href="../../../internals/polys.html#diofant.polys.modulargcd.modgcd">[docs]</a><span class="k">def</span> <span class="nf">modgcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in `\mathbb{Z}[x_0, \ldots, x_{k-1}]`</span>
<span class="sd">    using a modular algorithm.</span>

<span class="sd">    The algorithm computes the GCD of two multivariate integer polynomials</span>
<span class="sd">    `f` and `g` by calculating the GCD in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]` for suitable primes `p` and then</span>
<span class="sd">    reconstructing the coefficients with the Chinese Remainder Theorem. To</span>
<span class="sd">    compute the multivariate GCD over `\mathbb{Z}_p` the recursive</span>
<span class="sd">    subroutine ``_modgcd_p`` is used. To verify the result in</span>
<span class="sd">    `\mathbb{Z}[x_0, \ldots, x_{k-1}]`, trial division is done, but only for</span>
<span class="sd">    candidates which are very likely the desired GCD.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        multivariate integer polynomial</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        multivariate integer polynomial</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of the polynomials `f` and `g`</span>
<span class="sd">    cff : PolyElement</span>
<span class="sd">        cofactor of `f`, i.e. `\frac{f}{h}`</span>
<span class="sd">    cfg : PolyElement</span>
<span class="sd">        cofactor of `g`, i.e. `\frac{g}{h}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; modgcd((x - y)*(x + y), (x + y)**2)</span>
<span class="sd">    (x + y, x - y, x + y)</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; modgcd((x - y)*z**2, (x**2 + 1)*z)</span>
<span class="sd">    (z, x*z - y*z, x**2 + 1)</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    * :cite:`Monagan2000Brown`</span>
<span class="sd">    * :cite:`Brown1971gcd`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">ring</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">is_IntegerRing</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="c1"># divide out integer content</span>
    <span class="n">cf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">cg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">cg</span><span class="p">)</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>

    <span class="n">badprimes</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">badprimes</span> <span class="o">*=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">_swap</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>

    <span class="n">degbound</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">fdeg</span><span class="p">,</span> <span class="n">gdeg</span><span class="p">)</span> <span class="k">for</span> <span class="n">fdeg</span><span class="p">,</span> <span class="n">gdeg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">degree_list</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">degree_list</span><span class="p">())]</span>
    <span class="n">contbound</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">degbound</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">badprimes</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># monic GCD of fp, gp in Z_p[x_0, ..., x_{k-2}, y]</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="n">_modgcd_p</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degbound</span><span class="p">,</span> <span class="n">contbound</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ModularGCDFailed</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">hp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hp</span><span class="o">*</span><span class="n">gamma</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hp</span>
            <span class="k">continue</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hlastm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">*=</span> <span class="n">p</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">hm</span> <span class="o">==</span> <span class="n">hlastm</span><span class="p">:</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hm</span>
            <span class="k">continue</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">primitive</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fquo</span><span class="p">,</span> <span class="n">frem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">gquo</span><span class="p">,</span> <span class="n">grem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frem</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">grem</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">*=</span> <span class="n">ch</span>
            <span class="n">cff</span> <span class="o">=</span> <span class="n">fquo</span><span class="o">*</span><span class="p">(</span><span class="n">cf</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">gquo</span><span class="o">*</span><span class="p">(</span><span class="n">cg</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">cff</span><span class="p">,</span> <span class="n">cfg</span></div>


<span class="k">def</span> <span class="nf">_gf_div</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `\frac f g` modulo `p` for two univariate polynomials over</span>
<span class="sd">    `\mathbb Z_p`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">densequo</span><span class="p">,</span> <span class="n">denserem</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">p</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">densequo</span><span class="p">),</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">denserem</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rational_function_reconstruction</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a rational function `\frac a b` in `\mathbb Z_p(t)` from</span>

<span class="sd">    .. math::</span>

<span class="sd">        c = \frac a b \; \mathrm{mod} \, m,</span>

<span class="sd">    where `c` and `m` are polynomials in `\mathbb Z_p[t]` and `m` has</span>
<span class="sd">    positive degree.</span>

<span class="sd">    The algorithm is based on the Euclidean Algorithm. In general, `m` is</span>
<span class="sd">    not irreducible, so it is possible that `b` is not invertible modulo</span>
<span class="sd">    `m`. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    c : PolyElement</span>
<span class="sd">        univariate polynomial in `\mathbb Z[t]`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number</span>
<span class="sd">    m : PolyElement</span>
<span class="sd">        modulus, not necessarily irreducible</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    frac : FracElement</span>
<span class="sd">        either `\frac a b` in `\mathbb Z(t)` or ``None``</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    * :cite:`Monagan2004algebraic`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">M</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">r0</span><span class="p">,</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>

    <span class="k">while</span> <span class="n">r1</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">quo</span> <span class="o">=</span> <span class="n">_gf_div</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="p">(</span><span class="n">r0</span> <span class="o">-</span> <span class="n">quo</span><span class="o">*</span><span class="n">r1</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">,</span> <span class="p">(</span><span class="n">s0</span> <span class="o">-</span> <span class="n">quo</span><span class="o">*</span><span class="n">s1</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="n">s1</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">D</span> <span class="ow">or</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">lc</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">LC</span>
    <span class="k">if</span> <span class="n">lc</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">lcinv</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">lcinv</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">lcinv</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">field</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">to_field</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">field</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">field</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rational_reconstruction_func_coeffs</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct every coefficient `c_h` of a polynomial `h` in</span>
<span class="sd">    `\mathbb Z_p(t_k)[t_1, \ldots, t_{k-1}][x, z]` from the corresponding</span>
<span class="sd">    coefficient `c_{h_m}` of a polynomial `h_m` in</span>
<span class="sd">    `\mathbb Z_p[t_1, \ldots, t_k][x, z] \cong \mathbb Z_p[t_k][t_1, \ldots, t_{k-1}][x, z]`</span>
<span class="sd">    such that</span>

<span class="sd">    .. math::</span>

<span class="sd">        c_{h_m} = c_h \; \mathrm{mod} \, m,</span>

<span class="sd">    where `m \in \mathbb Z_p[t]`.</span>

<span class="sd">    The reconstruction is based on the Euclidean Algorithm. In general, `m`</span>
<span class="sd">    is not irreducible, so it is possible that this fails for some</span>
<span class="sd">    coefficient. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    hm : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>
<span class="sd">    m : PolyElement</span>
<span class="sd">        modulus, polynomial in `\mathbb Z[t]`, not necessarily irreducible</span>
<span class="sd">    ring : PolynomialRing</span>
<span class="sd">        `\mathbb Z(t_k)[t_1, \ldots, t_{k-1}][x, z]`, `h` will be an</span>
<span class="sd">        element of this ring</span>
<span class="sd">    k : Integer</span>
<span class="sd">        index of the parameter `t_k` which will be reconstructed</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        reconstructed polynomial in</span>
<span class="sd">        `\mathbb Z(t_k)[t_1, \ldots, t_{k-1}][x, z]` or ``None``</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    _rational_function_reconstruction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hm</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coeffh</span> <span class="o">=</span> <span class="n">_rational_function_reconstruction</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffh</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeffh</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span>
            <span class="k">for</span> <span class="n">mon</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">_rational_function_reconstruction</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="p">:</span>
                    <span class="k">return</span>

                <span class="n">coeffh</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>

        <span class="n">h</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffh</span>

    <span class="k">return</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_gf_gcdex</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extended Euclidean Algorithm for two univariate polynomials over</span>
<span class="sd">    `\mathbb Z_p`.</span>

<span class="sd">    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and</span>
<span class="sd">    `g` and `sf + tg = h \; \mathrm{mod} \, p`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">gf_gcdex</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">p</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_trunc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the reduced representation of a polynomial `f` in</span>
<span class="sd">    `\mathbb Z_p[z] / (\check m_{\alpha}(z))[x]`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial `\check m_{\alpha} \in \mathbb Z[z]`, not necessarily</span>
<span class="sd">        irreducible</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    ftrunc : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[x, z]`, reduced modulo</span>
<span class="sd">        `\check m_{\alpha}(z)` and `p`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">minpoly</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
    <span class="n">p_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ground_new</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">div</span><span class="p">([</span><span class="n">minpoly</span><span class="p">,</span> <span class="n">p_</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_euclidean_algorithm</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the monic GCD of two univariate polynomials in</span>
<span class="sd">    `\mathbb{Z}_p[z]/(\check m_{\alpha}(z))[x]` with the Euclidean</span>
<span class="sd">    Algorithm.</span>

<span class="sd">    In general, `\check m_{\alpha}(z)` is not irreducible, so it is possible</span>
<span class="sd">    that some leading coefficient is not invertible modulo</span>
<span class="sd">    `\check m_{\alpha}(z)`. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[z]`, not necessarily irreducible</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of `f` and `g` in `\mathbb Z[z, x]` or ``None``, coefficients</span>
<span class="sd">        are in `\left[ -\frac{p-1} 2, \frac{p-1} 2 \right]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">g</span><span class="p">:</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># degree in x</span>
        <span class="n">lcinv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">_gf_gcdex</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">gcd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># degree in x</span>
            <span class="k">if</span> <span class="n">degrem</span> <span class="o">&lt;</span> <span class="n">deg</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">quo</span> <span class="o">=</span> <span class="p">(</span><span class="n">lcinv</span> <span class="o">*</span> <span class="n">rem</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">rem</span> <span class="o">-</span> <span class="n">g</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="n">degrem</span> <span class="o">-</span> <span class="n">deg</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">quo</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">rem</span>

    <span class="n">lcfinv</span> <span class="o">=</span> <span class="n">_gf_gcdex</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">lcfinv</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>


<div class="viewcode-block" id="trial_division"><a class="viewcode-back" href="../../../internals/polys.html#diofant.polys.modulargcd.trial_division">[docs]</a><span class="k">def</span> <span class="nf">trial_division</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if `h` divides `f` in</span>
<span class="sd">    `\mathbb K[t_1, \ldots, t_k][z]/(m_{\alpha}(z))`, where `\mathbb K` is</span>
<span class="sd">    either `\mathbb Q` or `\mathbb Z_p`.</span>

<span class="sd">    This algorithm is based on pseudo division and does not use any</span>
<span class="sd">    fractions. By default `\mathbb K` is `\mathbb Q`, if a prime number `p`</span>
<span class="sd">    is given, `\mathbb Z_p` is chosen instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, h : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial `m_{\alpha}(z)` in `\mathbb Z[t_1, \ldots, t_k][z]`</span>
<span class="sd">    p : Integer or None</span>
<span class="sd">        if `p` is given, `\mathbb K` is set to `\mathbb Z_p` instead of</span>
<span class="sd">        `\mathbb Q`, default is ``None``</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    rem : PolyElement</span>
<span class="sd">        remainder of `\frac f h`</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    * :cite:`vanHoeij2002modgcd`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">zxring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">minpoly</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
    <span class="n">rem</span> <span class="o">=</span> <span class="n">f</span>

    <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degm</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">lch</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
    <span class="n">lcm</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">LC</span>

    <span class="k">while</span> <span class="n">rem</span> <span class="ow">and</span> <span class="n">degrem</span> <span class="o">&gt;=</span> <span class="n">degh</span><span class="p">:</span>
        <span class="c1"># polynomial in Z[t_1, ..., t_k][z]</span>
        <span class="n">lcrem</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">*</span><span class="n">lch</span> <span class="o">-</span> <span class="n">h</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="n">degrem</span> <span class="o">-</span> <span class="n">degh</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">lcrem</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">rem</span> <span class="ow">and</span> <span class="n">degrem</span> <span class="o">&gt;=</span> <span class="n">degm</span><span class="p">:</span>
            <span class="c1"># polynomial in Z[t_1, ..., t_k][x]</span>
            <span class="n">lcrem</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">rem</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">zxring</span><span class="p">))</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">*</span><span class="n">lcm</span> <span class="o">-</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">degrem</span> <span class="o">-</span> <span class="n">degm</span><span class="p">))</span><span class="o">*</span><span class="n">lcrem</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">rem</span></div>


<span class="k">def</span> <span class="nf">_evaluate_ground</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground</span>
<span class="sd">    domain.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">fa</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fa</span>


<span class="k">def</span> <span class="nf">_func_field_modgcd_p</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials `f` and `g` in</span>
<span class="sd">    `\mathbb Z_p(t_1, \ldots, t_k)[z]/(\check m_\alpha(z))[x]`.</span>

<span class="sd">    The algorithm reduces the problem step by step by evaluating the</span>
<span class="sd">    polynomials `f` and `g` at `t_k = a` for suitable `a \in \mathbb Z_p`</span>
<span class="sd">    and then calls itself recursively to compute the GCD in</span>
<span class="sd">    `\mathbb Z_p(t_1, \ldots, t_{k-1})[z]/(\check m_\alpha(z))[x]`. If these</span>
<span class="sd">    recursive calls are successful, the GCD over `k` variables is</span>
<span class="sd">    interpolated, otherwise the algorithm returns ``None``. After</span>
<span class="sd">    interpolation, Rational Function Reconstruction is used to obtain the</span>
<span class="sd">    correct coefficients. If this fails, a new evaluation point has to be</span>
<span class="sd">    chosen, otherwise the desired polynomial is obtained by clearing</span>
<span class="sd">    denominators. The result is verified with a fraction free trial</span>
<span class="sd">    division.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[t_1, \ldots, t_k][z]`, not necessarily</span>
<span class="sd">        irreducible</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        primitive associate in `\mathbb Z[t_1, \ldots, t_k][x, z]` of the</span>
<span class="sd">        GCD of the polynomials `f` and `g`  or ``None``, coefficients are</span>
<span class="sd">        in `\left[ -\frac{p-1} 2, \frac{p-1} 2 \right]`</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    * :cite:`Monagan2004algebraic`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>  <span class="c1"># Z[t_1, ..., t_k]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">rings</span><span class="o">.</span><span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ngens</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_euclidean_algorithm</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">qdomain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">to_field</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qdomain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">qdomain</span> <span class="o">=</span> <span class="n">qdomain</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">qdomain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">to_field</span><span class="p">())</span>

    <span class="n">qring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">qdomain</span><span class="p">)</span>  <span class="c1"># = Z(t_k)[t_1, ..., t_{k-1}][x, z]</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># polynomial in Z_p[t_1, ..., t_k][z]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span> <span class="o">*</span> <span class="n">g</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span>
    <span class="c1"># polynomial in Z_p[t_1, ..., t_k]</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">LC</span>

    <span class="n">evalpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LMlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">gammaa</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">minpolya</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">minpoly</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gammaa</span><span class="o">.</span><span class="n">div</span><span class="p">([</span><span class="n">minpolya</span><span class="p">,</span> <span class="n">gammaa</span><span class="o">.</span><span class="n">ring</span><span class="p">(</span><span class="n">p</span><span class="p">)])[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">fa</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">ga</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="c1"># polynomial in Z_p[x, t_1, ..., t_{k-1}, z]/(minpoly)</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="n">_func_field_modgcd_p</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">ga</span><span class="p">,</span> <span class="n">minpolya</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">ha</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ha</span>

        <span class="n">LM</span> <span class="o">=</span> <span class="p">[</span><span class="n">ha</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">ha</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">LM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span> <span class="o">&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span>

        <span class="n">evalpoints_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">heval_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">ha</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">hb</span><span class="p">,</span> <span class="n">LMhb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">heval</span><span class="p">,</span> <span class="n">LMlist</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">LMhb</span> <span class="o">==</span> <span class="n">LM</span><span class="p">:</span>
                <span class="n">evalpoints_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">heval_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hb</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">*=</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">evalpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">heval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span>
        <span class="n">LMlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LM</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># polynomial in Z_p[t_1, ..., t_k][x, z]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_interpolate</span><span class="p">(</span><span class="n">evalpoints_a</span><span class="p">,</span> <span class="n">heval_a</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ground</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># polynomial in Z_p(t_k)[t_1, ..., t_{k-1}][x, z]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_rational_reconstruction_func_coeffs</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">qring</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>

            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">gf_lcm</span><span class="p">(</span><span class="n">den</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">coeff</span><span class="o">.</span><span class="n">denom</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span>
                                                 <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>

            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">gf_lcm</span><span class="p">(</span><span class="n">den</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">denom</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span>
                                                     <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="n">den</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain_new</span><span class="p">(</span><span class="n">den</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">ring</span><span class="p">((</span><span class="n">h</span><span class="o">*</span><span class="n">den</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">trial_division</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">trial_division</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">h</span>

    <span class="k">return</span>


<span class="k">def</span> <span class="nf">_rational_reconstruction_int_coeffs</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct every rational coefficient `c_h` of a polynomial `h` in</span>
<span class="sd">    `\mathbb Q[t_1, \ldots, t_k][x, z]` from the corresponding integer</span>
<span class="sd">    coefficient `c_{h_m}` of a polynomial `h_m` in</span>
<span class="sd">    `\mathbb Z[t_1, \ldots, t_k][x, z]` such that</span>

<span class="sd">    .. math::</span>

<span class="sd">        c_{h_m} = c_h \; \mathrm{mod} \, m,</span>

<span class="sd">    where `m \in \mathbb Z`.</span>

<span class="sd">    The reconstruction is based on the Euclidean Algorithm. In general,</span>
<span class="sd">    `m` is not a prime number, so it is possible that this fails for some</span>
<span class="sd">    coefficient. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    hm : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    m : Integer</span>
<span class="sd">        modulus, not necessarily prime</span>
<span class="sd">    ring : PolynomialRing</span>
<span class="sd">        `\mathbb Q[t_1, \ldots, t_k][x, z]`, `h` will be an element of this</span>
<span class="sd">        ring</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        reconstructed polynomial in `\mathbb Q[t_1, \ldots, t_k][x, z]` or</span>
<span class="sd">        ``None``</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    diofant.ntheory.modular.integer_rational_reconstruction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">rings</span><span class="o">.</span><span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">_rational_reconstruction_int_coeffs</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">integer_rational_reconstruction</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hm</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">coeffh</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffh</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">h</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffh</span>

    <span class="k">return</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in</span>
<span class="sd">    `\mathbb Q(t_1, \ldots, t_k)[z]/(m_{\alpha}(z))[x]` using a modular</span>
<span class="sd">    algorithm.</span>

<span class="sd">    The algorithm computes the GCD of two polynomials `f` and `g` by</span>
<span class="sd">    calculating the GCD in</span>
<span class="sd">    `\mathbb Z_p(t_1, \ldots, t_k)[z] / (\check m_{\alpha}(z))[x]` for</span>
<span class="sd">    suitable primes `p` and the primitive associate `\check m_{\alpha}(z)`</span>
<span class="sd">    of `m_{\alpha}(z)`. Then the coefficients are reconstructed with the</span>
<span class="sd">    Chinese Remainder Theorem and Rational Reconstruction. To compute the</span>
<span class="sd">    GCD over `\mathbb Z_p(t_1, \ldots, t_k)[z] / (\check m_{\alpha})[x]`,</span>
<span class="sd">    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the</span>
<span class="sd">    result in `\mathbb Q(t_1, \ldots, t_k)[z] / (m_{\alpha}(z))[x]`, a</span>
<span class="sd">    fraction free trial division is used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        irreducible polynomial in `\mathbb Z[t_1, \ldots, t_k][z]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        the primitive associate in `\mathbb Z[t_1, \ldots, t_k][x, z]` of</span>
<span class="sd">        the GCD of `f` and `g`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; R, x, z = ring(&#39;x, z&#39;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; minpoly = (z**2 - 2).drop(0)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 + 2*x*z + 2</span>
<span class="sd">    &gt;&gt;&gt; g = x + z</span>
<span class="sd">    &gt;&gt;&gt; _func_field_modgcd_m(f, g, minpoly)</span>
<span class="sd">    x + z</span>

<span class="sd">    &gt;&gt;&gt; D, t = ring(&#39;t&#39;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; R, x, z = ring(&#39;x, z&#39;, D)</span>
<span class="sd">    &gt;&gt;&gt; minpoly = (z**2-3).drop(0)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 + (t + 1)*x*z + 3*t</span>
<span class="sd">    &gt;&gt;&gt; g = x*z + 3*t</span>
<span class="sd">    &gt;&gt;&gt; _func_field_modgcd_m(f, g, minpoly)</span>
<span class="sd">    x + t*z</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    * :cite:`Monagan2004algebraic`</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    _func_field_modgcd_p</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">rings</span><span class="o">.</span><span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ngens</span>
        <span class="n">QQdomain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
        <span class="n">QQring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">QQdomain</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">QQring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>

    <span class="n">cf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">cg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>

    <span class="c1"># polynomial in Z[t_1, ..., t_k][z]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span> <span class="o">*</span> <span class="n">g</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span>
    <span class="c1"># polynomial in Z[t_1, ..., t_k]</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">LC</span>
    <span class="k">assert</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">delta</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">primes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hplist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LMlist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gamma</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">minpolyp</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="n">_func_field_modgcd_p</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">minpolyp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">hp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>

        <span class="n">LM</span> <span class="o">=</span> <span class="p">[</span><span class="n">hp</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">LM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span> <span class="o">&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">hp</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">p</span>

        <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">hq</span><span class="p">,</span> <span class="n">LMhq</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primes</span><span class="p">,</span> <span class="n">hplist</span><span class="p">,</span> <span class="n">LMlist</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">LMhq</span> <span class="o">==</span> <span class="n">LM</span><span class="p">:</span>
                <span class="n">hm</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction</span><span class="p">(</span><span class="n">hq</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">*=</span> <span class="n">q</span>

        <span class="n">primes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">hplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hp</span><span class="p">)</span>
        <span class="n">LMlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LM</span><span class="p">)</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">_rational_reconstruction_int_coeffs</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">QQring</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hm</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">coeff</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">*</span><span class="n">den</span>

        <span class="c1"># convert back to Z[t_1, ..., t_k][x, z] from Q[t_1, ..., t_k][x, z]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">primitive</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">trial_division</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">cf</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">trial_division</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">cg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_to_ZZ_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute an associate of a polynomial</span>
<span class="sd">    `f \in \mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]` in</span>
<span class="sd">    `\mathbb Z[x_1, \ldots, x_{n-1}][z] / (\check m_{\alpha}(z))[x_0]`,</span>
<span class="sd">    where `\check m_{\alpha}(z) \in \mathbb Z[z]` is the primitive associate</span>
<span class="sd">    of the minimal polynomial `m_{\alpha}(z)` of `\alpha` over</span>
<span class="sd">    `\mathbb Q`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>
<span class="sd">    ring : PolynomialRing</span>
<span class="sd">        `\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    f_ : PolyElement</span>
<span class="sd">        associate of `f` in</span>
<span class="sd">        `\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">rings</span><span class="o">.</span><span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">one</span>

    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">to_dense</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">rings</span><span class="o">.</span><span class="n">PolynomialRing</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coeff</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">domain</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f_</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="k">return</span> <span class="n">f_</span>


<span class="k">def</span> <span class="nf">_to_ANP_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a polynomial</span>
<span class="sd">    `f \in \mathbb Z[x_1, \ldots, x_{n-1}][z]/(\check m_{\alpha}(z))[x_0]`</span>
<span class="sd">    to a polynomial in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`,</span>
<span class="sd">    where `\check m_{\alpha}(z) \in \mathbb Z[z]` is the primitive associate</span>
<span class="sd">    of the minimal polynomial `m_{\alpha}(z)` of `\alpha` over</span>
<span class="sd">    `\mathbb Q`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]`</span>
<span class="sd">    ring : PolynomialRing</span>
<span class="sd">        `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    f_ : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">f_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">rings</span><span class="o">.</span><span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">mon</span><span class="p">,</span> <span class="n">coef</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">mon</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">domain</span><span class="p">([</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">coef</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">monom</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f_</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">domain</span><span class="p">([</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">coeff</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">monom</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f_</span><span class="p">:</span>
                <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="k">return</span> <span class="n">f_</span>


<span class="k">def</span> <span class="nf">_minpoly_from_dense</span><span class="p">(</span><span class="n">minpoly</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change representation of the minimal polynomial from ``Poly`` to</span>
<span class="sd">    ``PolyElement`` for a given ring.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minpoly_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">terms</span><span class="p">():</span>
        <span class="n">minpoly_</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">minpoly_</span>


<span class="k">def</span> <span class="nf">_primitive_in_x0</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the content in `x_0` and the primitive part of a polynomial `f`</span>
<span class="sd">    in</span>
<span class="sd">    `\mathbb Q(\alpha)[x_0, x_1, \ldots, x_{n-1}] \cong \mathbb Q(\alpha)[x_1, \ldots, x_{n-1}][x_0]`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">fring</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fring</span><span class="o">.</span><span class="n">ngens</span><span class="p">))</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">f_</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f_</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="n">func_field_modgcd</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cont</span> <span class="o">==</span> <span class="n">dom</span><span class="o">.</span><span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cont</span><span class="p">,</span> <span class="n">f</span>

    <span class="k">return</span> <span class="n">cont</span><span class="p">,</span> <span class="n">f</span><span class="o">//</span><span class="n">cont</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">fring</span><span class="p">)</span>


<span class="c1"># TODO: add support for algebraic function fields</span>
<div class="viewcode-block" id="func_field_modgcd"><a class="viewcode-back" href="../../../internals/polys.html#diofant.polys.modulargcd.func_field_modgcd">[docs]</a><span class="k">def</span> <span class="nf">func_field_modgcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials `f` and `g` in</span>
<span class="sd">    `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]` using a modular algorithm.</span>

<span class="sd">    The algorithm first computes the primitive associate</span>
<span class="sd">    `\check m_{\alpha}(z)` of the minimal polynomial `m_{\alpha}` in</span>
<span class="sd">    `\mathbb{Z}[z]` and the primitive associates of `f` and `g` in</span>
<span class="sd">    `\mathbb{Z}[x_1, \ldots, x_{n-1}][z]/(\check m_{\alpha})[x_0]`. Then it</span>
<span class="sd">    computes the GCD in</span>
<span class="sd">    `\mathbb Q(x_1, \ldots, x_{n-1})[z]/(m_{\alpha}(z))[x_0]`.</span>
<span class="sd">    This is done by calculating the GCD in</span>
<span class="sd">    `\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]` for</span>
<span class="sd">    suitable primes `p` and then reconstructing the coefficients with the</span>
<span class="sd">    Chinese Remainder Theorem and Rational Reconstuction. The GCD over</span>
<span class="sd">    `\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]` is</span>
<span class="sd">    computed with a recursive subroutine, which evaluates the polynomials at</span>
<span class="sd">    `x_{n-1} = a` for suitable evaluation points `a \in \mathbb Z_p` and</span>
<span class="sd">    then calls itself recursively until the ground domain does no longer</span>
<span class="sd">    contain any parameters. For</span>
<span class="sd">    `\mathbb{Z}_p[z]/(\check m_{\alpha}(z))[x_0]` the Euclidean Algorithm is</span>
<span class="sd">    used. The results of those recursive calls are then interpolated and</span>
<span class="sd">    Rational Function Reconstruction is used to obtain the correct</span>
<span class="sd">    coefficients. The results, both in</span>
<span class="sd">    `\mathbb Q(x_1, \ldots, x_{n-1})[z]/(m_{\alpha}(z))[x_0]` and</span>
<span class="sd">    `\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]`, are</span>
<span class="sd">    verified by a fraction free trial division.</span>

<span class="sd">    Apart from the above GCD computation some GCDs in</span>
<span class="sd">    `\mathbb Q(\alpha)[x_1, \ldots, x_{n-1}]` have to be calculated,</span>
<span class="sd">    because treating the polynomials as univariate ones can result in</span>
<span class="sd">    a spurious content of the GCD. For this ``func_field_modgcd`` is</span>
<span class="sd">    called recursively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        monic GCD of the polynomials `f` and `g`</span>
<span class="sd">    cff : PolyElement</span>
<span class="sd">        cofactor of `f`, i.e. `\frac f h`</span>
<span class="sd">    cfg : PolyElement</span>
<span class="sd">        cofactor of `g`, i.e. `\frac g h`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; A = QQ.algebraic_field(sqrt(2))</span>
<span class="sd">    &gt;&gt;&gt; R, x = ring(&#39;x&#39;, A)</span>

<span class="sd">    &gt;&gt;&gt; func_field_modgcd(x**2 - 2, x + sqrt(2))</span>
<span class="sd">    (x + sqrt(2), x - sqrt(2), 1)</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&#39;x, y&#39;, A)</span>

<span class="sd">    &gt;&gt;&gt; func_field_modgcd((x + sqrt(2)*y)**2, x + sqrt(2)*y)</span>
<span class="sd">    (x + sqrt(2)*y, x + sqrt(2)*y, 1)</span>

<span class="sd">    &gt;&gt;&gt; func_field_modgcd(x + sqrt(2)*y, x + y)</span>
<span class="sd">    (1, x + sqrt(2)*y, x + y)</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    * :cite:`Monagan2004algebraic`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="k">assert</span> <span class="n">ring</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">ring</span> <span class="ow">and</span> <span class="n">domain</span><span class="o">.</span><span class="n">is_AlgebraicField</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>

    <span class="n">ZZring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="p">,),</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">f_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ZZring</span><span class="p">)</span>
        <span class="n">g_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ZZring</span><span class="p">)</span>
        <span class="n">minpoly</span> <span class="o">=</span> <span class="n">ZZring</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">to_dense</span><span class="p">())</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f_</span><span class="p">,</span> <span class="n">g_</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_to_ANP_poly</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># contx0f in Q(a)[x_1, ..., x_{n-1}], f in Q(a)[x_0, ..., x_{n-1}]</span>
        <span class="n">contx0f</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">_primitive_in_x0</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">contx0g</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">_primitive_in_x0</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">contx0h</span> <span class="o">=</span> <span class="n">func_field_modgcd</span><span class="p">(</span><span class="n">contx0f</span><span class="p">,</span> <span class="n">contx0g</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ZZring_</span> <span class="o">=</span> <span class="n">ZZring</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="n">f_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ZZring_</span><span class="p">)</span>
        <span class="n">g_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ZZring_</span><span class="p">)</span>
        <span class="n">minpoly</span> <span class="o">=</span> <span class="n">_minpoly_from_dense</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">ZZring_</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f_</span><span class="p">,</span> <span class="n">g_</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_to_ANP_poly</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>

        <span class="n">contx0h_</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">_primitive_in_x0</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">*=</span> <span class="n">contx0h</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">*=</span> <span class="n">contx0f</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">*=</span> <span class="n">contx0g</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">quo_ground</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="o">//</span><span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="o">//</span><span class="n">h</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2006-2018 SymPy Development Team, 2013-2019 Sergey B Kirpichev

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>