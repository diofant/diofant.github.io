<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Internals of the Polynomial Manipulation Module &mdash; Diofant 0.14.0a4.dev1+gfe26709b6 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script>window.MathJax = {"CommonHTML": {"linebreaks": {"automatic": true}}, "HTML-CSS": {"linebreaks": {"automatic": true}}, "SVG": {"linebreaks": {"automatic": true}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Gruntz Algorithm" href="gruntz.html" />
    <link rel="prev" title="Internals" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cli.html">Command-Line Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/index.html">Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Internals</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Internals of the Polynomial Manipulation Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manipulation-of-sparse-distributed-polynomials">Manipulation of sparse, distributed polynomials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polynomial-factorization-algorithms">Polynomial factorization algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#classical-remainder-sequence">Classical remainder sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simplified-remainder-sequences">Simplified remainder sequences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subresultant-sequence">Subresultant sequence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#grobner-basis-algorithms">Gröbner basis algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#algebraic-number-fields">Algebraic number fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-diofant.polys.factorization_alg_field">Factorization over algebraic number fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-diofant.polys.modulargcd">Modular GCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#heuristic-gcd">Heuristic GCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-diofant.polys.rootisolation">Further tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#undocumented">Undocumented</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gruntz.html">The Gruntz Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyperexpand.html">Details on the Hypergeometric Function Expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="g-functions.html">Computing Integrals using Meijer G-Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="evalf.html">Numerical evaluation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../guide.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aboutus.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sources.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Diofant</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Internals</a> &raquo;</li>
      <li>Internals of the Polynomial Manipulation Module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/internals/polys.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="internals-of-the-polynomial-manipulation-module">
<span id="polys-internals"></span><h1>Internals of the Polynomial Manipulation Module<a class="headerlink" href="#internals-of-the-polynomial-manipulation-module" title="Permalink to this headline"></a></h1>
<p>All polynomial manipulations are relative to a <em>ground domain</em>. For
example, when factoring a polynomial like <span class="math notranslate nohighlight">\(x^{10} - 1\)</span>, one has to decide what
ring the coefficients are supposed to belong to, or less trivially, what
coefficients are allowed to appear in the factorization. This choice of
coefficients is called a ground domain. Typical choices include the integers
<span class="math notranslate nohighlight">\(\mathbb{Z}\)</span>, the rational numbers <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span> or various related rings and
fields. But it is perfectly legitimate (although in this case uninteresting)
to factorize over polynomial rings such as <span class="math notranslate nohighlight">\(k[Y]\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is some fixed
field.</p>
<p>Thus the polynomial manipulation algorithms (both
complicated ones like factoring, and simpler ones like addition or
multiplication) have to rely on other code to manipulate the coefficients.
In the polynomial manipulation module, such code is encapsulated in so-called
<a class="reference internal" href="../modules/domains.html#module-diofant.domains" title="diofant.domains"><code class="xref py py-mod docutils literal notranslate"><span class="pre">domains</span></code></a>.  A domain is basically a factory object: it takes various
representations of data, and converts them into objects with unified interface.
Every object created by a domain has to implement the arithmetic operations
<span class="math notranslate nohighlight">\(+\)</span>, <span class="math notranslate nohighlight">\(-\)</span> and <span class="math notranslate nohighlight">\(\times\)</span>. Other operations are accessed through the domain, e.g.
as in <code class="docutils literal notranslate"><span class="pre">ZZ.quo(ZZ(4),</span> <span class="pre">ZZ(2))</span></code>.</p>
<section id="manipulation-of-sparse-distributed-polynomials">
<h2>Manipulation of sparse, distributed polynomials<a class="headerlink" href="#manipulation-of-sparse-distributed-polynomials" title="Permalink to this headline"></a></h2>
<p>Dense representations quickly require infeasible amounts of storage and
computation time if the number of variables increases. For this reason,
there is code to manipulate polynomials in a <em>sparse</em> representation.</p>
<p>Sparse polynomials are represented as dictionaries.</p>
<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.rings.ring">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.rings.</span></span><span class="sig-name descname"><span class="pre">ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order=&lt;diofant.polys.orderings.LexOrder</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L31-L52"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.ring" title="Permalink to this definition"></a></dt>
<dd><p>Construct a polynomial ring returning <code class="docutils literal notranslate"><span class="pre">(ring,</span> <span class="pre">x_1,</span> <span class="pre">...,</span> <span class="pre">x_n)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>symbols</strong> (<em>str, Symbol/Expr or sequence of str, Symbol/Expr (non-empty)</em>)</p></li>
<li><p><strong>domain</strong> (<a class="reference internal" href="../modules/domains.html#diofant.domains.domain.Domain" title="diofant.domains.domain.Domain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Domain</span></code></a> or coercible)</p></li>
<li><p><strong>order</strong> (<a class="reference internal" href="#diofant.polys.polyoptions.Order" title="diofant.polys.polyoptions.Order"><code class="xref py py-class docutils literal notranslate"><span class="pre">Order</span></code></a> or coercible, optional, defaults to <code class="docutils literal notranslate"><span class="pre">lex</span></code>)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span>
<span class="go">ZZ[x,y,z]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="go">x + y + z</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.rings.</span></span><span class="sig-name descname"><span class="pre">PolyElement</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L349-L1584"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement" title="Permalink to this definition"></a></dt>
<dd><p>Element of multivariate distributed polynomial ring.</p>
<p>Polynomial element is mutable, until the hash is computed, e.g.
when the polynomial was added to the <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>.</p>
<p>If one is interested in preserving a polynomial, and one plans
to use inplace operations, one can copy the polynomial first.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">x**2 + 2*x*y + y**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">x**2 + 2*x*y + y**2 + 3</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">... Polynomial element ... can&#39;t be modified ...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../modules/domains.html#diofant.polys.rings.PolynomialRing" title="diofant.polys.rings.PolynomialRing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolynomialRing</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L699-L709"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__add__" title="Permalink to this definition"></a></dt>
<dd><p>Add two polynomials.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L480-L503"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__eq__" title="Permalink to this definition"></a></dt>
<dd><p>Equality test for polynomials.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">==</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1051-L1084"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__getitem__" title="Permalink to this definition"></a></dt>
<dd><p>Returns the coefficient that stands next to the given monomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>element</strong> (PolyElement (with <code class="docutils literal notranslate"><span class="pre">is_monomial</span> <span class="pre">=</span> <span class="pre">True</span></code>) or 1)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">z</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">23</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">]</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">23</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L730-L756"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__mul__" title="Permalink to this definition"></a></dt>
<dd><p>Multiply two polynomials.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__pow__">
<span class="sig-name descname"><span class="pre">__pow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L762-L785"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__pow__" title="Permalink to this definition"></a></dt>
<dd><p>Raise polynomial to power <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L758-L760"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__rmul__" title="Permalink to this definition"></a></dt>
<dd><p>Multiply other to self with other in the coefficient domain of self.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L726-L728"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__rsub__" title="Permalink to this definition"></a></dt>
<dd><p>Substract self from other, with other convertible to the coefficient domain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__sub__">
<span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L714-L724"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.__sub__" title="Permalink to this definition"></a></dt>
<dd><p>Subtract polynomial other from self.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.__weakref__">
<span class="sig-name descname"><span class="pre">__weakref__</span></span><a class="headerlink" href="#diofant.polys.rings.PolyElement.__weakref__" title="Permalink to this definition"></a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.cancel">
<span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1256-L1304"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.cancel" title="Permalink to this definition"></a></dt>
<dd><p>Cancel common factors in a rational function <code class="docutils literal notranslate"><span class="pre">f/g</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(2*x + 2, x - 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1365-L1406"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.compose" title="Permalink to this definition"></a></dt>
<dd><p>Computes the functional composition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.content">
<span class="sig-name descname"><span class="pre">content</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1121-L1132"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.content" title="Permalink to this definition"></a></dt>
<dd><p>Returns GCD of polynomial’s coefficients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L401-L403"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.copy" title="Permalink to this definition"></a></dt>
<dd><p>Return a shallow copy of self.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.degree">
<span class="sig-name descname"><span class="pre">degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1009-L1017"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.degree" title="Permalink to this definition"></a></dt>
<dd><p>The leading degree in <code class="docutils literal notranslate"><span class="pre">x</span></code> or the main variable.</p>
<p>Note that the degree of 0 is negative floating-point infinity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.diff">
<span class="sig-name descname"><span class="pre">diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1306-L1330"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.diff" title="Permalink to this definition"></a></dt>
<dd><p>Computes partial derivative in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x*y**3 + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.discriminant">
<span class="sig-name descname"><span class="pre">discriminant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1408-L1418"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.discriminant" title="Permalink to this definition"></a></dt>
<dd><p>Computes discriminant of a polynomial.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.div">
<span class="sig-name descname"><span class="pre">div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fv</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L889-L964"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.div" title="Permalink to this definition"></a></dt>
<dd><p>Division algorithm for multivariate polynomials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fv</strong> (<em>sequence of PolyElement’s</em>) – List of divsors.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>(qv, r)</strong> (<em>tuple</em>) – Where qv is the sequence of quotients and r is the remainder.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For multivariate polynomials the remainder is not uniquely
determined, unless divisors form a Gröbner basis.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="go">([y, 0], y**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">([</span><span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="p">])</span>
<span class="go">([x, 0], x)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">([</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">([</span><span class="n">g2</span><span class="p">,</span> <span class="n">g1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id1">[<a class="reference internal" href="../sources.html#id157" title="David Cox, John Little, and Donald O'Shea. Ideals, Varieties and Algorithms. Undergraduate Texts in Mathematics. Springer–Verlag, New York, NY, USA, fourth edition, 2015. ISBN 978-3-319-16720-6.">CLOShea15</a>]</span>, p. 64.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.gcdex">
<span class="sig-name descname"><span class="pre">gcdex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1546-L1568"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.gcdex" title="Permalink to this definition"></a></dt>
<dd><p>Extended Euclidean algorithm in <span class="math notranslate nohighlight">\(F[x]\)</span>.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">(s,</span> <span class="pre">t,</span> <span class="pre">h)</span></code> such that <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">gcd(self,</span> <span class="pre">other)</span></code> and
<code class="docutils literal notranslate"><span class="pre">s*self</span> <span class="pre">+</span> <span class="pre">t*other</span> <span class="pre">=</span> <span class="pre">h</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">gcdex</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(-1/5*x + 3/5, 1/5*x**2 - 6/5*x + 2, x + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.integrate">
<span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1332-L1345"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.integrate" title="Permalink to this definition"></a></dt>
<dd><p>Computes indefinite integral in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.leading_expv">
<span class="sig-name descname"><span class="pre">leading_expv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1033-L1046"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.leading_expv" title="Permalink to this definition"></a></dt>
<dd><p>Leading monomial tuple according to the monomial ordering.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">leading_expv</span><span class="p">()</span>
<span class="go">(4, 0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.leading_term">
<span class="sig-name descname"><span class="pre">leading_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1105-L1119"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.leading_term" title="Permalink to this definition"></a></dt>
<dd><p>Leading term as a polynomial element.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">leading_term</span><span class="p">()</span>
<span class="go">3*x*y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.monic">
<span class="sig-name descname"><span class="pre">monic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1142-L1147"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.monic" title="Permalink to this definition"></a></dt>
<dd><p>Divides all coefficients by the leading coefficient.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.prem">
<span class="sig-name descname"><span class="pre">prem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1438-L1495"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.prem" title="Permalink to this definition"></a></dt>
<dd><p>Polynomial pseudo-remainder.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">prem</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-4*y + 4</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id2">[<a class="reference internal" href="../sources.html#id4" title="Donald E. Knuth. The Art of Computer Programming: Seminumerical Algorithms. Addison–Wesley, Reading, MA, USA, second edition, 1985. ISBN 0-201-03822-6.">Knu85</a>]</span>, p. 407.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.primitive">
<span class="sig-name descname"><span class="pre">primitive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1134-L1140"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.primitive" title="Permalink to this definition"></a></dt>
<dd><p>Returns content and a primitive polynomial.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.resultant">
<span class="sig-name descname"><span class="pre">resultant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">includePRS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1497-L1523"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.resultant" title="Permalink to this definition"></a></dt>
<dd><p>Computes resultant of two polynomials in <span class="math notranslate nohighlight">\(K[X]\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">9</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">resultant</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">-3*y**10 - 12*y**7 + y**6 - 54*y**4 + 8*y**3 + 729*y**2 - 216*y + 16</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.subresultants">
<span class="sig-name descname"><span class="pre">subresultants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1525-L1544"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.subresultants" title="Permalink to this definition"></a></dt>
<dd><p>Computes subresultant PRS of two polynomials in <span class="math notranslate nohighlight">\(K[X]\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">9</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">27</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">12</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">7</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">54</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">729</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">216</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">16</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">subresultants</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.tail_degree">
<span class="sig-name descname"><span class="pre">tail_degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1019-L1027"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.tail_degree" title="Permalink to this definition"></a></dt>
<dd><p>The tail degree in <code class="docutils literal notranslate"><span class="pre">x</span></code> or the main variable.</p>
<p>Note that the degree of 0 is negative floating-point infinity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rings.PolyElement.total_degree">
<span class="sig-name descname"><span class="pre">total_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rings.py#L1029-L1031"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rings.PolyElement.total_degree" title="Permalink to this definition"></a></dt>
<dd><p>Returns the total degree.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diofant.polys.univar.UnivarPolyElement">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.univar.</span></span><span class="sig-name descname"><span class="pre">UnivarPolyElement</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/univar.py#L167-L397"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.univar.UnivarPolyElement" title="Permalink to this definition"></a></dt>
<dd><p>Element of univariate distributed polynomial ring.</p>
<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.univar.UnivarPolyElement.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/univar.py#L284-L331"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.univar.UnivarPolyElement.decompose" title="Permalink to this definition"></a></dt>
<dd><p>Compute functional decomposition of <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">K[x]</span></code>.</p>
<p>Given a univariate polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> with coefficients in a field of
characteristic zero, returns list <code class="docutils literal notranslate"><span class="pre">[f_1,</span> <span class="pre">f_2,</span> <span class="pre">...,</span> <span class="pre">f_n]</span></code>, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">f_1</span> <span class="n">o</span> <span class="n">f_2</span> <span class="n">o</span> <span class="o">...</span> <span class="n">f_n</span> <span class="o">=</span> <span class="n">f_1</span><span class="p">(</span><span class="n">f_2</span><span class="p">(</span><span class="o">...</span> <span class="n">f_n</span><span class="p">))</span>
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">f_2,</span> <span class="pre">...,</span> <span class="pre">f_n</span></code> are monic and homogeneous polynomials of at
least second degree.</p>
<p>Unlike factorization, complete functional decompositions of
polynomials are not unique, consider examples:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">f(x</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">o</span> <span class="pre">(g</span> <span class="pre">-</span> <span class="pre">b)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x**n</span> <span class="pre">o</span> <span class="pre">x**m</span> <span class="pre">=</span> <span class="pre">x**m</span> <span class="pre">o</span> <span class="pre">x**n</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T_n</span> <span class="pre">o</span> <span class="pre">T_m</span> <span class="pre">=</span> <span class="pre">T_m</span> <span class="pre">o</span> <span class="pre">T_n</span></code></p></li>
</ol>
<p>where <code class="docutils literal notranslate"><span class="pre">T_n</span></code> and <code class="docutils literal notranslate"><span class="pre">T_m</span></code> are Chebyshev polynomials.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>
<span class="go">[x**2, x**2 - x]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id3">[<a class="reference internal" href="../sources.html#id161" title="Dexter Kozen and Susan Landau. Polynomial Decomposition Algorithms. Journal of Symbolic Computation, 7(5):445–456, 1989. doi:10.1016/S0747-7171(89)80027-6.">KL89</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.univar.UnivarPolyElement.half_gcdex">
<span class="sig-name descname"><span class="pre">half_gcdex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/univar.py#L179-L215"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.univar.UnivarPolyElement.half_gcdex" title="Permalink to this definition"></a></dt>
<dd><p>Half extended Euclidean algorithm in <span class="math notranslate nohighlight">\(F[x]\)</span>.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">(s,</span> <span class="pre">h)</span></code> such that <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">gcd(self,</span> <span class="pre">other)</span></code>
and <code class="docutils literal notranslate"><span class="pre">s*self</span> <span class="pre">=</span> <span class="pre">h</span> <span class="pre">(mod</span> <span class="pre">other)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">half_gcdex</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(-1/5*x + 3/5, x + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.univar.UnivarPolyElement.sturm">
<span class="sig-name descname"><span class="pre">sturm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/univar.py#L333-L353"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.univar.UnivarPolyElement.sturm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Sturm sequence of <code class="docutils literal notranslate"><span class="pre">f</span></code> in <code class="docutils literal notranslate"><span class="pre">F[x]</span></code>.</p>
<p>Given a univariate, square-free polynomial <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> returns the
associated Sturm sequence (see e.g. <span id="id4">[<a class="reference internal" href="../sources.html#id34" title="J. H. Davenport, Y. Siret, and E. Tournier. Computer algebra: systems and algorithms for algebraic computation. Academic Press, New York, NY, USA, 1988. ISBN 0-12-204230-1.">DST88</a>]</span>)
<code class="docutils literal notranslate"><span class="pre">f_0(x),</span> <span class="pre">...,</span> <span class="pre">f_n(x)</span></code> defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f_0</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;(x)</span>
<span class="n">f_n</span> <span class="o">=</span> <span class="o">-</span><span class="n">rem</span><span class="p">(</span><span class="n">f_</span><span class="p">{</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">}(</span><span class="n">x</span><span class="p">),</span> <span class="n">f_</span><span class="p">{</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">}(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">sturm</span><span class="p">()</span>
<span class="go">[x**3 - 2*x**2 + x - 3, 3*x**2 - 4*x + 1, 2/9*x + 25/9, -2079/4]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="polynomial-factorization-algorithms">
<h2>Polynomial factorization algorithms<a class="headerlink" href="#polynomial-factorization-algorithms" title="Permalink to this headline"></a></h2>
<p>Many variants of Euclid’s algorithm:</p>
<span class="target" id="module-diofant.polys.euclidtools"></span><section id="classical-remainder-sequence">
<h3>Classical remainder sequence<a class="headerlink" href="#classical-remainder-sequence" title="Permalink to this headline"></a></h3>
<p>Let <span class="math notranslate nohighlight">\(K\)</span> be a field, and consider the ring <span class="math notranslate nohighlight">\(K[X]\)</span> of polynomials in a single
indeterminate <span class="math notranslate nohighlight">\(X\)</span> with coefficients in <span class="math notranslate nohighlight">\(K\)</span>. Given two elements <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>
of <span class="math notranslate nohighlight">\(K[X]\)</span> with <span class="math notranslate nohighlight">\(g\neq 0\)</span> there are unique polynomials <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(r\)</span> such that
<span class="math notranslate nohighlight">\(f = qg + r\)</span> and <span class="math notranslate nohighlight">\(\deg(r) &lt; \deg(g)\)</span> or <span class="math notranslate nohighlight">\(r = 0\)</span>.
They are denoted by <span class="math notranslate nohighlight">\(\mathrm{quo}(f,g)\)</span>
(<em>quotient</em>) and <span class="math notranslate nohighlight">\(\mathrm{rem}(f,g)\)</span> (<em>remainder</em>), so we have
the <em>division identity</em></p>
<div class="math notranslate nohighlight">
\[f = \mathrm{quo}(f,g)g + \mathrm{rem}(f,g).\]</div>
<p>It follows that every ideal <span class="math notranslate nohighlight">\(I\)</span> of <span class="math notranslate nohighlight">\(K[X]\)</span> is a principal ideal, generated by
any element <span class="math notranslate nohighlight">\(\neq 0\)</span> of minimum degree (assuming <span class="math notranslate nohighlight">\(I\)</span> non-zero). In fact,
if <span class="math notranslate nohighlight">\(g\)</span> is such a polynomial and <span class="math notranslate nohighlight">\(f\)</span> is any element of <span class="math notranslate nohighlight">\(I\)</span>,
<span class="math notranslate nohighlight">\(\mathrm{rem}(f,g)\)</span> belongs to <span class="math notranslate nohighlight">\(I\)</span> as a linear combination of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>,
hence must be zero; therefore <span class="math notranslate nohighlight">\(f\)</span> is a multiple of <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>Using this result it is possible to find a <a class="reference external" href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common
divisor</a>
(gcd) of any polynomials <span class="math notranslate nohighlight">\(f,g,\ldots\)</span> in <span class="math notranslate nohighlight">\(K[X]\)</span>.
If <span class="math notranslate nohighlight">\(I\)</span> is the ideal formed by all linear combinations of the given polynomials
with coefficients in <span class="math notranslate nohighlight">\(K[X]\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> is its generator,
then every common divisor of the polynomials also divides <span class="math notranslate nohighlight">\(d\)</span>.
On the other hand, the given polynomials are multiples of the generator <span class="math notranslate nohighlight">\(d\)</span>;
hence <span class="math notranslate nohighlight">\(d\)</span> is a gcd of the polynomials, denoted <span class="math notranslate nohighlight">\(\mathrm{gcd}(f,g,\ldots)\)</span>.</p>
<p>An algorithm for the gcd of two polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> in <span class="math notranslate nohighlight">\(K[X]\)</span> can
now be obtained as follows.
By the division identity, <span class="math notranslate nohighlight">\(r = \mathrm{rem}(f,g)\)</span> is in the ideal generated
by <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>, as well as <span class="math notranslate nohighlight">\(f\)</span> is in the ideal generated by <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(r\)</span>.
Hence the ideals generated by the pairs <span class="math notranslate nohighlight">\((f,g)\)</span> and <span class="math notranslate nohighlight">\((g,r)\)</span> are the same.
Set <span class="math notranslate nohighlight">\(f_0 = f\)</span>, <span class="math notranslate nohighlight">\(f_1 = g\)</span>, and define recursively
<span class="math notranslate nohighlight">\(f_i = \mathrm{rem}(f_{i-2},f_{i-1})\)</span> for <span class="math notranslate nohighlight">\(i\ge 2\)</span>.
The recursion ends after a finite number of steps with <span class="math notranslate nohighlight">\(f_{k+1}=0\)</span>,
since the degrees of the polynomials are strictly decreasing.
By the above remark, all the pairs <span class="math notranslate nohighlight">\((f_{i-1},f_i)\)</span> generate the same ideal.
In particular, the ideal generated by <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> is generated by <span class="math notranslate nohighlight">\(f_k\)</span>
alone as <span class="math notranslate nohighlight">\(f_{k+1} = 0\)</span>. Hence <span class="math notranslate nohighlight">\(d = f_k\)</span> is a gcd of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>The sequence of polynomials <span class="math notranslate nohighlight">\(f_0\)</span>, <span class="math notranslate nohighlight">\(f_1,\ldots, f_k\)</span> is called the
<em>Euclidean polynomial remainder sequence</em> determined by <span class="math notranslate nohighlight">\((f,g)\)</span> because
of the analogy with the classical <a class="reference external" href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a> for the gcd of
natural numbers.</p>
<p>The algorithm may be extended to obtain an expression for <span class="math notranslate nohighlight">\(d\)</span> in terms of
<span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> by using the full division identities
to write recursively each <span class="math notranslate nohighlight">\(f_i\)</span> as a linear combination of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.
This leads to an equation</p>
<div class="math notranslate nohighlight">
\[d = uf + vg\qquad (u,v \in K[X])\]</div>
<p>analogous to <a class="reference external" href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">Bézout’s identity</a>
in the case of integers.</p>
</section>
<section id="simplified-remainder-sequences">
<h3>Simplified remainder sequences<a class="headerlink" href="#simplified-remainder-sequences" title="Permalink to this headline"></a></h3>
<p>Assume, as is usual, that the coefficient field <span class="math notranslate nohighlight">\(K\)</span> is
the field of fractions of an integral domain <span class="math notranslate nohighlight">\(A\)</span>.
In this case the coefficients (numerators and denominators)
of the polynomials in the Euclidean remainder sequence
tend to grow very fast.</p>
<p>If <span class="math notranslate nohighlight">\(A\)</span> is a unique factorization domain, the coefficients may be
reduced by cancelling common factors of numerators and denominators.
Further reduction is possible noting that a gcd of polynomials in
<span class="math notranslate nohighlight">\(K[X]\)</span> is not unique:
it may be multiplied by any (non-zero) constant factor.</p>
<p>Any polynomial <span class="math notranslate nohighlight">\(f\)</span> in <span class="math notranslate nohighlight">\(K[X]\)</span> can be simplified by extracting
the denominators and common factors of the numerators of its coefficients.
This yields the representation <span class="math notranslate nohighlight">\(f = cF\)</span> where <span class="math notranslate nohighlight">\(c\in K\)</span> is
the <em>content</em> of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(F\)</span> is a <em>primitive</em> polynomial, i.e.,
a polynomial in <span class="math notranslate nohighlight">\(A[X]\)</span> with coprime coefficients.</p>
<p>It is possible to start the algorithm by replacing the given polynomials
<span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> with their primitive parts. This will only modify
<span class="math notranslate nohighlight">\(\mathrm{rem}(f,g)\)</span> by a constant factor.
Replacing it with its primitive part and continuing recursively
we obtain all the primitive parts of the polynomials in
the Euclidean remainder sequence, including the primitive
<span class="math notranslate nohighlight">\(\mathrm{gcd}(f,g)\)</span>.</p>
<p>This sequence is the <em>primitive polynomial remainder sequence</em>.
It is an example of <em>general polynomial remainder sequences</em> where
the computed remainders are modified by constant multipliers (or divisors)
in order to simplify the results.</p>
</section>
<section id="subresultant-sequence">
<h3>Subresultant sequence<a class="headerlink" href="#subresultant-sequence" title="Permalink to this headline"></a></h3>
<p>The coefficients of the primitive polynomial sequence do not grow
exceedingly, but the computation of the primitive parts requires
extra processing effort. Besides, the method only works with fraction fields
of unique factorization domains, excluding, for example, the general number
fields.</p>
<p>Collins <span id="id5">[<a class="reference internal" href="../sources.html#id213" title="George E. Collins. Subresultants and reduced polynomial remainder sequences. Journal of the ACM, 14(1):128–142, January 1967. URL: https://dl.acm.org/citation.cfm?doid=321371.321381, doi:10.1145/321371.321381.">Col67</a>]</span> realized that the so-called <em>subresultant polynomials</em>
of a pair of polynomials also form a generalized remainder sequence.
The coefficients of these polynomials
are expressible as determinants in the coefficients of the given
polynomials. Hence (the logarithm of) their size only grows linearly.
In addition, if the coefficients of the given polynomials
are in the subdomain <span class="math notranslate nohighlight">\(A\)</span>, so are those
of the subresultant polynomials. This means that the subresultant
sequence is comparable to the primitive remainder sequence without
relying on unique factorization in <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>To see how subresultants are associated with remainder sequences
recall that all polynomials <span class="math notranslate nohighlight">\(h\)</span> in the sequence are linear combinations of
the given polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span></p>
<div class="math notranslate nohighlight">
\[h = uf+vg\]</div>
<p>with polynomials <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> in <span class="math notranslate nohighlight">\(K[X]\)</span>. Moreover, as is seen from the
extended Euclidean algorithm, the degrees of <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are relatively
low, with limited growth from step to step.</p>
<p>Let <span class="math notranslate nohighlight">\(n = \deg(f)\)</span>, and <span class="math notranslate nohighlight">\(m = \deg(g)\)</span>, and assume <span class="math notranslate nohighlight">\(n\ge m\)</span>.
If <span class="math notranslate nohighlight">\(\deg(h) = j &lt; m\)</span>, the coefficients of the powers <span class="math notranslate nohighlight">\(X^k\)</span> (<span class="math notranslate nohighlight">\(k &gt; j\)</span>)
in the products <span class="math notranslate nohighlight">\(uf\)</span> and <span class="math notranslate nohighlight">\(vg\)</span> cancel each other. In particular, the
products must have the same degree, say, <span class="math notranslate nohighlight">\(l\)</span>.
Then <span class="math notranslate nohighlight">\(\deg(u) = l - n\)</span> and <span class="math notranslate nohighlight">\(\deg(v) = l - m\)</span> with a total of <span class="math notranslate nohighlight">\(2l -n - m + 2\)</span>
coefficients to be determined.</p>
<p>On the other hand, the equality <span class="math notranslate nohighlight">\(h = uf + vg\)</span> implies that <span class="math notranslate nohighlight">\(l - j\)</span>
linear combinations of the coefficients are zero, those associated with
the powers <span class="math notranslate nohighlight">\(X^i\)</span> (<span class="math notranslate nohighlight">\(j &lt; i \leq l\)</span>), and one has a given non-zero value,
namely the leading coefficient of <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>To satisfy these <span class="math notranslate nohighlight">\(l - j + 1\)</span> linear equations the total number of
coefficients to be determined cannot be lower than <span class="math notranslate nohighlight">\(l - j + 1\)</span>, in general.
This leads to the inequality <span class="math notranslate nohighlight">\(l \ge n + m - j - 1\)</span>.
Taking <span class="math notranslate nohighlight">\(l = n + m - j - 1\)</span>, we obtain <span class="math notranslate nohighlight">\(\deg(u) = m - j - 1\)</span> and
<span class="math notranslate nohighlight">\(\deg(v) = n - j - 1\)</span>.</p>
<p>In the case <span class="math notranslate nohighlight">\(j = 0\)</span> the matrix of the resulting system of linear equations
is the <a class="reference external" href="https://en.wikipedia.org/wiki/Sylvester_matrix">Sylvester matrix</a>
<span class="math notranslate nohighlight">\(S(f,g)\)</span> associated to <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>,
an <span class="math notranslate nohighlight">\((n+m)\times (n+m)\)</span> matrix with coefficients of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> as entries.
Its determinant is the <a class="reference external" href="https://en.wikipedia.org/wiki/Resultant">resultant</a>
<span class="math notranslate nohighlight">\(\mathrm{res}(f,g)\)</span> of the pair <span class="math notranslate nohighlight">\((f,g)\)</span>.
It is non-zero if and only if <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are relatively prime.</p>
<p>For any <span class="math notranslate nohighlight">\(j\)</span> in the interval from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(m\)</span> the matrix of the linear system is
an <span class="math notranslate nohighlight">\((n+m-2j)\times (n+m-2j)\)</span> submatrix of the Sylvester matrix.
Its determinant <span class="math notranslate nohighlight">\(s_j(f,g)\)</span>
is called the <span class="math notranslate nohighlight">\(j\)</span> th <em>scalar subresultant</em> of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(s_j(f,g)\)</span> is not zero, the associated equation <span class="math notranslate nohighlight">\(h = uf + vg\)</span> has
a unique solution where <span class="math notranslate nohighlight">\(\deg(h) = j\)</span> and the leading coefficient
of <span class="math notranslate nohighlight">\(h\)</span> has any given value; the one with leading coefficient
<span class="math notranslate nohighlight">\(s_j(f,g)\)</span> is the <span class="math notranslate nohighlight">\(j\)</span> th <em>subresultant polynomial</em> or, briefly,
<em>subresultant</em> of the pair <span class="math notranslate nohighlight">\((f,g)\)</span>, and denoted <span class="math notranslate nohighlight">\(S_j(f,g)\)</span>.
This choice guarantees that the remainining coefficients
are also certain subdeterminants of the Sylvester matrix.
In particular, if <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are in <span class="math notranslate nohighlight">\(A[X]\)</span>, so is <span class="math notranslate nohighlight">\(S_j(f,g)\)</span> as well.
This construction of subresultants applies to any <span class="math notranslate nohighlight">\(j\)</span> between
<span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(m\)</span> regardless of the value of <span class="math notranslate nohighlight">\(s_j(f,g)\)</span>; if it is zero, then
<span class="math notranslate nohighlight">\(\deg(S_j(f,g)) &lt; j\)</span>.</p>
<p>The properties of subresultants are as follows. Let <span class="math notranslate nohighlight">\(n_0 = \deg(f)\)</span>,
<span class="math notranslate nohighlight">\(n_1 = \deg(g)\)</span>, <span class="math notranslate nohighlight">\(n_2, \ldots, n_k\)</span> be the decreasing sequence of
degrees of polynomials in a remainder sequence.
Let <span class="math notranslate nohighlight">\(0 \le j \le n_1\)</span>; then</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(s_j(f,g)\ne 0\)</span> if and only if <span class="math notranslate nohighlight">\(j = n_i\)</span> for some <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(S_j(f,g)\ne 0\)</span> if and only if <span class="math notranslate nohighlight">\(j = n_i\)</span> or <span class="math notranslate nohighlight">\(j = n_i - 1\)</span> for some <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
</ul>
<p>Normally, <span class="math notranslate nohighlight">\(n_{i-1} - n_i = 1\)</span> for <span class="math notranslate nohighlight">\(1 &lt; i \le k\)</span>. If <span class="math notranslate nohighlight">\(n_{i-1} - n_i &gt; 1\)</span>
for some <span class="math notranslate nohighlight">\(i\)</span> (the <em>abnormal</em> case), then <span class="math notranslate nohighlight">\(S_{n_{i-1}-1}(f,g)\)</span> and
<span class="math notranslate nohighlight">\(S_{n_i}(f,g)\)</span> are constant multiples of each other.
Hence either one could be included in the polynomial remainder sequence.
The former is given by smaller determinants,
so it is expected to have smaller coefficients.</p>
<p>Collins defined the <em>subresultant remainder sequence</em> by setting</p>
<div class="math notranslate nohighlight">
\[f_i = S_{n_{i-1}-1}(f,g) \qquad (2\le i \le k).\]</div>
<p>In the normal case, these are the same as the <span class="math notranslate nohighlight">\(S_{n_i}(f,g)\)</span>. He also
derived expressions for the constants <span class="math notranslate nohighlight">\(\gamma_i\)</span> in the remainder
formulas</p>
<div class="math notranslate nohighlight">
\[\gamma_i f_i = \mathrm{rem}(f_{i-2},f_{i-1})\]</div>
<p>in terms of the leading coefficients of <span class="math notranslate nohighlight">\(f_1,\ldots,f_{i-1}\)</span>, working
in the field <span class="math notranslate nohighlight">\(K\)</span>.</p>
<p>Brown and Traub <span id="id6">[<a class="reference internal" href="../sources.html#id141" title="W. S. Brown and J. F. Traub. On Euclid's Algorithm and the Theory of Subresultants. Journal of the ACM, 18(4):505–514, 1971. doi:10.1145/321662.321665.">BT71</a>]</span> later developed a recursive procedure
for computing the coefficients <span class="math notranslate nohighlight">\(\gamma_i\)</span>. Their algorithm deals with elements
of the domain <span class="math notranslate nohighlight">\(A\)</span> exclusively (assuming <span class="math notranslate nohighlight">\(f,g\in A[X]\)</span>). However, in the
abnormal case there was a problem, a division in <span class="math notranslate nohighlight">\(A\)</span>
which could only be conjectured to be exact.</p>
<p>This was subsequently justified by Brown <span id="id7">[<a class="reference internal" href="../sources.html#id230" title="W. S. Brown. The subresultant prs algorithm. ACM Transactions on Mathematical Software, 4(3):237–249, September 1978. URL: https://dl.acm.org/doi/10.1145/355791.355795, doi:10.1145/355791.355795.">Bro78</a>]</span> who showed that
the result of the division is, in fact, a scalar subresultant.
More specifically, the constant appearing in the computation of <span class="math notranslate nohighlight">\(f_i\)</span> is
<span class="math notranslate nohighlight">\(s_{n_{i-2}}(f,g)\)</span> (Theorem 3).
The implication of this discovery is that the scalar subresultants
are computed as by-products of the algorithm, all but <span class="math notranslate nohighlight">\(s_{n_k}(f,g)\)</span>
which is not needed after finding <span class="math notranslate nohighlight">\(f_{k+1} = 0\)</span>.
Completing the last step we obtain all non-zero scalar subresultants,
including the last one which is the resultant if this does not vanish.</p>
<p>Polynomial factorization in characteristic zero:</p>
<span class="target" id="module-diofant.polys.factortools"></span><p>Polynomial factorization routines in characteristic zero.</p>
</section>
</section>
<section id="grobner-basis-algorithms">
<h2>Gröbner basis algorithms<a class="headerlink" href="#grobner-basis-algorithms" title="Permalink to this headline"></a></h2>
<p>Gröbner bases can be used to answer many problems in computational
commutative algebra. Their computation in rather complicated, and very
performance-sensitive. We present here various low-level implementations of
Gröbner basis computation algorithms; please see the previous section of the
manual for usage.</p>
<span class="target" id="module-diofant.polys.groebnertools"></span><p>Gröbner bases algorithms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.buchberger">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">buchberger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L48-L248"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.buchberger" title="Permalink to this definition"></a></dt>
<dd><p>Computes Gröbner basis for a set of polynomials in <span class="math notranslate nohighlight">\(K[X]\)</span>.</p>
<p>Given a set of multivariate polynomials <span class="math notranslate nohighlight">\(F\)</span>, finds another
set <span class="math notranslate nohighlight">\(G\)</span>, such that Ideal <span class="math notranslate nohighlight">\(F = Ideal G\)</span> and <span class="math notranslate nohighlight">\(G\)</span> is a reduced
Gröbner basis.</p>
<p>The resulting basis is unique and has monic generators if the
ground domains is a field. Otherwise the result is non-unique
but Gröbner bases over e.g. integers can be computed (if the
input polynomials are monic).</p>
<p>Gröbner bases can be used to choose specific generators for a
polynomial ideal. Because these bases are unique you can check
for ideal equality by comparing the Gröbner bases.  To see if
one polynomial lies in an ideal, divide by the elements in the
base and see if the remainder vanishes.</p>
<p>They can also be used to solve systems of polynomial equations
as,  by choosing lexicographic ordering,  you can eliminate one
variable at a time, provided that the ideal is zero-dimensional
(finite number of solutions).</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id8">[<a class="reference internal" href="../sources.html#id207" title="B. Buchberger N.K. Bose and J.P. Guiver. Multidimensional Systems Theory and Applications. Springer, second edition, 2003.">NKBG03</a>]</span></p></li>
<li><p><span id="id9">[<a class="reference internal" href="../sources.html#id35" title="Alessandro Giovini, Teo Mora, Gianfranco Niesi, Lorenzo Robbiano, and Carlo Traverso. “One sugar cube, please” or selection strategies in the Buchberger algorithm. In ISSAC '91: Proceedings of the 1991 International Symposium on Symbolic and Algebraic Computation, 49–54. New York, NY, USA, 1991. ACM Press. doi:10.1145/120694.120701.">GMN+91</a>]</span></p></li>
<li><p><span id="id10">[<a class="reference internal" href="../sources.html#id74" title="Iyad A. Ajwa, Zhuojun Liu, and Paul S. Wang. Gröbner Bases Algorithm. Technical Report ICM-199502-00, ICM Technical Reports Series, 1995.">ALW95</a>]</span></p></li>
<li><p><span id="id11">[<a class="reference internal" href="../sources.html#id157" title="David Cox, John Little, and Donald O'Shea. Ideals, Varieties and Algorithms. Undergraduate Texts in Mathematics. Springer–Verlag, New York, NY, USA, fourth edition, 2015. ISBN 978-3-319-16720-6.">CLOShea15</a>]</span></p></li>
<li><p><span id="id12">[<a class="reference internal" href="../sources.html#id205" title="Thomas Becker and Volker Weispfenning. Gröbner Bases: A Computational Approach to Commutative Algebra. Volume 141 of Graduate Texts in Mathematics. Springer–Verlag, New York, NY, USA, 1993. ISBN 0-387-97971-9. In Cooperation with Heinz Kredel.">BW93</a>]</span>, page 232</p></li>
</ul>
<p class="rubric">Notes</p>
<p>Used an improved version of Buchberger’s algorithm
as presented in <span id="id13">[<a class="reference internal" href="../sources.html#id205" title="Thomas Becker and Volker Weispfenning. Gröbner Bases: A Computational Approach to Commutative Algebra. Volume 141 of Graduate Texts in Mathematics. Springer–Verlag, New York, NY, USA, 1993. ISBN 0-387-97971-9. In Cooperation with Heinz Kredel.">BW93</a>]</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.cp_key">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">cp_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L434-L436"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.cp_key" title="Permalink to this definition"></a></dt>
<dd><p>Key for comparing critical pairs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.critical_pair">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">critical_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L398-L431"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.critical_pair" title="Permalink to this definition"></a></dt>
<dd><p>Compute the critical pair corresponding to two labeled polynomials.</p>
<p>A critical pair is a tuple (um, f, vm, g), where um and vm are
terms such that um * f - vm * g is the S-polynomial of f and g (so,
wlog assume um * f &gt; vm * g).
For performance sake, a critical pair is represented as a tuple
(Sign(um * f), um, f, Sign(vm * g), vm, g), since um * f creates
a new, relatively expensive object in memory, whereas Sign(um *
f) and um are lightweight and f (in the tuple) is a reference to
an already existing object in memory.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.f5_reduce">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">f5_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L476-L519"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.f5_reduce" title="Permalink to this definition"></a></dt>
<dd><p>F5-reduce a labeled polynomial f by B.</p>
<p>Continously searches for non-zero labeled polynomial h in B, such
that the leading term lt_h of h divides the leading term lt_f of
f and Sign(lt_h * h) &lt; Sign(f). If such a labeled polynomial h is
found, f gets replaced by f - lt_f / lt_h * h. If no such h can be
found or f is 0, f is no further F5-reducible and f gets returned.</p>
<p>A polynomial that is reducible in the usual sense need not be
F5-reducible, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">lex</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lbp</span><span class="p">(</span><span class="n">sig</span><span class="p">(</span><span class="n">Monomial</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">4</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">lbp</span><span class="p">(</span><span class="n">sig</span><span class="p">(</span><span class="n">Monomial</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Polyn</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">div</span><span class="p">([</span><span class="n">Polyn</span><span class="p">(</span><span class="n">g</span><span class="p">)])[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">g</span><span class="p">])</span>
<span class="go">(((1, 1, 1), 4), x, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.f5b">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">f5b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L522-L641"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.f5b" title="Permalink to this definition"></a></dt>
<dd><p>Computes a reduced Gröbner basis for the ideal generated by F.</p>
<p>f5b is an implementation of the F5B algorithm by Yao Sun and
Dingkang Wang. Similarly to Buchberger’s algorithm, the algorithm
proceeds by computing critical pairs, computing the S-polynomial,
reducing it and adjoining the reduced S-polynomial if it is not 0.</p>
<p>Unlike Buchberger’s algorithm, each polynomial contains additional
information, namely a signature and a number. The signature
specifies the path of computation (i.e. from which polynomial in
the original basis was it derived and how), the number says when
the polynomial was added to the basis.  With this information it
is (often) possible to decide if an S-polynomial will reduce to
0 and can be discarded.</p>
<p>Optimizations include: Reducing the generators before computing
a Gröbner basis, removing redundant critical pairs when a new
polynomial enters the basis and sorting the critical pairs and
the current basis.</p>
<p>Once a Gröbner basis has been found, it gets reduced.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id14">[<a class="reference internal" href="../sources.html#id223" title="Yao Sun and Dingkang Wang. A new proof of the F5 algorithm. CoRR, 2010. URL: https://arxiv.org/abs/1004.0084, arXiv:1004.0084.">SW10</a>]</span></p></li>
<li><p><span id="id15">[<a class="reference internal" href="../sources.html#id205" title="Thomas Becker and Volker Weispfenning. Gröbner Bases: A Computational Approach to Commutative Algebra. Volume 141 of Graduate Texts in Mathematics. Springer–Verlag, New York, NY, USA, 1993. ISBN 0-387-97971-9. In Cooperation with Heinz Kredel.">BW93</a>]</span>, pp. 203, 216.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.groebner">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">groebner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L9-L45"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.groebner" title="Permalink to this definition"></a></dt>
<dd><p>Computes Gröbner basis for a set of polynomials in <span class="math notranslate nohighlight">\(K[X]\)</span>.</p>
<p>Wrapper around the (default) improved Buchberger and the other algorithms
for computing Gröbner bases. The choice of algorithm can be changed via
<code class="docutils literal notranslate"><span class="pre">method</span></code> argument or <a class="reference internal" href="../modules/config.html#diofant.config.setup" title="diofant.config.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code></a>,
where <code class="docutils literal notranslate"><span class="pre">method</span></code> can be either <code class="docutils literal notranslate"><span class="pre">buchberger</span></code> or <code class="docutils literal notranslate"><span class="pre">f5b</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.groebner_gcd">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">groebner_gcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L746-L762"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.groebner_gcd" title="Permalink to this definition"></a></dt>
<dd><p>Computes GCD of two polynomials using Gröbner bases.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.groebner_lcm">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">groebner_lcm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L709-L743"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.groebner_lcm" title="Permalink to this definition"></a></dt>
<dd><p>Computes LCM of two polynomials using Gröbner bases.</p>
<p>The LCM is computed as the unique generator of the intersection
of the two ideals generated by <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>. The approach is to
compute a Gröbner basis with respect to lexicographic ordering
of <span class="math notranslate nohighlight">\(t*f\)</span> and <span class="math notranslate nohighlight">\((1 - t)*g\)</span>, where <span class="math notranslate nohighlight">\(t\)</span> is an unrelated variable and
then filtering out the solution that doesn’t contain <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id16">[<a class="reference internal" href="../sources.html#id157" title="David Cox, John Little, and Donald O'Shea. Ideals, Varieties and Algorithms. Undergraduate Texts in Mathematics. Springer–Verlag, New York, NY, USA, fourth edition, 2015. ISBN 978-3-319-16720-6.">CLOShea15</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.is_groebner">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">is_groebner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L680-L689"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.is_groebner" title="Permalink to this definition"></a></dt>
<dd><p>Check if G is a Gröbner basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.is_minimal">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">is_minimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L692-L706"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.is_minimal" title="Permalink to this definition"></a></dt>
<dd><p>Checks if G is a minimal Gröbner basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.is_rewritable_or_comparable">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">is_rewritable_or_comparable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sign</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L448-L473"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.is_rewritable_or_comparable" title="Permalink to this definition"></a></dt>
<dd><p>Check if a labeled polynomial is redundant by checking if its
signature and number imply rewritability or comparability.</p>
<p>(sign, num) is comparable if there exists a labeled polynomial
h in B, such that sign[1] (the index) is less than Sign(h)[1]
and sign[0] is divisible by the leading monomial of h.</p>
<p>(sign, num) is rewritable if there exists a labeled polynomial
h in B, such thatsign[1] is equal to Sign(h)[1], num &lt; Num(h)
and sign[0] is divisible by Sign(h)[0].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.lbp_cmp">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">lbp_cmp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L372-L388"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.lbp_cmp" title="Permalink to this definition"></a></dt>
<dd><p>Compare two labeled polynomials.</p>
<dl class="simple">
<dt>f &lt; g iff</dt><dd><ul class="simple">
<li><p>Sign(f) &lt; Sign(g)</p></li>
</ul>
</dd>
<dt>or</dt><dd><ul class="simple">
<li><p>Sign(f) == Sign(g) and Num(f) &gt; Num(g)</p></li>
</ul>
</dd>
</dl>
<p>f &gt; g otherwise</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.lbp_key">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">lbp_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L391-L393"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.lbp_key" title="Permalink to this definition"></a></dt>
<dd><p>Key for comparing two labeled polynomials.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.lbp_mul_term">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">lbp_mul_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cx</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L360-L369"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.lbp_mul_term" title="Permalink to this definition"></a></dt>
<dd><p>Multiply a labeled polynomial with a term.</p>
<p>The product of a labeled polynomial (s, p, k) by a monomial is
defined as (m * s, m * p, k).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.lbp_sub">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">lbp_sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L342-L357"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.lbp_sub" title="Permalink to this definition"></a></dt>
<dd><p>Subtract labeled polynomial g from f.</p>
<p>The signature and number of the difference of f and g are signature
and number of the maximum of f and g, w.r.t. lbp_cmp.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.matrix_fglm">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">matrix_fglm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">O_to</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L765-L825"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.matrix_fglm" title="Permalink to this definition"></a></dt>
<dd><p>Converts the reduced Gröbner basis <code class="docutils literal notranslate"><span class="pre">F</span></code> of a zero-dimensional
ideal w.r.t. <code class="docutils literal notranslate"><span class="pre">O_from</span></code> to a reduced Gröbner basis
w.r.t. <code class="docutils literal notranslate"><span class="pre">O_to</span></code>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id17">[<a class="reference internal" href="../sources.html#id222" title="J.C. Faugère, P. Gianni, D. Lazard, and T. Mora. Efficient computation of zero-dimensional gröbner bases by change of ordering. Journal of Symbolic Computation, 16(4):329–344, October 1993. URL: https://www.sciencedirect.com/science/article/pii/S0747717183710515, doi:10.1006/jsco.1993.1051.">FaugereGLM93</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.red_groebner">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">red_groebner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L644-L677"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.red_groebner" title="Permalink to this definition"></a></dt>
<dd><p>Compute reduced Gröbner basis.</p>
<p>Selects a subset of generators, that already generate the ideal
and computes a reduced Gröbner basis for them.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id18">[<a class="reference internal" href="../sources.html#id205" title="Thomas Becker and Volker Weispfenning. Gröbner Bases: A Computational Approach to Commutative Algebra. Volume 141 of Graduate Texts in Mathematics. Springer–Verlag, New York, NY, USA, 1993. ISBN 0-387-97971-9. In Cooperation with Heinz Kredel.">BW93</a>]</span>, page 216.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.s_poly">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">s_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cp</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L439-L445"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.s_poly" title="Permalink to this definition"></a></dt>
<dd><p>Compute the S-polynomial of a critical pair.</p>
<p>The S-polynomial of a critical pair cp is cp[1] * cp[2] - cp[4] * cp[5].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.sig_cmp">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">sig_cmp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L297-L313"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.sig_cmp" title="Permalink to this definition"></a></dt>
<dd><p>Compare two signatures by extending the term order to K[X]^n.</p>
<dl class="simple">
<dt>u &lt; v iff</dt><dd><ul class="simple">
<li><p>the index of v is greater than the index of u</p></li>
</ul>
</dd>
<dt>or</dt><dd><ul class="simple">
<li><p>the index of v is equal to the index of u and u[0] &lt; v[0] w.r.t. order</p></li>
</ul>
</dd>
</dl>
<p>u &gt; v otherwise</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.sig_key">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">sig_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L316-L326"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.sig_key" title="Permalink to this definition"></a></dt>
<dd><p>Key for comparing two signatures.</p>
<p>s = (m, k), t = (n, l)</p>
<p>s &lt; t iff [k &gt; l] or [k == l and m &lt; n]
s &gt; t otherwise</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.sig_mult">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">sig_mult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L329-L337"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.sig_mult" title="Permalink to this definition"></a></dt>
<dd><p>Multiply a signature by a monomial.</p>
<p>The product of a signature (m, i) and a monomial n is defined as
(m * t, i).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.groebnertools.spoly">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.groebnertools.</span></span><span class="sig-name descname"><span class="pre">spoly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/groebnertools.py#L251-L268"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.groebnertools.spoly" title="Permalink to this definition"></a></dt>
<dd><p>Compute LCM(LM(p1), LM(p2))/LM(p1)*p1 - LCM(LM(p1), LM(p2))/LM(p2)*p2.</p>
<p>This is the S-poly, provided p1 and p2 are monic</p>
</dd></dl>

</section>
<section id="algebraic-number-fields">
<h2>Algebraic number fields<a class="headerlink" href="#algebraic-number-fields" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.numberfields.minpoly_groebner">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.numberfields.</span></span><span class="sig-name descname"><span class="pre">minpoly_groebner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/numberfields.py#L598-L680"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.numberfields.minpoly_groebner" title="Permalink to this definition"></a></dt>
<dd><p>Computes the minimal polynomial of an algebraic number
using Gröbner bases</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minimal_polynomial</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;groebner&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="go">x**2 - 2*x - 1</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id19">[<a class="reference internal" href="../sources.html#id152" title="William Wells Adams and Philippe Loustaunau. An Introduction to Gröbner Bases. American Mathematical Society, Boston, MA, USA, July 1994. ISBN 0-821-83804-0.">AL94</a>]</span></p></li>
</ul>
</dd></dl>

</section>
<section id="module-diofant.polys.factorization_alg_field">
<span id="factorization-over-algebraic-number-fields"></span><h2>Factorization over algebraic number fields<a class="headerlink" href="#module-diofant.polys.factorization_alg_field" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._alpha_to_z">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_alpha_to_z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L25-L62"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._alpha_to_z" title="Permalink to this definition"></a></dt>
<dd><p>Change the representation of a polynomial over
<span class="math notranslate nohighlight">\(\mathbb Q(\alpha)\)</span> by replacing the algebraic element <span class="math notranslate nohighlight">\(\alpha\)</span> by a new
variable <span class="math notranslate nohighlight">\(z\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_n]\)</span></p></li>
<li><p><strong>ring</strong> (<em>PolynomialRing</em>) – the polynomial ring <span class="math notranslate nohighlight">\(\mathbb Q[x_0, \ldots, x_n, z]\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>f_</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Q[x_0, \ldots, x_n, z]\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._denominator">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_denominator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L142-L156"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._denominator" title="Permalink to this definition"></a></dt>
<dd><p>Compute the denominator <span class="math notranslate nohighlight">\(\mathrm{den}(f)\)</span> of a polynomial <span class="math notranslate nohighlight">\(f\)</span> over
<span class="math notranslate nohighlight">\(\mathbb Q\)</span>, i.e. the smallest integer such that <span class="math notranslate nohighlight">\(\mathrm{den}(f) f\)</span> is
a polynomial over <span class="math notranslate nohighlight">\(\mathbb Z\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._diophantine">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_diophantine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L616-L688"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._diophantine" title="Permalink to this definition"></a></dt>
<dd><p>Solve multivariate Diophantine equations over <span class="math notranslate nohighlight">\(\mathbb Z_p[z]/(\mu(z))\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._diophantine_univariate">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_diophantine_univariate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L556-L613"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._diophantine_univariate" title="Permalink to this definition"></a></dt>
<dd><p>Solve univariate Diophantine equations of the form</p>
<div class="math notranslate nohighlight">
\[\sum_{f \in F} \left( h_f(x) \cdot \prod_{g \in F \setminus \lbrace f \rbrace } g(x) \right) = x^m\]</div>
<p>over <span class="math notranslate nohighlight">\(\mathbb Z_p[z]/(\mu(z))\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._distinct_prime_divisors">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_distinct_prime_divisors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L102-L139"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._distinct_prime_divisors" title="Permalink to this definition"></a></dt>
<dd><p>Try to find pairwise coprime divisors of all elements of a given list
<span class="math notranslate nohighlight">\(S\)</span> of integers.</p>
<p>If this fails, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id20">[<a class="reference internal" href="../sources.html#id93" title="Seyed Mohammad Mahdi Javadi and Michael Monagan. On Factorization of Multivariate Polynomials over Algebraic Number and Function Fields. In ISSAC '09: Proceedings of the 2009 International Symposium on Symbolic and Algebraic Computation, 199–206. New York, NY, USA, 2009. ACM Press. doi:10.1145/1576702.1576731.">JM09</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._div">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L492-L519"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._div" title="Permalink to this definition"></a></dt>
<dd><p>Division with remainder for univariate polynomials over
<span class="math notranslate nohighlight">\(\mathbb Z_p[z]/(\mu(z))\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._extended_euclidean_algorithm">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_extended_euclidean_algorithm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L522-L553"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._extended_euclidean_algorithm" title="Permalink to this definition"></a></dt>
<dd><p>Extended Euclidean Algorithm for univariate polynomials over
<span class="math notranslate nohighlight">\(\mathbb Z_p[z]/(\mu(z))\)</span>.</p>
<p>Returns <span class="math notranslate nohighlight">\(s, t, h\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the GCD of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> and
<span class="math notranslate nohighlight">\(sf + tg = h\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._factor">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L814-L942"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._factor" title="Permalink to this definition"></a></dt>
<dd><p>Factor a multivariate polynomial <span class="math notranslate nohighlight">\(f\)</span>, which is squarefree and primitive
in <span class="math notranslate nohighlight">\(x_0\)</span>, in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_n]\)</span>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id21">[<a class="reference internal" href="../sources.html#id93" title="Seyed Mohammad Mahdi Javadi and Michael Monagan. On Factorization of Multivariate Polynomials over Algebraic Number and Function Fields. In ISSAC '09: Proceedings of the 2009 International Symposium on Symbolic and Algebraic Computation, 199–206. New York, NY, USA, 2009. ACM Press. doi:10.1145/1576702.1576731.">JM09</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._hensel_lift">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_hensel_lift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L691-L774"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._hensel_lift" title="Permalink to this definition"></a></dt>
<dd><p>Parallel Hensel lifting algorithm over <span class="math notranslate nohighlight">\(\mathbb  Z_p[z]/(\mu(z))\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – squarefree polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[x_0, \ldots, x_n, z]\)</span></p></li>
<li><p><strong>H</strong> (<em>list of PolyElement objects</em>) – monic univariate factors of <span class="math notranslate nohighlight">\(f(x_0, A)\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z[x_0, z]\)</span></p></li>
<li><p><strong>LC</strong> (<em>list of PolyElement objects</em>) – true leading coefficients of the irreducible factors of <span class="math notranslate nohighlight">\(f\)</span></p></li>
<li><p><strong>A</strong> (<em>list of Integer objects</em>) – the evaluation point <span class="math notranslate nohighlight">\([a_1, \ldots, a_n]\)</span></p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pfactors</strong> (<em>list of PolyElement objects</em>) – irreducible factors of <span class="math notranslate nohighlight">\(f\)</span> modulo <span class="math notranslate nohighlight">\(p\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._leading_coeffs">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_leading_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcfactors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divisors</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L184-L296"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._leading_coeffs" title="Permalink to this definition"></a></dt>
<dd><p>Compute the true leading coefficients in <span class="math notranslate nohighlight">\(x_0\)</span> of the irreducible
factors of a polynomial <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>If this fails, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – squarefree polynomial in <span class="math notranslate nohighlight">\(Z[x_0, \ldots, x_n, z]\)</span></p></li>
<li><p><strong>U</strong> (<em>list of PolyElement objects</em>) – monic univariate factors of <span class="math notranslate nohighlight">\(f(x_0, A)\)</span> in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0]\)</span></p></li>
<li><p><strong>gamma</strong> (<em>Integer</em>) – integer content of <span class="math notranslate nohighlight">\(\mathrm{lc}_{x_0}(f)\)</span></p></li>
<li><p><strong>lcfactors</strong> (<em>list of (PolyElement, Integer) objects</em>) – factorization of <span class="math notranslate nohighlight">\(\mathrm{lc}_{x_0}(f)\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z[x_1, \ldots, x_n, z]\)</span></p></li>
<li><p><strong>A</strong> (<em>list of Integer objects</em>) – the evaluation point <span class="math notranslate nohighlight">\([a_1, \ldots, a_n]\)</span></p></li>
<li><p><strong>D</strong> (<em>Integer</em>) – integral multiple of the defect of <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)\)</span></p></li>
<li><p><strong>denoms</strong> (<em>list of Integer objects</em>) – denominators of <span class="math notranslate nohighlight">\(\frac 1 {l(A)}\)</span> for <span class="math notranslate nohighlight">\(l\)</span> in <code class="docutils literal notranslate"><span class="pre">lcfactors</span></code></p></li>
<li><p><strong>divisors</strong> (<em>list of Integer objects</em>) – pairwise coprime divisors of all elements of <code class="docutils literal notranslate"><span class="pre">denoms</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – possibly updated polynomial <span class="math notranslate nohighlight">\(f\)</span></p></li>
<li><p><strong>lcs</strong> (<em>list of PolyElement objects</em>) – true leading coefficients of the irreducible factors of <span class="math notranslate nohighlight">\(f\)</span></p></li>
<li><p><strong>U_</strong> (<em>list of PolyElement objects</em>) – list of possibly updated monic associates of the univariate factors
<span class="math notranslate nohighlight">\(U\)</span></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id22">[<a class="reference internal" href="../sources.html#id93" title="Seyed Mohammad Mahdi Javadi and Michael Monagan. On Factorization of Multivariate Polynomials over Algebraic Number and Function Fields. In ISSAC '09: Proceedings of the 2009 International Symposium on Symbolic and Algebraic Computation, 199–206. New York, NY, USA, 2009. ACM Press. doi:10.1145/1576702.1576731.">JM09</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._monic_associate">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_monic_associate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L159-L181"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._monic_associate" title="Permalink to this definition"></a></dt>
<dd><p>Compute the monic associate of a polynomial <span class="math notranslate nohighlight">\(f\)</span> over
<span class="math notranslate nohighlight">\(\mathbb Q(\alpha)\)</span>, which is defined as</p>
<div class="math notranslate nohighlight">
\[\mathrm{den}\left( \frac 1 {\mathrm{lc}(f)} f \right) \cdot \frac 1 {\mathrm{lc}(f)} f.\]</div>
<p>The result is a polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[x_0, \ldots, x_n, z]\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#diofant.polys.factorization_alg_field._denominator" title="diofant.polys.factorization_alg_field._denominator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_denominator</span></code></a>, <a class="reference internal" href="#diofant.polys.factorization_alg_field._alpha_to_z" title="diofant.polys.factorization_alg_field._alpha_to_z"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_alpha_to_z</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._padic_lift">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_padic_lift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pfactors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L386-L489"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._padic_lift" title="Permalink to this definition"></a></dt>
<dd><p>Lift the factorization of a polynomial over <span class="math notranslate nohighlight">\(\mathbb Z_p[z]/(\mu(z))\)</span> to
a factorization over <span class="math notranslate nohighlight">\(\mathbb Z_{p^m}[z]/(\mu(z))\)</span>, where <span class="math notranslate nohighlight">\(p^m \geq B\)</span>.</p>
<p>If this fails, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – squarefree polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[x_0, \ldots, x_n, z]\)</span></p></li>
<li><p><strong>pfactors</strong> (<em>list of PolyElement objects</em>) – irreducible factors of <span class="math notranslate nohighlight">\(f\)</span> modulo <span class="math notranslate nohighlight">\(p\)</span></p></li>
<li><p><strong>lcs</strong> (<em>list of PolyElement objects</em>) – true leading coefficients in <span class="math notranslate nohighlight">\(x_0\)</span> of the irreducible factors of <span class="math notranslate nohighlight">\(f\)</span></p></li>
<li><p><strong>B</strong> (<em>Integer</em>) – heuristic numerical bound on the size of the largest integer
coefficient in the irreducible factors of <span class="math notranslate nohighlight">\(f\)</span></p></li>
<li><p><strong>minpoly</strong> (<em>PolyElement</em>) – minimal polynomial <span class="math notranslate nohighlight">\(\mu\)</span> of <span class="math notranslate nohighlight">\(\alpha\)</span> over <span class="math notranslate nohighlight">\(\mathbb Q\)</span></p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>H</strong> (<em>list of PolyElement objects</em>) – factorization of <span class="math notranslate nohighlight">\(f\)</span> modulo <span class="math notranslate nohighlight">\(p^m\)</span>, where <span class="math notranslate nohighlight">\(p^m \geq B\)</span></p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id23">[<a class="reference internal" href="../sources.html#id93" title="Seyed Mohammad Mahdi Javadi and Michael Monagan. On Factorization of Multivariate Polynomials over Algebraic Number and Function Fields. In ISSAC '09: Proceedings of the 2009 International Symposium on Symbolic and Algebraic Computation, 199–206. New York, NY, USA, 2009. ACM Press. doi:10.1145/1576702.1576731.">JM09</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._sqf_p">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_sqf_p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L777-L790"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._sqf_p" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <span class="math notranslate nohighlight">\(f\)</span> is square-free in <span class="math notranslate nohighlight">\(\mathbb Z_p[z]/(\mu(z))[x]\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._subs_ground">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_subs_ground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L371-L383"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._subs_ground" title="Permalink to this definition"></a></dt>
<dd><p>Substitute variables in the coefficients of a polynomial <span class="math notranslate nohighlight">\(f\)</span> over a
<code class="docutils literal notranslate"><span class="pre">PolynomialRing</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._test_evaluation_points">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_test_evaluation_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcfactors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L299-L368"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._test_evaluation_points" title="Permalink to this definition"></a></dt>
<dd><p>Test if an evaluation point is suitable for _factor.</p>
<p>If it is not, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – squarefree polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[x_0, \ldots, x_n, z]\)</span></p></li>
<li><p><strong>gamma</strong> (<em>Integer</em>) – leading coefficient of <span class="math notranslate nohighlight">\(f\)</span> in <span class="math notranslate nohighlight">\(\mathbb Z\)</span></p></li>
<li><p><strong>lcfactors</strong> (<em>list of (PolyElement, Integer) objects</em>) – factorization of <span class="math notranslate nohighlight">\(\mathrm{lc}_{x_0}(f)\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z[x_1, \ldots, x_n, z]\)</span></p></li>
<li><p><strong>A</strong> (<em>list of Integer objects</em>) – the evaluation point <span class="math notranslate nohighlight">\([a_1, \ldots, a_n]\)</span></p></li>
<li><p><strong>D</strong> (<em>Integer</em>) – integral multiple of the defect of <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fA</strong> (<em>PolyElement</em>) – <span class="math notranslate nohighlight">\(f\)</span> evaluated at <span class="math notranslate nohighlight">\(A\)</span>, i.e. <span class="math notranslate nohighlight">\(f(x_0, A)\)</span></p></li>
<li><p><strong>denoms</strong> (<em>list of Integer objects</em>) – the denominators of <span class="math notranslate nohighlight">\(\frac 1 {l(A)}\)</span> for <span class="math notranslate nohighlight">\(l\)</span> in <code class="docutils literal notranslate"><span class="pre">lcfactors</span></code></p></li>
<li><p><strong>divisors</strong> (<em>list of Integer objects</em>) – pairwise coprime divisors of all elements of <code class="docutils literal notranslate"><span class="pre">denoms</span></code></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id24">[<a class="reference internal" href="../sources.html#id93" title="Seyed Mohammad Mahdi Javadi and Michael Monagan. On Factorization of Multivariate Polynomials over Algebraic Number and Function Fields. In ISSAC '09: Proceedings of the 2009 International Symposium on Symbolic and Algebraic Computation, 199–206. New York, NY, USA, 2009. ACM Press. doi:10.1145/1576702.1576731.">JM09</a>]</span></p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#diofant.polys.factorization_alg_field._factor" title="diofant.polys.factorization_alg_field._factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_factor</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._test_prime">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_test_prime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L793-L810"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._test_prime" title="Permalink to this definition"></a></dt>
<dd><p>Test if a prime number is suitable for _factor.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#diofant.polys.factorization_alg_field._factor" title="diofant.polys.factorization_alg_field._factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_factor</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field._z_to_alpha">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">_z_to_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L65-L99"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field._z_to_alpha" title="Permalink to this definition"></a></dt>
<dd><p>Change the representation of a polynomial in
<span class="math notranslate nohighlight">\(\mathbb Q[x_0, \ldots, x_n, z]\)</span> by replacing the variable <span class="math notranslate nohighlight">\(z\)</span> by the
algebraic element <span class="math notranslate nohighlight">\(\alpha\)</span> of the given ring
<span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_n]\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Q[x_0, \ldots, x_n, z]\)</span></p></li>
<li><p><strong>ring</strong> (<em>PolynomialRing</em>) – the polynomial ring <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_n]\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>f_</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_n]\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.factorization_alg_field.efactor">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.factorization_alg_field.</span></span><span class="sig-name descname"><span class="pre">efactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/factorization_alg_field.py#L946-L989"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.factorization_alg_field.efactor" title="Permalink to this definition"></a></dt>
<dd><p>Factor a multivariate polynomial <span class="math notranslate nohighlight">\(f\)</span> in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_n]\)</span>.</p>
<p>By default, an estimate of the defect of the algebraic field is included
in all computations. If <code class="docutils literal notranslate"><span class="pre">save</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the defect will be
treated as one, thus computations are faster. However, if the defect of
<span class="math notranslate nohighlight">\(\alpha\)</span> is larger than one, this may lead to wrong results.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id25">[<a class="reference internal" href="../sources.html#id93" title="Seyed Mohammad Mahdi Javadi and Michael Monagan. On Factorization of Multivariate Polynomials over Algebraic Number and Function Fields. In ISSAC '09: Proceedings of the 2009 International Symposium on Symbolic and Algebraic Computation, 199–206. New York, NY, USA, 2009. ACM Press. doi:10.1145/1576702.1576731.">JM09</a>]</span></p></li>
</ul>
</dd></dl>

</section>
<section id="module-diofant.polys.modulargcd">
<span id="modular-gcd"></span><h2>Modular GCD<a class="headerlink" href="#module-diofant.polys.modulargcd" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._chinese_remainder_reconstruction">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_chinese_remainder_reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L12-L104"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._chinese_remainder_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Construct a polynomial <span class="math notranslate nohighlight">\(h_{pq}\)</span> in
<span class="math notranslate nohighlight">\(\mathbb{Z}_{p q}[x_0, \ldots, x_{k-1}]\)</span> such that</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}h_{pq} = h_p \; \mathrm{mod} \, p\\h_{pq} = h_q \; \mathrm{mod} \, q\end{aligned}\end{align} \]</div>
<p>for relatively prime integers <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> and polynomials
<span class="math notranslate nohighlight">\(h_p\)</span> and <span class="math notranslate nohighlight">\(h_q\)</span> in <span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-1}]\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{Z}_q[x_0, \ldots, x_{k-1}]\)</span> respectively.</p>
<p>The coefficients of the polynomial <span class="math notranslate nohighlight">\(h_{pq}\)</span> are computed with the
Chinese Remainder Theorem. The symmetric representation in
<span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-1}]\)</span>,
<span class="math notranslate nohighlight">\(\mathbb{Z}_q[x_0, \ldots, x_{k-1}]\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{Z}_{p q}[x_0, \ldots, x_{k-1}]\)</span> is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hp</strong> (<em>PolyElement</em>) – multivariate integer polynomial with coefficients in <span class="math notranslate nohighlight">\(\mathbb{Z}_p\)</span></p></li>
<li><p><strong>hq</strong> (<em>PolyElement</em>) – multivariate integer polynomial with coefficients in <span class="math notranslate nohighlight">\(\mathbb{Z}_q\)</span></p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – modulus of <span class="math notranslate nohighlight">\(h_p\)</span>, relatively prime to <span class="math notranslate nohighlight">\(q\)</span></p></li>
<li><p><strong>q</strong> (<em>Integer</em>) – modulus of <span class="math notranslate nohighlight">\(h_q\)</span>, relatively prime to <span class="math notranslate nohighlight">\(p\)</span></p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hp</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hq</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span>
<span class="go">4*x**3*y + 5*x**2 + 3*x*y**2 + 2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">hp</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">hq</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hp</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span>
<span class="go">3*x**4 + 5*y**3*z + z</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">hp</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hpq</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">hq</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._euclidean_algorithm">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_euclidean_algorithm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L619-L674"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._euclidean_algorithm" title="Permalink to this definition"></a></dt>
<dd><p>Compute the monic GCD of two univariate polynomials in
<span class="math notranslate nohighlight">\(\mathbb{Z}_p[z]/(\check m_{\alpha}(z))[x]\)</span> with the Euclidean
Algorithm.</p>
<p>In general, <span class="math notranslate nohighlight">\(\check m_{\alpha}(z)\)</span> is not irreducible, so it is possible
that some leading coefficient is not invertible modulo
<span class="math notranslate nohighlight">\(\check m_{\alpha}(z)\)</span>. In that case <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f, g</strong> (<em>PolyElement</em>) – polynomials in <span class="math notranslate nohighlight">\(\mathbb Z[x, z]\)</span></p></li>
<li><p><strong>minpoly</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[z]\)</span>, not necessarily irreducible</p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number, modulus of <span class="math notranslate nohighlight">\(\mathbb Z_p\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – GCD of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> in <span class="math notranslate nohighlight">\(\mathbb Z[z, x]\)</span> or <code class="docutils literal notranslate"><span class="pre">None</span></code>, coefficients
are in <span class="math notranslate nohighlight">\(\left[ -\frac{p-1} 2, \frac{p-1} 2 \right]\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._evaluate_ground">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_evaluate_ground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L746-L758"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._evaluate_ground" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a polynomial <span class="math notranslate nohighlight">\(f\)</span> at <span class="math notranslate nohighlight">\(a\)</span> in the <span class="math notranslate nohighlight">\(i\)</span>-th variable of the ground
domain.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._func_field_modgcd_m">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_func_field_modgcd_m</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L992-L1135"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._func_field_modgcd_m" title="Permalink to this definition"></a></dt>
<dd><p>Compute the GCD of two polynomials in
<span class="math notranslate nohighlight">\(\mathbb Q(t_1, \ldots, t_k)[z]/(m_{\alpha}(z))[x]\)</span> using a modular
algorithm.</p>
<p>The algorithm computes the GCD of two polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> by
calculating the GCD in
<span class="math notranslate nohighlight">\(\mathbb Z_p(t_1, \ldots, t_k)[z] / (\check m_{\alpha}(z))[x]\)</span> for
suitable primes <span class="math notranslate nohighlight">\(p\)</span> and the primitive associate <span class="math notranslate nohighlight">\(\check m_{\alpha}(z)\)</span>
of <span class="math notranslate nohighlight">\(m_{\alpha}(z)\)</span>. Then the coefficients are reconstructed with the
Chinese Remainder Theorem and Rational Reconstruction. To compute the
GCD over <span class="math notranslate nohighlight">\(\mathbb Z_p(t_1, \ldots, t_k)[z] / (\check m_{\alpha})[x]\)</span>,
the recursive subroutine <code class="docutils literal notranslate"><span class="pre">_func_field_modgcd_p</span></code> is used. To verify the
result in <span class="math notranslate nohighlight">\(\mathbb Q(t_1, \ldots, t_k)[z] / (m_{\alpha}(z))[x]\)</span>, a
fraction free trial division is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f, g</strong> (<em>PolyElement</em>) – polynomials in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span></p></li>
<li><p><strong>minpoly</strong> (<em>PolyElement</em>) – irreducible polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][z]\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – the primitive associate in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span> of
the GCD of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x z&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minpoly</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span>
<span class="go">x + z</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x z&#39;</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minpoly</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span>
<span class="go">x + t*z</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id26">[<a class="reference internal" href="../sources.html#id54" title="Michael Monagan and Mark van Hoeij. Algorithms for Polynomial GCD Computation over Algebraic Function Fields. In ISSAC '04: Proceedings of the 2004 International Symposium on Symbolic and Algebraic Computation, 297–304. New York, NY, USA, 2004. ACM Press. doi:10.1145/1005285.1005328.">MvH04</a>]</span></p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#diofant.polys.modulargcd._func_field_modgcd_p" title="diofant.polys.modulargcd._func_field_modgcd_p"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_func_field_modgcd_p</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._func_field_modgcd_p">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_func_field_modgcd_p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L761-L928"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._func_field_modgcd_p" title="Permalink to this definition"></a></dt>
<dd><p>Compute the GCD of two polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z_p(t_1, \ldots, t_k)[z]/(\check m_\alpha(z))[x]\)</span>.</p>
<p>The algorithm reduces the problem step by step by evaluating the
polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> at <span class="math notranslate nohighlight">\(t_k = a\)</span> for suitable <span class="math notranslate nohighlight">\(a \in \mathbb Z_p\)</span>
and then calls itself recursively to compute the GCD in
<span class="math notranslate nohighlight">\(\mathbb Z_p(t_1, \ldots, t_{k-1})[z]/(\check m_\alpha(z))[x]\)</span>. If these
recursive calls are successful, the GCD over <span class="math notranslate nohighlight">\(k\)</span> variables is
interpolated, otherwise the algorithm returns <code class="docutils literal notranslate"><span class="pre">None</span></code>. After
interpolation, Rational Function Reconstruction is used to obtain the
correct coefficients. If this fails, a new evaluation point has to be
chosen, otherwise the desired polynomial is obtained by clearing
denominators. The result is verified with a fraction free trial
division.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f, g</strong> (<em>PolyElement</em>) – polynomials in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span></p></li>
<li><p><strong>minpoly</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][z]\)</span>, not necessarily
irreducible</p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number, modulus of <span class="math notranslate nohighlight">\(\mathbb Z_p\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – primitive associate in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span> of the
GCD of the polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>  or <code class="docutils literal notranslate"><span class="pre">None</span></code>, coefficients are
in <span class="math notranslate nohighlight">\(\left[ -\frac{p-1} 2, \frac{p-1} 2 \right]\)</span></p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id27">[<a class="reference internal" href="../sources.html#id54" title="Michael Monagan and Mark van Hoeij. Algorithms for Polynomial GCD Computation over Algebraic Function Fields. In ISSAC '04: Proceedings of the 2004 International Symposium on Symbolic and Algebraic Computation, 297–304. New York, NY, USA, 2004. ACM Press. doi:10.1145/1005285.1005328.">MvH04</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._gf_gcdex">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_gf_gcdex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L572-L585"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._gf_gcdex" title="Permalink to this definition"></a></dt>
<dd><p>Extended Euclidean Algorithm for two univariate polynomials over
<span class="math notranslate nohighlight">\(\mathbb Z_p\)</span>.</p>
<p>Returns polynomials <span class="math notranslate nohighlight">\(s, t\)</span> and <span class="math notranslate nohighlight">\(h\)</span>, such that <span class="math notranslate nohighlight">\(h\)</span> is the GCD of <span class="math notranslate nohighlight">\(f\)</span> and
<span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(sf + tg = h \; \mathrm{mod} \, p\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._interpolate">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evalpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hpeval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ground</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L107-L173"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._interpolate" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct a polynomial <span class="math notranslate nohighlight">\(h_p\)</span> in <span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-1}]\)</span>
from a list of evaluation points in <span class="math notranslate nohighlight">\(\mathbb{Z}_p\)</span> and a list of
polynomials in
<span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{i-1}, x_{i+1}, \ldots, x_{k-1}]\)</span>, which
are the images of <span class="math notranslate nohighlight">\(h_p\)</span> evaluated in the variable <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
<p>It is also possible to reconstruct a parameter of the ground domain,
i.e. if <span class="math notranslate nohighlight">\(h_p\)</span> is a polynomial over <span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-1}]\)</span>.
In this case, one has to set <code class="docutils literal notranslate"><span class="pre">ground=True</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>evalpoints</strong> (<em>list of Integer objects</em>) – list of evaluation points in <span class="math notranslate nohighlight">\(\mathbb{Z}_p\)</span></p></li>
<li><p><strong>hpeval</strong> (<em>list of PolyElement objects</em>) – list of polynomials in (resp. over)
<span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{i-1}, x_{i+1}, \ldots, x_{k-1}]\)</span>,
images of <span class="math notranslate nohighlight">\(h_p\)</span> evaluated in the variable <span class="math notranslate nohighlight">\(x_i\)</span></p></li>
<li><p><strong>ring</strong> (<em>PolynomialRing</em>) – <span class="math notranslate nohighlight">\(h_p\)</span> will be an element of this ring</p></li>
<li><p><strong>i</strong> (<em>Integer</em>) – index of the variable which has to be reconstructed</p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number, modulus of <span class="math notranslate nohighlight">\(h_p\)</span></p></li>
<li><p><strong>ground</strong> (<em>Boolean</em>) – indicates whether <span class="math notranslate nohighlight">\(x_i\)</span> is in the ground domain, default is
<code class="docutils literal notranslate"><span class="pre">False</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hp</strong> (<em>PolyElement</em>) – interpolated polynomial in (resp. over)
<span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-1}]\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._minpoly_from_dense">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_minpoly_from_dense</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L1247-L1258"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._minpoly_from_dense" title="Permalink to this definition"></a></dt>
<dd><p>Change representation of the minimal polynomial from <code class="docutils literal notranslate"><span class="pre">Poly</span></code> to
<code class="docutils literal notranslate"><span class="pre">PolyElement</span></code> for a given ring.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._modgcd_p">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_modgcd_p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degbound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contbound</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L176-L318"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._modgcd_p" title="Permalink to this definition"></a></dt>
<dd><p>Compute the GCD of two polynomials in <span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-1}]\)</span>.</p>
<p>The algorithm reduces the problem step by step by evaluating the
polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> at <span class="math notranslate nohighlight">\(x_{k-1} = a\)</span> for suitable
<span class="math notranslate nohighlight">\(a \in \mathbb{Z}_p\)</span> and then calls itself recursively to compute the GCD
in <span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-2}]\)</span>. If these recursive calls are
successful for enough evaluation points, the GCD in <span class="math notranslate nohighlight">\(k\)</span> variables is
interpolated, otherwise the algorithm returns <code class="docutils literal notranslate"><span class="pre">None</span></code>. Every time a GCD
or a content is computed, their degrees are compared with the bounds. If
a degree greater then the bound is encountered, then the current call
returns <code class="docutils literal notranslate"><span class="pre">None</span></code> and a new evaluation point has to be chosen. If at some
point the degree is smaller, the correspondent bound is updated and the
algorithm fails.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – multivariate polynomial with coefficients in <span class="math notranslate nohighlight">\(\mathbb{Z}_p\)</span></p></li>
<li><p><strong>g</strong> (<em>PolyElement</em>) – multivariate polynomial with coefficients in <span class="math notranslate nohighlight">\(\mathbb{Z}_p\)</span></p></li>
<li><p><strong>degbound</strong> (<em>list of Integer objects</em>) – <code class="docutils literal notranslate"><span class="pre">degbound[i]</span></code> is an upper bound for the degree of the GCD of <span class="math notranslate nohighlight">\(f\)</span>
and <span class="math notranslate nohighlight">\(g\)</span> in the variable <span class="math notranslate nohighlight">\(x_i\)</span></p></li>
<li><p><strong>contbound</strong> (<em>list of Integer objects</em>) – <code class="docutils literal notranslate"><span class="pre">contbound[i]</span></code> is an upper bound for the degree of the content of
the GCD in <span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_i][x_0, \ldots, x_{i-1}]\)</span>, <code class="docutils literal notranslate"><span class="pre">contbound[0]</span></code>
is not used can therefore be chosen arbitrarily.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – GCD of the polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id28">[<a class="reference internal" href="../sources.html#id221" title="Michael B. Monagan and Allan D. Wittkopf. On the design and implementation of brown's algorithm over the integers and number fields. In Proceedings of the 2000 International Symposium on Symbolic and Algebraic Computation, ISSAC '00, 225–233. New York, NY, USA, 2000. ACM Press. URL: https://dl.acm.org/citation.cfm?doid=345542.345639, doi:10.1145/345542.345639.">MW00</a>]</span></p></li>
<li><p><span id="id29">[<a class="reference internal" href="../sources.html#id142" title="W. S. Brown. On Euclid's Algorithm and the Computation of Polynomial Greatest Common Divisors. In SYMSAC '71: Proceedings of the second ACM Symposium on Symbolic and Algebraic Computation, 195–211. New York, NY, USA, 1971. ACM Press. doi:10.1145/800204.806288.">Bro71</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._primitive_in_x0">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_primitive_in_x0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L1261-L1278"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._primitive_in_x0" title="Permalink to this definition"></a></dt>
<dd><p>Compute the content in <span class="math notranslate nohighlight">\(x_0\)</span> and the primitive part of a polynomial <span class="math notranslate nohighlight">\(f\)</span>
in
<span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, x_1, \ldots, x_{n-1}] \cong \mathbb Q(\alpha)[x_1, \ldots, x_{n-1}][x_0]\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._rational_function_reconstruction">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_rational_function_reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L433-L499"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._rational_function_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct a rational function <span class="math notranslate nohighlight">\(\frac a b\)</span> in <span class="math notranslate nohighlight">\(\mathbb Z_p(t)\)</span> from</p>
<div class="math notranslate nohighlight">
\[c = \frac a b \; \mathrm{mod} \, m,\]</div>
<p>where <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(m\)</span> are polynomials in <span class="math notranslate nohighlight">\(\mathbb Z_p[t]\)</span> and <span class="math notranslate nohighlight">\(m\)</span> has
positive degree.</p>
<p>The algorithm is based on the Euclidean Algorithm. In general, <span class="math notranslate nohighlight">\(m\)</span> is
not irreducible, so it is possible that <span class="math notranslate nohighlight">\(b\)</span> is not invertible modulo
<span class="math notranslate nohighlight">\(m\)</span>. In that case <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<em>PolyElement</em>) – univariate polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[t]\)</span></p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number</p></li>
<li><p><strong>m</strong> (<em>PolyElement</em>) – modulus, not necessarily irreducible</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>frac</strong> (<em>FracElement</em>) – either <span class="math notranslate nohighlight">\(\frac a b\)</span> in <span class="math notranslate nohighlight">\(\mathbb Z(t)\)</span> or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id30">[<a class="reference internal" href="../sources.html#id54" title="Michael Monagan and Mark van Hoeij. Algorithms for Polynomial GCD Computation over Algebraic Function Fields. In ISSAC '04: Proceedings of the 2004 International Symposium on Symbolic and Algebraic Computation, 297–304. New York, NY, USA, 2004. ACM Press. doi:10.1145/1005285.1005328.">MvH04</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._rational_reconstruction_func_coeffs">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_rational_reconstruction_func_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L502-L569"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._rational_reconstruction_func_coeffs" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct every coefficient <span class="math notranslate nohighlight">\(c_h\)</span> of a polynomial <span class="math notranslate nohighlight">\(h\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z_p(t_k)[t_1, \ldots, t_{k-1}][x, z]\)</span> from the corresponding
coefficient <span class="math notranslate nohighlight">\(c_{h_m}\)</span> of a polynomial <span class="math notranslate nohighlight">\(h_m\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z_p[t_1, \ldots, t_k][x, z] \cong \mathbb Z_p[t_k][t_1, \ldots, t_{k-1}][x, z]\)</span>
such that</p>
<div class="math notranslate nohighlight">
\[c_{h_m} = c_h \; \mathrm{mod} \, m,\]</div>
<p>where <span class="math notranslate nohighlight">\(m \in \mathbb Z_p[t]\)</span>.</p>
<p>The reconstruction is based on the Euclidean Algorithm. In general, <span class="math notranslate nohighlight">\(m\)</span>
is not irreducible, so it is possible that this fails for some
coefficient. In that case <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hm</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span></p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number, modulus of <span class="math notranslate nohighlight">\(\mathbb Z_p\)</span></p></li>
<li><p><strong>m</strong> (<em>PolyElement</em>) – modulus, polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[t]\)</span>, not necessarily irreducible</p></li>
<li><p><strong>ring</strong> (<em>PolynomialRing</em>) – <span class="math notranslate nohighlight">\(\mathbb Z(t_k)[t_1, \ldots, t_{k-1}][x, z]\)</span>, <span class="math notranslate nohighlight">\(h\)</span> will be an
element of this ring</p></li>
<li><p><strong>k</strong> (<em>Integer</em>) – index of the parameter <span class="math notranslate nohighlight">\(t_k\)</span> which will be reconstructed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – reconstructed polynomial in
<span class="math notranslate nohighlight">\(\mathbb Z(t_k)[t_1, \ldots, t_{k-1}][x, z]\)</span> or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#diofant.polys.modulargcd._rational_function_reconstruction" title="diofant.polys.modulargcd._rational_function_reconstruction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_rational_function_reconstruction</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._rational_reconstruction_int_coeffs">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_rational_reconstruction_int_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L931-L989"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._rational_reconstruction_int_coeffs" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct every rational coefficient <span class="math notranslate nohighlight">\(c_h\)</span> of a polynomial <span class="math notranslate nohighlight">\(h\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Q[t_1, \ldots, t_k][x, z]\)</span> from the corresponding integer
coefficient <span class="math notranslate nohighlight">\(c_{h_m}\)</span> of a polynomial <span class="math notranslate nohighlight">\(h_m\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span> such that</p>
<div class="math notranslate nohighlight">
\[c_{h_m} = c_h \; \mathrm{mod} \, m,\]</div>
<p>where <span class="math notranslate nohighlight">\(m \in \mathbb Z\)</span>.</p>
<p>The reconstruction is based on the Euclidean Algorithm. In general,
<span class="math notranslate nohighlight">\(m\)</span> is not a prime number, so it is possible that this fails for some
coefficient. In that case <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hm</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span></p></li>
<li><p><strong>m</strong> (<em>Integer</em>) – modulus, not necessarily prime</p></li>
<li><p><strong>ring</strong> (<em>PolynomialRing</em>) – <span class="math notranslate nohighlight">\(\mathbb Q[t_1, \ldots, t_k][x, z]\)</span>, <span class="math notranslate nohighlight">\(h\)</span> will be an element of this
ring</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – reconstructed polynomial in <span class="math notranslate nohighlight">\(\mathbb Q[t_1, \ldots, t_k][x, z]\)</span> or
<code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../modules/ntheory.html#diofant.ntheory.modular.integer_rational_reconstruction" title="diofant.ntheory.modular.integer_rational_reconstruction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diofant.ntheory.modular.integer_rational_reconstruction</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._to_ANP_poly">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_to_ANP_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L1196-L1244"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._to_ANP_poly" title="Permalink to this definition"></a></dt>
<dd><p>Convert a polynomial
<span class="math notranslate nohighlight">\(f \in \mathbb Z[x_1, \ldots, x_{n-1}][z]/(\check m_{\alpha}(z))[x_0]\)</span>
to a polynomial in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]\)</span>,
where <span class="math notranslate nohighlight">\(\check m_{\alpha}(z) \in \mathbb Z[z]\)</span> is the primitive associate
of the minimal polynomial <span class="math notranslate nohighlight">\(m_{\alpha}(z)\)</span> of <span class="math notranslate nohighlight">\(\alpha\)</span> over
<span class="math notranslate nohighlight">\(\mathbb Q\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]\)</span></p></li>
<li><p><strong>ring</strong> (<em>PolynomialRing</em>) – <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>f_</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._to_ZZ_poly">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_to_ZZ_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L1138-L1193"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._to_ZZ_poly" title="Permalink to this definition"></a></dt>
<dd><p>Compute an associate of a polynomial
<span class="math notranslate nohighlight">\(f \in \mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z[x_1, \ldots, x_{n-1}][z] / (\check m_{\alpha}(z))[x_0]\)</span>,
where <span class="math notranslate nohighlight">\(\check m_{\alpha}(z) \in \mathbb Z[z]\)</span> is the primitive associate
of the minimal polynomial <span class="math notranslate nohighlight">\(m_{\alpha}(z)\)</span> of <span class="math notranslate nohighlight">\(\alpha\)</span> over
<span class="math notranslate nohighlight">\(\mathbb Q\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]\)</span></p></li>
<li><p><strong>ring</strong> (<em>PolynomialRing</em>) – <span class="math notranslate nohighlight">\(\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>f_</strong> (<em>PolyElement</em>) – associate of <span class="math notranslate nohighlight">\(f\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd._trunc">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">_trunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L588-L616"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd._trunc" title="Permalink to this definition"></a></dt>
<dd><p>Compute the reduced representation of a polynomial <span class="math notranslate nohighlight">\(f\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Z_p[z] / (\check m_{\alpha}(z))[x]\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[x, z]\)</span></p></li>
<li><p><strong>minpoly</strong> (<em>PolyElement</em>) – polynomial <span class="math notranslate nohighlight">\(\check m_{\alpha} \in \mathbb Z[z]\)</span>, not necessarily
irreducible</p></li>
<li><p><strong>p</strong> (<em>Integer</em>) – prime number, modulus of <span class="math notranslate nohighlight">\(\mathbb Z_p\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ftrunc</strong> (<em>PolyElement</em>) – polynomial in <span class="math notranslate nohighlight">\(\mathbb Z[x, z]\)</span>, reduced modulo
<span class="math notranslate nohighlight">\(\check m_{\alpha}(z)\)</span> and <span class="math notranslate nohighlight">\(p\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd.func_field_modgcd">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">func_field_modgcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L1281-L1391"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd.func_field_modgcd" title="Permalink to this definition"></a></dt>
<dd><p>Compute the GCD of two polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> in
<span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]\)</span> using a modular algorithm.</p>
<p>The algorithm first computes the primitive associate
<span class="math notranslate nohighlight">\(\check m_{\alpha}(z)\)</span> of the minimal polynomial <span class="math notranslate nohighlight">\(m_{\alpha}\)</span> in
<span class="math notranslate nohighlight">\(\mathbb{Z}[z]\)</span> and the primitive associates of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> in
<span class="math notranslate nohighlight">\(\mathbb{Z}[x_1, \ldots, x_{n-1}][z]/(\check m_{\alpha})[x_0]\)</span>. Then it
computes the GCD in
<span class="math notranslate nohighlight">\(\mathbb Q(x_1, \ldots, x_{n-1})[z]/(m_{\alpha}(z))[x_0]\)</span>.
This is done by calculating the GCD in
<span class="math notranslate nohighlight">\(\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]\)</span> for
suitable primes <span class="math notranslate nohighlight">\(p\)</span> and then reconstructing the coefficients with the
Chinese Remainder Theorem and Rational Reconstuction. The GCD over
<span class="math notranslate nohighlight">\(\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]\)</span> is
computed with a recursive subroutine, which evaluates the polynomials at
<span class="math notranslate nohighlight">\(x_{n-1} = a\)</span> for suitable evaluation points <span class="math notranslate nohighlight">\(a \in \mathbb Z_p\)</span> and
then calls itself recursively until the ground domain does no longer
contain any parameters. For
<span class="math notranslate nohighlight">\(\mathbb{Z}_p[z]/(\check m_{\alpha}(z))[x_0]\)</span> the Euclidean Algorithm is
used. The results of those recursive calls are then interpolated and
Rational Function Reconstruction is used to obtain the correct
coefficients. The results, both in
<span class="math notranslate nohighlight">\(\mathbb Q(x_1, \ldots, x_{n-1})[z]/(m_{\alpha}(z))[x_0]\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]\)</span>, are
verified by a fraction free trial division.</p>
<p>Apart from the above GCD computation some GCDs in
<span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_1, \ldots, x_{n-1}]\)</span> have to be calculated,
because treating the polynomials as univariate ones can result in
a spurious content of the GCD. For this <code class="docutils literal notranslate"><span class="pre">func_field_modgcd</span></code> is
called recursively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f, g</strong> (<em>PolyElement</em>) – polynomials in <span class="math notranslate nohighlight">\(\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]\)</span></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – monic GCD of the polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">algebraic_field</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func_field_modgcd</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">x + sqrt(2)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func_field_modgcd</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="go">x + sqrt(2)*y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func_field_modgcd</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id31">[<a class="reference internal" href="../sources.html#id54" title="Michael Monagan and Mark van Hoeij. Algorithms for Polynomial GCD Computation over Algebraic Function Fields. In ISSAC '04: Proceedings of the 2004 International Symposium on Symbolic and Algebraic Computation, 297–304. New York, NY, USA, 2004. ACM Press. doi:10.1145/1005285.1005328.">MvH04</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd.modgcd">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">modgcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L321-L430"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd.modgcd" title="Permalink to this definition"></a></dt>
<dd><p>Compute the GCD of two polynomials in <span class="math notranslate nohighlight">\(\mathbb{Z}[x_0, \ldots, x_{k-1}]\)</span>
using a modular algorithm.</p>
<p>The algorithm computes the GCD of two multivariate integer polynomials
<span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> by calculating the GCD in
<span class="math notranslate nohighlight">\(\mathbb{Z}_p[x_0, \ldots, x_{k-1}]\)</span> for suitable primes <span class="math notranslate nohighlight">\(p\)</span> and then
reconstructing the coefficients with the Chinese Remainder Theorem. To
compute the multivariate GCD over <span class="math notranslate nohighlight">\(\mathbb{Z}_p\)</span> the recursive
subroutine <code class="docutils literal notranslate"><span class="pre">_modgcd_p</span></code> is used. To verify the result in
<span class="math notranslate nohighlight">\(\mathbb{Z}[x_0, \ldots, x_{k-1}]\)</span>, trial division is done, but only for
candidates which are very likely the desired GCD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>PolyElement</em>) – multivariate integer polynomial</p></li>
<li><p><strong>g</strong> (<em>PolyElement</em>) – multivariate integer polynomial</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> (<em>PolyElement</em>) – GCD of the polynomials <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">modgcd</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">modgcd</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="go">z</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id32">[<a class="reference internal" href="../sources.html#id221" title="Michael B. Monagan and Allan D. Wittkopf. On the design and implementation of brown's algorithm over the integers and number fields. In Proceedings of the 2000 International Symposium on Symbolic and Algebraic Computation, ISSAC '00, 225–233. New York, NY, USA, 2000. ACM Press. URL: https://dl.acm.org/citation.cfm?doid=345542.345639, doi:10.1145/345542.345639.">MW00</a>]</span></p></li>
<li><p><span id="id33">[<a class="reference internal" href="../sources.html#id142" title="W. S. Brown. On Euclid's Algorithm and the Computation of Polynomial Greatest Common Divisors. In SYMSAC '71: Proceedings of the second ACM Symposium on Symbolic and Algebraic Computation, 195–211. New York, NY, USA, 1971. ACM Press. doi:10.1145/800204.806288.">Bro71</a>]</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="diofant.polys.modulargcd.trial_division">
<span class="sig-prename descclassname"><span class="pre">diofant.polys.modulargcd.</span></span><span class="sig-name descname"><span class="pre">trial_division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/modulargcd.py#L677-L743"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.modulargcd.trial_division" title="Permalink to this definition"></a></dt>
<dd><p>Check if <span class="math notranslate nohighlight">\(h\)</span> divides <span class="math notranslate nohighlight">\(f\)</span> in
<span class="math notranslate nohighlight">\(\mathbb K[t_1, \ldots, t_k][z]/(m_{\alpha}(z))\)</span>, where <span class="math notranslate nohighlight">\(\mathbb K\)</span> is
either <span class="math notranslate nohighlight">\(\mathbb Q\)</span> or <span class="math notranslate nohighlight">\(\mathbb Z_p\)</span>.</p>
<p>This algorithm is based on pseudo division and does not use any
fractions. By default <span class="math notranslate nohighlight">\(\mathbb K\)</span> is <span class="math notranslate nohighlight">\(\mathbb Q\)</span>, if a prime number <span class="math notranslate nohighlight">\(p\)</span>
is given, <span class="math notranslate nohighlight">\(\mathbb Z_p\)</span> is chosen instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f, h</strong> (<em>PolyElement</em>) – polynomials in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][x, z]\)</span></p></li>
<li><p><strong>minpoly</strong> (<em>PolyElement</em>) – polynomial <span class="math notranslate nohighlight">\(m_{\alpha}(z)\)</span> in <span class="math notranslate nohighlight">\(\mathbb Z[t_1, \ldots, t_k][z]\)</span></p></li>
<li><p><strong>p</strong> (<em>Integer or None</em>) – if <span class="math notranslate nohighlight">\(p\)</span> is given, <span class="math notranslate nohighlight">\(\mathbb K\)</span> is set to <span class="math notranslate nohighlight">\(\mathbb Z_p\)</span> instead of
<span class="math notranslate nohighlight">\(\mathbb Q\)</span>, default is <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rem</strong> (<em>PolyElement</em>) – remainder of <span class="math notranslate nohighlight">\(\frac f h\)</span></p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id34">[<a class="reference internal" href="../sources.html#id68" title="Mark van Hoeij and Michael Monagan. A Modular GCD Algorithm over Number Fields Presented with Multiple Extensions. In ISSAC '02: Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation, 109–116. New York, NY, USA, 2002. ACM Press. doi:10.1145/780506.780520.">vHM02</a>]</span></p></li>
</ul>
</dd></dl>

</section>
<section id="heuristic-gcd">
<h2>Heuristic GCD<a class="headerlink" href="#heuristic-gcd" title="Permalink to this headline"></a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.euclidtools._GCD._zz_heu_gcd">
<span class="sig-prename descclassname"><span class="pre">_GCD.</span></span><span class="sig-name descname"><span class="pre">_zz_heu_gcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/euclidtools.py#L165-L243"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.euclidtools._GCD._zz_heu_gcd" title="Permalink to this definition"></a></dt>
<dd><p>Heuristic polynomial GCD in <code class="docutils literal notranslate"><span class="pre">Z[X]</span></code>.</p>
<p>Given univariate polynomials <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> in <code class="docutils literal notranslate"><span class="pre">Z[X]</span></code>, returns
their GCD, i.e. polynomial <code class="docutils literal notranslate"><span class="pre">h</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p>The algorithm is purely heuristic which means it may fail to compute
the GCD. This will be signaled by raising an exception. In this case
you will need to switch to another GCD method.</p>
<p>The algorithm computes the polynomial GCD by evaluating polynomials
<code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> at certain points and computing (fast) integer GCD
of those evaluations. The polynomial GCD is recovered from the integer
image by interpolation. The evaluation proces reduces f and g variable
by variable into a large integer. The final step is to verify if the
interpolated polynomial is the correct GCD.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><span id="id35">[<a class="reference internal" href="../sources.html#id24" title="Hsin–Chao Liao and Richard J. Fateman. Evaluation of the heuristic polynomial GCD. In ISSAC '95: Proceedings of the 1995 International Symposium on Symbolic and Algebraic Computation, 240–247. New York, NY, USA, 1995. ACM Press. doi:10.1145/220346.220376.">LF95</a>]</span></p></li>
</ul>
</dd></dl>

</section>
<section id="module-diofant.polys.rootisolation">
<span id="further-tools"></span><h2>Further tools<a class="headerlink" href="#module-diofant.polys.rootisolation" title="Permalink to this headline"></a></h2>
<p>Real and complex root isolation and refinement algorithms.</p>
<dl class="py class">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.rootisolation.</span></span><span class="sig-name descname"><span class="pre">ComplexInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L876-L1018"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval" title="Permalink to this definition"></a></dt>
<dd><p>A fully qualified representation of a complex isolation interval.
The printed form is shown as (x1, y1) x (x2, y2): the southwest x northeast
coordinates of the interval’s rectangle.</p>
<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L925-L927"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.as_tuple" title="Permalink to this definition"></a></dt>
<dd><p>Return tuple representation of complex isolating interval.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.ax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ax</span></span><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.ax" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">x</span></code> coordinate of south-western corner.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.ay">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ay</span></span><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.ay" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinate of south-western corner.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.bx">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bx</span></span><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.bx" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">x</span></code> coordinate of north-eastern corner.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.by">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">by</span></span><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.by" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinate of north-eastern corner.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.center">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.center" title="Permalink to this definition"></a></dt>
<dd><p>Return the center of the complex isolating interval.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.conjugate">
<span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L929-L933"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.conjugate" title="Permalink to this definition"></a></dt>
<dd><p>Return conjugated isolating interval.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.is_disjoint">
<span class="sig-name descname"><span class="pre">is_disjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_re_refinement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">re_disjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L935-L992"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.is_disjoint" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if two isolation intervals are disjoint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>check_re_refinement</strong> (<em>bool, optional</em>) – If enabled, test that either real projections of isolation
intervals are disjoint or roots share common real part.</p></li>
<li><p><strong>re_disjoint</strong> (<em>bool, optional</em>) – If enabled, return <code class="docutils literal notranslate"><span class="pre">True</span></code> only if real projections of isolation
intervals are disjoint.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.ComplexInterval.refine">
<span class="sig-name descname"><span class="pre">refine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L994-L1018"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.ComplexInterval.refine" title="Permalink to this definition"></a></dt>
<dd><p>Perform one step of complex root refinement algorithm.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.RealInterval">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.rootisolation.</span></span><span class="sig-name descname"><span class="pre">RealInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L794-L873"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.RealInterval" title="Permalink to this definition"></a></dt>
<dd><p>A fully qualified representation of a real isolation interval.</p>
<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.RealInterval.a">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">a</span></span><a class="headerlink" href="#diofant.polys.rootisolation.RealInterval.a" title="Permalink to this definition"></a></dt>
<dd><p>Return the position of the left end.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.RealInterval.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L856-L858"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.RealInterval.as_tuple" title="Permalink to this definition"></a></dt>
<dd><p>Return tuple representation of real isolating interval.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.RealInterval.b">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">b</span></span><a class="headerlink" href="#diofant.polys.rootisolation.RealInterval.b" title="Permalink to this definition"></a></dt>
<dd><p>Return the position of the right end.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.RealInterval.center">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#diofant.polys.rootisolation.RealInterval.center" title="Permalink to this definition"></a></dt>
<dd><p>Return the center of the real isolating interval.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.RealInterval.is_disjoint">
<span class="sig-name descname"><span class="pre">is_disjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L860-L862"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.RealInterval.is_disjoint" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if two isolation intervals are disjoint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.rootisolation.RealInterval.refine">
<span class="sig-name descname"><span class="pre">refine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/rootisolation.py#L864-L873"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.rootisolation.RealInterval.refine" title="Permalink to this definition"></a></dt>
<dd><p>Perform one step of real root refinement algorithm.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-diofant.polys.sqfreetools"></span><p>Square-free decomposition algorithms and related tools.</p>
</section>
<section id="undocumented">
<h2>Undocumented<a class="headerlink" href="#undocumented" title="Permalink to this headline"></a></h2>
<p>Many parts of the polys module are still undocumented, and even where there is
documentation it is scarce. Please contribute!</p>
<span class="target" id="module-diofant.polys.polyoptions"></span><p>Options manager for <a class="reference internal" href="../modules/polys.html#diofant.polys.polytools.Poly" title="diofant.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> and public API functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="diofant.polys.polyoptions.Options">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyoptions.</span></span><span class="sig-name descname"><span class="pre">Options</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyoptions.py#L78-L244"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyoptions.Options" title="Permalink to this definition"></a></dt>
<dd><p>Options manager for polynomial manipulation module.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Options</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="s1">&#39;ZZ&#39;</span><span class="p">})</span>
<span class="go">{&#39;auto&#39;: False, &#39;domain&#39;: ZZ, &#39;gens&#39;: (x, y, z)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">build_options</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="s1">&#39;ZZ&#39;</span><span class="p">})</span>
<span class="go">{&#39;auto&#39;: False, &#39;domain&#39;: ZZ, &#39;gens&#39;: (x, y, z)}</span>
</pre></div>
</div>
<p><strong>Options</strong></p>
<ul class="simple">
<li><p>Expand — boolean option</p></li>
<li><p>Gens — option</p></li>
<li><p>Wrt — option</p></li>
<li><p>Sort — option</p></li>
<li><p>Order — option</p></li>
<li><p>Field — boolean option</p></li>
<li><p>Greedy — boolean option</p></li>
<li><p>Domain — option</p></li>
<li><p>Split — boolean option</p></li>
<li><p>Gaussian — boolean option</p></li>
<li><p>Extension — option</p></li>
<li><p>Modulus — option</p></li>
<li><p>Symmetric — boolean option</p></li>
<li><p>Strict — boolean option</p></li>
</ul>
<p><strong>Flags</strong></p>
<ul class="simple">
<li><p>Auto — boolean flag</p></li>
<li><p>Frac — boolean flag</p></li>
<li><p>Formal — boolean flag</p></li>
<li><p>Polys — boolean flag</p></li>
<li><p>Include — boolean flag</p></li>
<li><p>All — boolean flag</p></li>
<li><p>Gen — flag</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.polyoptions.Options.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyoptions.py#L197-L207"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyoptions.Options.clone" title="Permalink to this definition"></a></dt>
<dd><p>Clone <code class="docutils literal notranslate"><span class="pre">self</span></code> and update specified options.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diofant.polys.polyoptions.Order">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyoptions.</span></span><span class="sig-name descname"><span class="pre">Order</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyoptions.py#L324-L337"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyoptions.Order" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">order</span></code> option to polynomial manipulation functions.</p>
</dd></dl>

<span class="target" id="module-diofant.polys.polyerrors"></span><p>Definitions of common exceptions for <a class="reference internal" href="../modules/polys.html#module-diofant.polys" title="diofant.polys"><code class="xref py py-mod docutils literal notranslate"><span class="pre">polys</span></code></a> module.</p>
<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.BasePolynomialError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">BasePolynomialError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L4-L5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.BasePolynomialError" title="Permalink to this definition"></a></dt>
<dd><p>Base class for polynomial related exceptions.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.CoercionFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">CoercionFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L102-L103"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.CoercionFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a coercion is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.ComputationFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">ComputationFailed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nargs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L138-L149"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.ComputationFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when polynomial computation failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.DomainError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">DomainError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L118-L119"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.DomainError" title="Permalink to this definition"></a></dt>
<dd><p>Generic domain error.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.EvaluationFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">EvaluationFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L94-L95"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.EvaluationFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a polynomial evaluation is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.ExactQuotientFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">ExactQuotientFailed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L8-L24"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.ExactQuotientFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when exact quotient is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.ExtraneousFactors">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">ExtraneousFactors</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L90-L91"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.ExtraneousFactors" title="Permalink to this definition"></a></dt>
<dd><p>Raised when there are extraneous factors.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.FlagError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">FlagError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L189-L190"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.FlagError" title="Permalink to this definition"></a></dt>
<dd><p>Generic flag error.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.GeneratorsError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">GeneratorsError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L130-L131"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.GeneratorsError" title="Permalink to this definition"></a></dt>
<dd><p>Raised when polynomial generators are unsuitable.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.GeneratorsNeeded">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">GeneratorsNeeded</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L134-L135"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.GeneratorsNeeded" title="Permalink to this definition"></a></dt>
<dd><p>Raised when more generators needed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.HeuristicGCDFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">HeuristicGCDFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L70-L71"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.HeuristicGCDFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a heuristic GCD is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.HomomorphismFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">HomomorphismFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L82-L83"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.HomomorphismFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a homomorphism is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.IsomorphismFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">IsomorphismFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L86-L87"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.IsomorphismFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when an isomprphism is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.ModularGCDFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">ModularGCDFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L74-L75"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.ModularGCDFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a modular GCD is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.MultivariatePolynomialError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">MultivariatePolynomialError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L156-L157"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.MultivariatePolynomialError" title="Permalink to this definition"></a></dt>
<dd><p>Generic multivariate polynomial error.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.NotAlgebraic">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">NotAlgebraic</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L114-L115"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.NotAlgebraic" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a non algebraic element occurred.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.NotInvertible">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">NotInvertible</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L106-L107"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.NotInvertible" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a element is not invertible.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.NotReversible">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">NotReversible</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L110-L111"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.NotReversible" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a element is not reversible.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.OperationNotSupported">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">OperationNotSupported</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L57-L67"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.OperationNotSupported" title="Permalink to this definition"></a></dt>
<dd><p>Raised when an operation is not supported.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.OptionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">OptionError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L185-L186"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.OptionError" title="Permalink to this definition"></a></dt>
<dd><p>Generic option error.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.PolificationFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">PolificationFailed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exprs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L160-L182"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.PolificationFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised if polunomial construction is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.PolynomialDivisionFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">PolynomialDivisionFailed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L27-L54"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.PolynomialDivisionFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when polynomial division is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.PolynomialError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">PolynomialError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L122-L123"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.PolynomialError" title="Permalink to this definition"></a></dt>
<dd><p>Generic polynomial error.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.RefinementFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">RefinementFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L98-L99"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.RefinementFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when a root refinement is failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.UnificationFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">UnificationFailed</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L126-L127"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.UnificationFailed" title="Permalink to this definition"></a></dt>
<dd><p>Raised when domains unification failed.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.UnivariatePolynomialError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">UnivariatePolynomialError</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L152-L153"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.UnivariatePolynomialError" title="Permalink to this definition"></a></dt>
<dd><p>Generic univariate polynomial error.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="diofant.polys.polyerrors.UnluckyLeadingCoefficient">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.polyerrors.</span></span><span class="sig-name descname"><span class="pre">UnluckyLeadingCoefficient</span></span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/polyerrors.py#L78-L79"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.polyerrors.UnluckyLeadingCoefficient" title="Permalink to this definition"></a></dt>
<dd><p>Raised when there are unlucky LC.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diofant.polys.fields.FracElement">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diofant.polys.fields.</span></span><span class="sig-name descname"><span class="pre">FracElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/fields.py#L203-L542"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.fields.FracElement" title="Permalink to this definition"></a></dt>
<dd><p>Element of multivariate distributed rational function field.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../modules/domains.html#diofant.polys.fields.FractionField" title="diofant.polys.fields.FractionField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FractionField</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.fields.FracElement.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/fields.py#L525-L542"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.fields.FracElement.compose" title="Permalink to this definition"></a></dt>
<dd><p>Computes the functional composition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diofant.polys.fields.FracElement.diff">
<span class="sig-name descname"><span class="pre">diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/diofant/diofant/blob/master/diofant/polys/fields.py#L488-L501"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diofant.polys.fields.FracElement.diff" title="Permalink to this definition"></a></dt>
<dd><p>Computes partial derivative in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*x/(z + 1)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Internals" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="gruntz.html" class="btn btn-neutral float-right" title="The Gruntz Algorithm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2006-2022 SymPy Development Team, 2013-2022 Sergey B Kirpichev.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-147167689-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-147167689-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>