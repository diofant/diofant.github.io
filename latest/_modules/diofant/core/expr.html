

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diofant.core.expr &mdash; Diofant 0.10.0a5.dev9+ge97a258 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Diofant
          

          
          </a>

          
            
            
              <div class="version">
                0.10.0a5.dev9+ge97a258
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../internals/index.html">Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../literature.html">Literature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../aboutus.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Diofant</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>diofant.core.expr</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diofant.core.expr</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="kn">from</span> <span class="nn">mpmath.libmp</span> <span class="k">import</span> <span class="n">mpf_log</span><span class="p">,</span> <span class="n">prec_to_dps</span>

<span class="kn">from</span> <span class="nn">.assumptions</span> <span class="k">import</span> <span class="n">ManagedProperties</span>
<span class="kn">from</span> <span class="nn">.basic</span> <span class="k">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Basic</span>
<span class="kn">from</span> <span class="nn">.cache</span> <span class="k">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">.compatibility</span> <span class="k">import</span> <span class="n">as_int</span><span class="p">,</span> <span class="n">default_sort_key</span>
<span class="kn">from</span> <span class="nn">.decorators</span> <span class="k">import</span> <span class="n">_sympifyit</span><span class="p">,</span> <span class="n">call_highest_priority</span>
<span class="kn">from</span> <span class="nn">.evalf</span> <span class="k">import</span> <span class="n">EvalfMixin</span><span class="p">,</span> <span class="n">pure_complex</span>
<span class="kn">from</span> <span class="nn">.singleton</span> <span class="k">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">.sympify</span> <span class="k">import</span> <span class="n">sympify</span>


<div class="viewcode-block" id="Expr"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr">[docs]</a><span class="k">class</span> <span class="nc">Expr</span><span class="p">(</span><span class="n">Basic</span><span class="p">,</span> <span class="n">EvalfMixin</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ManagedProperties</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for algebraic expressions.</span>

<span class="sd">    Everything that requires arithmetic operations to be defined</span>
<span class="sd">    should subclass this class, instead of Basic (which should be</span>
<span class="sd">    used only for argument storage and expression manipulation, i.e.</span>
<span class="sd">    pattern matching, substitutions, etc).</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    diofant.core.basic.Basic</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_assumptions</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">default_assumptions</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_diff_wrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is it allowed to take derivative wrt to this instance.</span>

<span class="sd">        This determines if it is allowed to take derivatives wrt this object.</span>
<span class="sd">        Subclasses such as Symbol, Function and Derivative should return True</span>
<span class="sd">        to enable derivatives wrt them. The implementation in Derivative</span>
<span class="sd">        separates the Symbol and non-Symbol _diff_wrt=True variables and</span>
<span class="sd">        temporarily converts the non-Symbol vars in Symbols when performing</span>
<span class="sd">        the differentiation.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The expr.subs({yourclass: Symbol}) should be well-defined on a</span>
<span class="sd">        structural level, or this will lead to inconsistent results.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; e = Expr()</span>
<span class="sd">        &gt;&gt;&gt; e._diff_wrt</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; class MyClass(Expr):</span>
<span class="sd">        ...     _diff_wrt = True</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; (2*MyClass()).diff(MyClass())</span>
<span class="sd">        2</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.core.function.Derivative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Expr.sort_key"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.sort_key">[docs]</a>    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a sort key. &quot;&quot;&quot;</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Dummy</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_ordered_factors</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>

            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">default_sort_key</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="n">args</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">coeff</span></div>

    <span class="c1"># ***************</span>
    <span class="c1"># * Arithmetics *</span>
    <span class="c1"># ***************</span>
    <span class="c1"># Expr and its sublcasses use _op_priority to determine which object</span>
    <span class="c1"># passed to a binary special method (__mul__, etc.) will handle the</span>
    <span class="c1"># operation. In general, the &#39;call_highest_priority&#39; decorator will choose</span>
    <span class="c1"># the object with the highest _op_priority to handle the call.</span>
    <span class="c1"># Custom subclasses that want to define their own binary special methods</span>
    <span class="c1"># should set an _op_priority value that is higher than the default.</span>
    <span class="c1">#</span>
    <span class="c1"># **NOTE**:</span>
    <span class="c1"># This is a temporary fix, and will eventually be replaced with</span>
    <span class="c1"># something better and more powerful.  See issue sympy/sympy#5510.</span>
    <span class="n">_op_priority</span> <span class="o">=</span> <span class="mf">10.0</span>

    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">Abs</span>
        <span class="k">return</span> <span class="n">Abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__radd__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rsub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rmul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rpow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rtruediv__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rmod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__mod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert complex to int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert </span><span class="si">%s</span><span class="s2"> to int&quot;</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__floor__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">floor</span>
        <span class="k">return</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Don&#39;t bother testing if it&#39;s a number; if it&#39;s not this is going</span>
        <span class="c1"># to fail, and if it is we still need to check that it evalf&#39;ed to</span>
        <span class="c1"># a number.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert complex to float&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert expression to float&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.relational</span> <span class="k">import</span> <span class="n">GreaterThan</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GreaterThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.relational</span> <span class="k">import</span> <span class="n">LessThan</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LessThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.relational</span> <span class="k">import</span> <span class="n">StrictGreaterThan</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StrictGreaterThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.relational</span> <span class="k">import</span> <span class="n">StrictLessThan</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StrictLessThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_mpmath</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">Float</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_mpf_&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_mpc_&quot;</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_mpc_</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span><span class="o">*</span><span class="n">I</span>
            <span class="k">return</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected mpmath number (mpf or mpc)&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if &#39;self&#39; has no free symbols.</span>

<span class="sd">        It will be faster than ``if not self.free_symbols``, however, since</span>
<span class="sd">        ``is_number`` will fail as soon as it hits a free symbol.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; x.is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2*x).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2 + log(2)).is_number</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (2 + Integral(2, x)).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2 + Integral(2, (x, 1, 2))).is_number</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">re_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">im_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">re_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">im_max</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self evaluated, if possible, replacing free symbols with</span>
<span class="sd">        random complex values, if necessary.</span>

<span class="sd">        The random complex value for each free symbol is generated</span>
<span class="sd">        by the random_complex_number routine giving real and imaginary</span>
<span class="sd">        parts in the range given by the re_min, re_max, im_min, and im_max</span>
<span class="sd">        values. The returned value is evaluated to a precision of n</span>
<span class="sd">        (if given) else the maximum of 15 and the precision needed</span>
<span class="sd">        to get more than 1 digit of precision. If the expression</span>
<span class="sd">        could not be evaluated to a number, or could not be evaluated</span>
<span class="sd">        to more than 1 digit of precision, then None is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; x._random()                         # doctest: +SKIP</span>
<span class="sd">        0.0392918155679172 + 0.916050214307199*I</span>
<span class="sd">        &gt;&gt;&gt; x._random(2)                        # doctest: +SKIP</span>
<span class="sd">        -0.77 - 0.87*I</span>
<span class="sd">        &gt;&gt;&gt; (x + y/2)._random(2)                # doctest: +SKIP</span>
<span class="sd">        -0.57 + 0.16*I</span>
<span class="sd">        &gt;&gt;&gt; sqrt(2)._random(2)</span>
<span class="sd">        1.4</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.utilities.randtest.random_complex_number</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">free</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">..utilities.randtest</span> <span class="k">import</span> <span class="n">random_complex_number</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">re_min</span><span class="p">,</span> <span class="n">re_max</span><span class="p">,</span> <span class="n">im_min</span><span class="p">,</span> <span class="n">im_max</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="n">random_complex_number</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">zi</span> <span class="ow">in</span> <span class="n">free</span><span class="p">]))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="c1"># if an out of range value resulted in evalf problems</span>
                <span class="c1"># then return None -- XXX is there a way to know how to</span>
                <span class="c1"># select a good random number for a given expression?</span>
                <span class="c1"># e.g. when calculating n! negative values for n should not</span>
                <span class="c1"># be used</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">nmag</span><span class="p">,</span> <span class="s1">&#39;_prec&#39;</span><span class="p">):</span>
            <span class="c1"># e.g. exp_polar(2*I*pi) doesn&#39;t evaluate but is_number is True</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">nmag</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">)</span>

<div class="viewcode-block" id="Expr.is_constant"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.is_constant">[docs]</a>    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">wrt</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self is constant, False if not, or None if</span>
<span class="sd">        the constancy could not be determined conclusively.</span>

<span class="sd">        If an expression has no free symbols then it is a constant. If</span>
<span class="sd">        there are free symbols it is possible that the expression is a</span>
<span class="sd">        constant, perhaps (but not necessarily) zero. To test such</span>
<span class="sd">        expressions, two strategies are tried:</span>

<span class="sd">        1) numerical evaluation at two random points. If two such evaluations</span>
<span class="sd">        give two different values and the values have a precision greater than</span>
<span class="sd">        1 then self is not constant. If the evaluations agree or could not be</span>
<span class="sd">        obtained with any precision, no decision is made. The numerical testing</span>
<span class="sd">        is done only if ``wrt`` is different than the free symbols.</span>

<span class="sd">        2) differentiation with respect to variables in &#39;wrt&#39; (or all free</span>
<span class="sd">        symbols if omitted) to see if the expression is constant or not. This</span>
<span class="sd">        will not always lead to an expression that is zero even though an</span>
<span class="sd">        expression is constant (see added test in test_expr.py). If</span>
<span class="sd">        all derivatives are zero then self is constant with respect to the</span>
<span class="sd">        given symbols.</span>

<span class="sd">        If neither evaluation nor differentiation can prove the expression is</span>
<span class="sd">        constant, None is returned unless two numerical values happened to be</span>
<span class="sd">        the same and the flag ``failing_number`` is True -- in that case the</span>
<span class="sd">        numerical value will be returned.</span>

<span class="sd">        If flag simplify=False is passed, self will not be simplified;</span>
<span class="sd">        the default is True since self should be simplified before testing.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; x.is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Integer(2).is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, 10)).is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(n)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; eq = a*cos(x)**2 + a*sin(x)**2 - a</span>
<span class="sd">        &gt;&gt;&gt; eq.is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (0**x).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x.is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (x**x).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; one = cos(x)**2 + sin(x)**2</span>
<span class="sd">        &gt;&gt;&gt; one.is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Except for expressions that contain units, only one of these should</span>
        <span class="c1"># be necessary since if something is</span>
        <span class="c1"># known to be a number it should also know that there are no</span>
        <span class="c1"># free symbols. But is_number quits as soon as it hits a non-number</span>
        <span class="c1"># whereas free_symbols goes until all free symbols have been collected,</span>
        <span class="c1"># thus is_number should be faster. But a double check on free symbols</span>
        <span class="c1"># is made just in case there is a discrepancy between the two.</span>
        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">free</span><span class="p">:</span>
            <span class="c1"># if the following assertion fails then that object&#39;s free_symbols</span>
            <span class="c1"># method needs attention: if an expression is a number it cannot</span>
            <span class="c1"># have free symbols</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">free</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># if we are only interested in some symbols and they are not in the</span>
        <span class="c1"># free symbols then this expression is constant wrt those symbols</span>
        <span class="n">wrt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wrt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrt</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wrt</span> <span class="o">&amp;</span> <span class="n">free</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">wrt</span> <span class="o">=</span> <span class="n">wrt</span> <span class="ow">or</span> <span class="n">free</span>

        <span class="c1"># simplify unless this has already been done</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="c1"># is_zero should be a quick assumptions check; it can be wrong for</span>
        <span class="c1"># numbers (see test_is_not_constant test), giving False when it</span>
        <span class="c1"># shouldn&#39;t, but hopefully it will never give True unless it is sure.</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># try numerical evaluation to see if we get two different values</span>
        <span class="n">failing_number</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">wrt</span> <span class="o">==</span> <span class="n">free</span><span class="p">:</span>
            <span class="c1"># try 0 (for a) and 1 (for b)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">))),</span>
                              <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
                    <span class="c1"># evaluation may succeed when substitution fails</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
                        <span class="c1"># try random real</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nan</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">))),</span>
                                  <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
                        <span class="c1"># evaluation may succeed when substitution fails</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nan</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># try random real</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nan</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">failing_number</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_number</span> <span class="k">else</span> <span class="n">b</span>

        <span class="c1"># now we will test each wrt symbol (or all free symbols) to see if the</span>
        <span class="c1"># expression depends on them or not using differentiation. This is</span>
        <span class="c1"># not sufficient for all expressions, however, so we don&#39;t return</span>
        <span class="c1"># False if we get a derivative other than 0 with free symbols.</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wrt</span><span class="p">:</span>
            <span class="n">deriv</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">deriv</span> <span class="o">=</span> <span class="n">deriv</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">deriv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">deriv</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">deriv</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;failing_number&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">failing_number</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">deriv</span><span class="o">.</span><span class="n">free_symbols</span>
                        <span class="k">return</span>  <span class="c1"># dead line provided _random returns None in such cases</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Expr.equals"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.equals">[docs]</a>    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">failing_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self == other, False if it doesn&#39;t, or None. If</span>
<span class="sd">        failing_expression is True then the expression which did not simplify</span>
<span class="sd">        to a 0 will be returned instead of None.</span>

<span class="sd">        If ``self`` is a Number (or complex number) that is not zero, then</span>
<span class="sd">        the result is False.</span>

<span class="sd">        If ``self`` is a number and has not evaluated to zero, evalf will be</span>
<span class="sd">        used to test whether the expression evaluates to zero. If it does so</span>
<span class="sd">        and the result has significance (i.e. the precision is either -1, for</span>
<span class="sd">        a Rational result, or is greater than 1) then the evalf value will be</span>
<span class="sd">        used to return True or False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># they aren&#39;t the same so see if we can make the difference 0;</span>
        <span class="c1"># don&#39;t worry about doing simplification steps one at a time</span>
        <span class="c1"># because if the expression ever goes to 0 then the subsequent</span>
        <span class="c1"># simplification steps that are done will be very fast.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">((</span><span class="bp">self</span> <span class="o">-</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="n">radical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">diff</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">diff</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">Mod</span><span class="p">):</span>
            <span class="c1"># if there is no expanding to be done after simplifying</span>
            <span class="c1"># then this can&#39;t be a zero</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">constant</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">failing_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># e.g. unless the right simplification is done, a symbolic</span>
            <span class="c1"># zero is possible (see expression of issue sympy/sympy#6829: without</span>
            <span class="c1"># simplification constant will be None).</span>
            <span class="k">return</span>

        <span class="n">ndiff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">_random</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ndiff</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">failing_expression</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">diff</span></div>

    <span class="k">def</span> <span class="nf">_eval_is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..polys.numberfields</span> <span class="k">import</span> <span class="n">minimal_polynomial</span>
        <span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">count_ops</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Dummy</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># check to see that we can get a value</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">nan</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">is_algebraic</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Function</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">75</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">minimal_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">Dummy</span><span class="p">())</span><span class="o">.</span><span class="n">is_Symbol</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_eval_is_positive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># check to see that we can get a value</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">nan</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="ow">not</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_is_negative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># check to see that we can get a value</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">nan</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="ow">not</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns evaluation over an interval.</span>

<span class="sd">        For most functions this is: self.subs({x: b}) - self.subs({x: a}),</span>
<span class="sd">        possibly using limit() if NaN is returned from subs.</span>

<span class="sd">        If b or a is None, it only evaluates -self.subs({x: a}) or self.subs({b: x}),</span>
<span class="sd">        respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..series</span> <span class="k">import</span> <span class="n">limit</span><span class="p">,</span> <span class="n">Limit</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Both interval ends cannot be None.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">zoo</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Limit</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Could not compute limit&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">b</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">zoo</span><span class="p">):</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Limit</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Could not compute limit&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">_eval_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># subclass to compute self**other for cases when</span>
        <span class="c1"># other is not NaN, 0, or 1</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_eval_conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_imaginary</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span>

<div class="viewcode-block" id="Expr.conjugate"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.conjugate">[docs]</a>    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the complex conjugate of self.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.functions.elementary.complexes.conjugate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..functions.elementary.complexes</span> <span class="k">import</span> <span class="n">conjugate</span> <span class="k">as</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_eval_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..functions.elementary.complexes</span> <span class="k">import</span> <span class="n">conjugate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_antihermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Expr.transpose"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transpose self.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.functions.elementary.complexes.transpose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..functions.elementary.complexes</span> <span class="k">import</span> <span class="n">transpose</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_eval_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..functions.elementary.complexes</span> <span class="k">import</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">transpose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_antihermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_conjugate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_transpose</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conjugate</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<div class="viewcode-block" id="Expr.adjoint"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute conjugate transpose or Hermite conjugation.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.functions.elementary.complexes.adjoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..functions.elementary.complexes</span> <span class="k">import</span> <span class="n">adjoint</span>
        <span class="k">return</span> <span class="n">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_order</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse and configure the ordering of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..polys.orderings</span> <span class="k">import</span> <span class="n">monomial_key</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;rev-&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="n">monom_key</span> <span class="o">=</span> <span class="n">monomial_key</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="n">monom</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monom</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="o">=</span> <span class="n">term</span>

            <span class="n">monom</span> <span class="o">=</span> <span class="n">neg</span><span class="p">(</span><span class="n">monom_key</span><span class="p">(</span><span class="n">monom</span><span class="p">))</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ncpart</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="nb">bool</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">im</span><span class="p">),</span> <span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">,</span> <span class="n">coeff</span>

        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span>

<div class="viewcode-block" id="Expr.as_ordered_factors"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_ordered_factors">[docs]</a>    <span class="k">def</span> <span class="nf">as_ordered_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of ordered factors (if Mul) else [self].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="Expr.as_ordered_terms"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_ordered_terms">[docs]</a>    <span class="k">def</span> <span class="nf">as_ordered_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform an expression to an ordered list of terms.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()</span>
<span class="sd">        [sin(x)**2*cos(x), sin(x)**2, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_terms</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">is_Order</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">):</span>
            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_terms</span><span class="p">,</span> <span class="n">_order</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="nb">repr</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                    <span class="n">_terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>

            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> \
                <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_order</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">gens</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">term</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">]</span></div>

<div class="viewcode-block" id="Expr.as_terms"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_terms">[docs]</a>    <span class="k">def</span> <span class="nf">as_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform an expression to a list of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">S</span>
        <span class="kn">from</span> <span class="nn">.exprtools</span> <span class="k">import</span> <span class="n">decompose_power</span>

        <span class="n">gens</span><span class="p">,</span> <span class="n">terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">_term</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">coeff</span> <span class="o">*=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="k">pass</span>

                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                        <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">decompose_power</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

                        <span class="n">cpart</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ncpart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">coeff</span><span class="o">.</span><span class="n">imag</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ncpart</span><span class="p">)</span>

            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="n">gens</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="n">k</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">),</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gens</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">monom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span>

            <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">cpart</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">monom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">base</span><span class="p">]]</span> <span class="o">=</span> <span class="n">exp</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">monom</span><span class="p">),</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">gens</span></div>

<div class="viewcode-block" id="Expr.removeO"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.removeO">[docs]</a>    <span class="k">def</span> <span class="nf">removeO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the additive O(..) symbol if there is one&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Expr.getO"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.getO">[docs]</a>    <span class="k">def</span> <span class="nf">getO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the additive O(..) symbol if there is one, else None.&quot;&quot;&quot;</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Expr.getn"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.getn">[docs]</a>    <span class="k">def</span> <span class="nf">getn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the order of the expression.</span>

<span class="sd">        The order is determined either from the O(...) term. If there</span>
<span class="sd">        is no O(...) term, it returns None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (1 + x + O(x**2)).getn()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (1 + x).getn()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">expr</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>  <span class="c1"># x**n*log(x)**n or x**n/log(x)**n</span>
                <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
                    <span class="k">elif</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                        <span class="n">syms</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">oi</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)})</span>
                            <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;not sure of order of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.count_ops"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.count_ops">[docs]</a>    <span class="k">def</span> <span class="nf">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;wrapper for count_ops that returns the operation count.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.args_cnc"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.args_cnc">[docs]</a>    <span class="k">def</span> <span class="nf">args_cnc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">split_1</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return [commutative factors, non-commutative factors] of self.</span>

<span class="sd">        self is treated as a Mul and the ordering of the factors is maintained.</span>
<span class="sd">        If ``cset`` is True the commutative factors will be returned in a set.</span>
<span class="sd">        If there were repeated factors (as may happen with an unevaluated Mul)</span>
<span class="sd">        then an error will be raised unless it is explicitly suppressed by</span>
<span class="sd">        setting ``warn`` to False.</span>

<span class="sd">        Note: -1 is always separated from a Number unless split_1 is False.</span>

<span class="sd">        &gt;&gt;&gt; A, B = symbols(&#39;A B&#39;, commutative=0)</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*y).args_cnc()</span>
<span class="sd">        [[-1, 2, x, y], []]</span>
<span class="sd">        &gt;&gt;&gt; (-2.5*x).args_cnc()</span>
<span class="sd">        [[-1, 2.5, x], []]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*A*B*y).args_cnc()</span>
<span class="sd">        [[-1, 2, x, y], [A, B]]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*A*B*y).args_cnc(split_1=False)</span>
<span class="sd">        [[-2, x, y], [A, B]]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*y).args_cnc(cset=True)</span>
<span class="sd">        [{-1, 2, x, y}, []]</span>

<span class="sd">        The arg is always treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (-2 + x + A).args_cnc()</span>
<span class="sd">        [[], [x - 2 + A]]</span>
<span class="sd">        &gt;&gt;&gt; (-oo).args_cnc() # -oo is a singleton</span>
<span class="sd">        [[-1, oo], []]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mi</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">split_1</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">and</span>
                <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">cset</span><span class="p">:</span>
            <span class="n">clen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clen</span> <span class="ow">and</span> <span class="n">warn</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">clen</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;repeated commutative arguments: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                 <span class="p">[</span><span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span></div>

<div class="viewcode-block" id="Expr.coeff"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.coeff">[docs]</a>    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the coefficient from the term(s) containing ``x**n`` or None. If ``n``</span>
<span class="sd">        is zero then all terms independent of ``x`` will be returned.</span>

<span class="sd">        When x is noncommutative, the coeff to the left (default) or right of x</span>
<span class="sd">        can be returned. The keyword &#39;right&#39; is ignored when x is commutative.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.core.expr.Expr.as_coefficient</span>
<span class="sd">        diofant.core.expr.Expr.as_coeff_Add</span>
<span class="sd">        diofant.core.expr.Expr.as_coeff_Mul</span>
<span class="sd">        diofant.core.expr.Expr.as_independent</span>
<span class="sd">        diofant.polys.polytools.Poly.coeff_monomial</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        You can select terms that have an explicit negative in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x + 2*y).coeff(-1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (x - 2*y).coeff(-1)</span>
<span class="sd">        2*y</span>

<span class="sd">        You can select terms with no Rational coefficient:</span>

<span class="sd">        &gt;&gt;&gt; (x + 2*y).coeff(1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(1)</span>
<span class="sd">        0</span>

<span class="sd">        You can select terms independent of x by making n=0; in this case</span>
<span class="sd">        expr.as_independent(x)[0] is returned (and 0 will be returned instead</span>
<span class="sd">        of None):</span>

<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x, 0)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; eq = ((x + 1)**3).expand() + 1</span>
<span class="sd">        &gt;&gt;&gt; eq</span>
<span class="sd">        x**3 + 3*x**2 + 3*x + 2</span>
<span class="sd">        &gt;&gt;&gt; [eq.coeff(x, i) for i in reversed(range(4))]</span>
<span class="sd">        [1, 3, 3, 2]</span>
<span class="sd">        &gt;&gt;&gt; eq -= 2</span>
<span class="sd">        &gt;&gt;&gt; [eq.coeff(x, i) for i in reversed(range(4))]</span>
<span class="sd">        [1, 3, 3, 0]</span>

<span class="sd">        You can select terms that have a numerical term in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x - 2*y).coeff(2)</span>
<span class="sd">        -y</span>
<span class="sd">        &gt;&gt;&gt; (x + sqrt(2)*x).coeff(sqrt(2))</span>
<span class="sd">        x</span>

<span class="sd">        The matching is exact:</span>

<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x**2)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x**3)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; (z*(x + y)**2).coeff((x + y)**2)</span>
<span class="sd">        z</span>
<span class="sd">        &gt;&gt;&gt; (z*(x + y)**2).coeff(x + y)</span>
<span class="sd">        0</span>

<span class="sd">        In addition, no factoring is done, so 1 + z*(1 + y) is not obtained</span>
<span class="sd">        from the following:</span>

<span class="sd">        &gt;&gt;&gt; (x + z*(x + x*y)).coeff(x)</span>
<span class="sd">        1</span>

<span class="sd">        If such factoring is desired, factor_terms can be used first:</span>

<span class="sd">        &gt;&gt;&gt; factor_terms(x + z*(x + x*y)).coeff(x)</span>
<span class="sd">        z*(y + 1) + 1</span>

<span class="sd">        &gt;&gt;&gt; n, m, o = symbols(&#39;n m o&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; n.coeff(n)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (3*n).coeff(n)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n) # = (1 + m)*n*m</span>
<span class="sd">        1 + m</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m</span>
<span class="sd">        m</span>

<span class="sd">        If there is more than one possible coefficient 0 is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + m*n).coeff(n)</span>
<span class="sd">        0</span>

<span class="sd">        If there is only one possible coefficient, it is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + x*m*n).coeff(m*n)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (n*m + x*m*n).coeff(m*n, right=1)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="n">co</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># continue with the full method, looking for this power of x:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span>

        <span class="k">def</span> <span class="nf">incommon</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">l1</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">l1</span><span class="p">[:]</span>

        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Find where list sub appears in list l. When ``first`` is True</span>
<span class="sd">            the first occurance from the left is returned, else the last</span>
<span class="sd">            occurance is returned. Return None if sub is not in l.</span>

<span class="sd">            &gt;&gt; l = range(5)*2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3])</span>
<span class="sd">            2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3], first=0)</span>
<span class="sd">            7</span>
<span class="sd">            &gt;&gt; find(l, [2, 4])</span>
<span class="sd">            None</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sub</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sub</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span>

        <span class="n">co</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">self_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="n">x_c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="k">if</span> <span class="n">self_c</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">self_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="n">nc</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># both nc</span>
            <span class="n">xargs</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># find the parts that pass the commutative terms</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">resid</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
            <span class="c1"># now check the non-comm parts</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">co</span><span class="p">]),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="n">beg</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">beg</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="n">gcdc</span> <span class="o">=</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">co</span><span class="p">)):</span>
                            <span class="n">gcdc</span> <span class="o">=</span> <span class="n">gcdc</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">gcdc</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gcdc</span><span class="p">)</span> <span class="o">+</span> <span class="n">beg</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">m</span><span class="p">:]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span>
                <span class="n">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">+</span> <span class="n">ii</span><span class="p">]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="c1"># look for single match</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span><span class="p">:</span>
                        <span class="n">hit</span> <span class="o">=</span> <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                    <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hit</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>

            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span></div>

<div class="viewcode-block" id="Expr.as_expr"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_expr">[docs]</a>    <span class="k">def</span> <span class="nf">as_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a polynomial to a Diofant expression.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; f = (x**2 + x*y).as_poly(x, y)</span>
<span class="sd">        &gt;&gt;&gt; f.as_expr()</span>
<span class="sd">        x**2 + x*y</span>

<span class="sd">        &gt;&gt;&gt; sin(x).as_expr()</span>
<span class="sd">        sin(x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Expr.as_poly"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_poly">[docs]</a>    <span class="k">def</span> <span class="nf">as_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts ``self`` to a polynomial or returns ``None``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (x**2 + x*y).as_poly()</span>
<span class="sd">        Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>

<span class="sd">        &gt;&gt;&gt; (x**2 + x*y).as_poly(x, y)</span>
<span class="sd">        Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>

<span class="sd">        &gt;&gt;&gt; (x**2 + sin(y)).as_poly(x, y) is None</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..polys</span> <span class="k">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">PolynomialError</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="Expr.as_coefficient"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">as_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts symbolic coefficient at the given expression.</span>

<span class="sd">        In other words, this functions separates &#39;self&#39; into the product</span>
<span class="sd">        of &#39;expr&#39; and &#39;expr&#39;-free coefficient. If such separation</span>
<span class="sd">        is not possible it will return None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; E.as_coefficient(E)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (2*E).as_coefficient(E)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (2*sin(E)*E).as_coefficient(E)</span>

<span class="sd">        Two terms have E in them so a sum is returned. (If one were</span>
<span class="sd">        desiring the coefficient of the term exactly matching E then</span>
<span class="sd">        the constant from the returned expression could be selected.</span>
<span class="sd">        Or, for greater precision, a method of Poly can be used to</span>
<span class="sd">        indicate the desired term from which the coefficient is</span>
<span class="sd">        desired.)</span>

<span class="sd">        &gt;&gt;&gt; (2*E + x*E).as_coefficient(E)</span>
<span class="sd">        x + 2</span>
<span class="sd">        &gt;&gt;&gt; _.args[0]  # just want the exact match</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; p = Poly(2*E + x*E); p</span>
<span class="sd">        Poly(x*E + 2*E, x, E, domain=&#39;ZZ&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p.coeff_monomial(E)</span>
<span class="sd">        2</span>

<span class="sd">        Since the following cannot be written as a product containing</span>
<span class="sd">        E as a factor, None is returned. (If the coefficient ``2*x`` is</span>
<span class="sd">        desired then the ``coeff`` method should be used.)</span>

<span class="sd">        &gt;&gt;&gt; (2*E*x + x).as_coefficient(E)</span>
<span class="sd">        &gt;&gt;&gt; (2*E*x + x).coeff(E)</span>
<span class="sd">        2*x</span>

<span class="sd">        &gt;&gt;&gt; (E*(x + 1) + x).as_coefficient(E)</span>

<span class="sd">        &gt;&gt;&gt; (2*pi*I).as_coefficient(pi*I)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (2*I).as_coefficient(pi*I)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        coeff: return sum of terms have a given factor</span>
<span class="sd">        as_coeff_Add: separate the additive constant from an expression</span>
<span class="sd">        as_coeff_Mul: separate the multiplicative constant from an expression</span>
<span class="sd">        as_independent: separate x-dependent terms/factors from others</span>
<span class="sd">        diofant.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">r</span></div>

<div class="viewcode-block" id="Expr.as_independent"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_independent">[docs]</a>    <span class="k">def</span> <span class="nf">as_independent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">,</span> <span class="o">**</span><span class="n">hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A mostly naive separation of a Mul or Add into arguments that are not</span>
<span class="sd">        are dependent on deps. To obtain as complete a separation of variables</span>
<span class="sd">        as possible, use a separation method first, e.g.:</span>

<span class="sd">        * separatevars() to change Mul, Add and Pow (including exp) into Mul</span>
<span class="sd">        * .expand(mul=True) to change Add or Mul into Add</span>
<span class="sd">        * .expand(log=True) to change log expr into an Add</span>

<span class="sd">        The only non-naive thing that is done here is to respect noncommutative</span>
<span class="sd">        ordering of variables.</span>

<span class="sd">        The returned tuple (i, d) has the following interpretation:</span>

<span class="sd">        * i will has no variable that appears in deps</span>
<span class="sd">        * d will be 1 or else have terms that contain variables that are in deps</span>
<span class="sd">        * if self is an Add then self = i + d</span>
<span class="sd">        * if self is a Mul then self = i*d</span>
<span class="sd">        * if self is anything else, either tuple (self, S.One) or (S.One, self)</span>
<span class="sd">          is returned.</span>

<span class="sd">        To force the expression to be treated as an Add, use the hint as_Add=True</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        -- self is an Add</span>

<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(x)</span>
<span class="sd">        (0, x*y + x)</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x)</span>
<span class="sd">        (y + z, 2*x*sin(x) + x)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x, y)</span>
<span class="sd">        (z, 2*x*sin(x) + x + y)</span>

<span class="sd">        -- self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; (x*sin(x)*cos(y)).as_independent(x)</span>
<span class="sd">        (cos(y), x*sin(x))</span>

<span class="sd">        non-commutative terms cannot always be separated out when self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; n1, n2, n3 = symbols(&#39;n1 n2 n3&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; (n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (n1, n1*n2)</span>
<span class="sd">        &gt;&gt;&gt; (n2*n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (0, n1*n2 + n2*n1)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n1)</span>
<span class="sd">        (1, n1*n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n2)</span>
<span class="sd">        (n1, n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; ((x-n1)*(x-y)).as_independent(x)</span>
<span class="sd">        (1, (x - y)*(x - n1))</span>

<span class="sd">        -- self is anything else:</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(x)</span>
<span class="sd">        (1, sin(x))</span>
<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(y)</span>
<span class="sd">        (sin(x), 1)</span>
<span class="sd">        &gt;&gt;&gt; exp(x+y).as_independent(x)</span>
<span class="sd">        (1, E**(x + y))</span>

<span class="sd">        -- force self to be treated as an Add:</span>

<span class="sd">        &gt;&gt;&gt; (3*x).as_independent(x, as_Add=True)</span>
<span class="sd">        (0, 3*x)</span>

<span class="sd">        -- force self to be treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (3+x).as_independent(x, as_Add=False)</span>
<span class="sd">        (1, x + 3)</span>
<span class="sd">        &gt;&gt;&gt; (-3+x).as_independent(x, as_Add=False)</span>
<span class="sd">        (1, x - 3)</span>

<span class="sd">        Note how the below differs from the above in making the</span>
<span class="sd">        constant on the dep term positive.</span>

<span class="sd">        &gt;&gt;&gt; (y*(-3+x)).as_independent(x)</span>
<span class="sd">        (y, x - 3)</span>

<span class="sd">        -- use .as_independent() for true independence testing instead</span>
<span class="sd">           of .has(). The former considers only symbols in the free</span>
<span class="sd">           symbols while the latter considers all symbols</span>

<span class="sd">        &gt;&gt;&gt; I = Integral(x, (x, 1, 2))</span>
<span class="sd">        &gt;&gt;&gt; I.has(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x in I.free_symbols</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; I.as_independent(x) == (I, 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (I + x).as_independent(x) == (I, x)</span>
<span class="sd">        True</span>

<span class="sd">        Note: when trying to get independent terms, a separation method</span>
<span class="sd">        might need to be used first. In this case, it is important to keep</span>
<span class="sd">        track of what you send to this routine so you know how to interpret</span>
<span class="sd">        the returned values</span>

<span class="sd">        &gt;&gt;&gt; separatevars(exp(x+y)).as_independent(x)</span>
<span class="sd">        (E**y, E**x)</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; separatevars(x + x*y).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).expand(mul=True).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; a, b=symbols(&#39;a b&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; (log(a*b).expand(log=True)).as_independent(b)</span>
<span class="sd">        (log(a), log(b))</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.simplify.simplify.separatevars</span>
<span class="sd">        expand</span>
<span class="sd">        diofant.core.add.Add.as_two_terms</span>
<span class="sd">        diofant.core.mul.Mul.as_two_terms</span>
<span class="sd">        as_coeff_add</span>
<span class="sd">        as_coeff_mul</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span>
        <span class="kn">from</span> <span class="nn">..utilities.iterables</span> <span class="k">import</span> <span class="n">sift</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="c1"># sift out deps into symbolic and other and ignore</span>
        <span class="c1"># all symbols but those that are in the free symbols</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)):</span>  <span class="c1"># Symbol.is_Symbol is True</span>
                <span class="n">sym</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;return the standard has() if there are no literal symbols, else</span>
<span class="sd">            check to see that symbol-deps are in the free symbols.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">has_other</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">has_other</span>
            <span class="k">return</span> <span class="n">has_other</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">sym</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;as_Add&#39;</span><span class="p">,</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Add</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Mul</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">func</span> <span class="ow">or</span>
                <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Add</span> <span class="ow">and</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">want</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">want</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">depend</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span>
        <span class="n">indep</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span>  <span class="c1"># all terms were treated as commutative</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># handle noncommutative by stopping at first dependent term</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">has</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">depend</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nc</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                    <span class="k">break</span>
                <span class="n">indep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.as_real_imag"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_real_imag">[docs]</a>    <span class="k">def</span> <span class="nf">as_real_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs complex expansion on &#39;self&#39; and returns a tuple</span>
<span class="sd">        containing collected both real and imaginary parts. This</span>
<span class="sd">        method can&#39;t be confused with re() and im() functions,</span>
<span class="sd">        which does not perform complex expansion at evaluation.</span>

<span class="sd">        However it is possible to expand both re() and im()</span>
<span class="sd">        functions and get exactly the same results as with</span>
<span class="sd">        a single call to this function.</span>

<span class="sd">        &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;, real=True)</span>

<span class="sd">        &gt;&gt;&gt; (x + y*I).as_real_imag()</span>
<span class="sd">        (x, y)</span>

<span class="sd">        &gt;&gt;&gt; (z + t*I).as_real_imag()</span>
<span class="sd">        (re(z) - im(t), re(t) + im(z))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">im</span><span class="p">,</span> <span class="n">re</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">re</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.as_powers_dict"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_powers_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_powers_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self as a dictionary of factors with each factor being</span>
<span class="sd">        treated as a power. The keys are the bases of the factors and the</span>
<span class="sd">        values, the corresponding exponents. The resulting dictionary should</span>
<span class="sd">        be used with caution if the expression is a Mul and contains non-</span>
<span class="sd">        commutative factors since the order that they appeared will be lost in</span>
<span class="sd">        the dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Expr.as_coefficients_dict"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_coefficients_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_coefficients_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping terms to their Rational coefficient.</span>
<span class="sd">        Since the dictionary is a defaultdict, inquiries about terms which</span>
<span class="sd">        were not present will return a coefficient of 0. If an expression is</span>
<span class="sd">        not an Add it is considered to have a single term.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (3*x + a*x + 4).as_coefficients_dict()</span>
<span class="sd">        {1: 4, x: 3, a*x: 1}</span>
<span class="sd">        &gt;&gt;&gt; _[a]</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; (3*a*x).as_coefficients_dict()</span>
<span class="sd">        {a*x: 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">m</span><span class="p">:</span> <span class="n">c</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Expr.as_base_exp"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_base_exp">[docs]</a>    <span class="k">def</span> <span class="nf">as_base_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return base and exp of self.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.core.power.Pow.as_base_exp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span></div>

<div class="viewcode-block" id="Expr.as_coeff_mul"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_coeff_mul">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as a Mul, ``m``.</span>

<span class="sd">        c should be a Rational multiplied by any terms of the Mul that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other terms of m; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is a Mul or not but</span>
<span class="sd">        you want to treat self as a Mul or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as a Mul.</span>

<span class="sd">        - if you know self is a Mul and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail;</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use ``self.as_independent(*deps)``</span>

<span class="sd">        &gt;&gt;&gt; (Integer(3)).as_coeff_mul()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul()</span>
<span class="sd">        (3, (x, y))</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, ())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span></div>

<div class="viewcode-block" id="Expr.as_coeff_add"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_coeff_add">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as an Add, ``a``.</span>

<span class="sd">        c should be a Rational added to any terms of the Add that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other terms of ``a``; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is an Add or not but</span>
<span class="sd">        you want to treat self as an Add or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as an Add.</span>

<span class="sd">        - if you know self is an Add and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail.</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use ``self.as_independent(*deps)``</span>

<span class="sd">        &gt;&gt;&gt; (Integer(3)).as_coeff_add()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3 + x).as_coeff_add()</span>
<span class="sd">        (3, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3 + x + y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3 + y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, ())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span></div>

<div class="viewcode-block" id="Expr.primitive"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.primitive">[docs]</a>    <span class="k">def</span> <span class="nf">primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the positive Rational that can be extracted non-recursively</span>
<span class="sd">        from every term of self (i.e., self is treated like an Add). This is</span>
<span class="sd">        like the as_coeff_Mul() method but primitive always extracts a positive</span>
<span class="sd">        Rational (never a negative or a Float).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (3*(x + 1)**2).primitive()</span>
<span class="sd">        (3, (x + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; a = (6*x + 2); a.primitive()</span>
<span class="sd">        (2, 3*x + 1)</span>
<span class="sd">        &gt;&gt;&gt; b = (x/2 + 3); b.primitive()</span>
<span class="sd">        (1/2, x + 6)</span>
<span class="sd">        &gt;&gt;&gt; (a*b).primitive()</span>
<span class="sd">        (1, (x/2 + 3)*(6*x + 2))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span></div>

<div class="viewcode-block" id="Expr.as_content_primitive"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_content_primitive">[docs]</a>    <span class="k">def</span> <span class="nf">as_content_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method should recursively remove a Rational from all arguments</span>
<span class="sd">        and return that (content) and the new self (primitive). The content</span>
<span class="sd">        should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.</span>
<span class="sd">        The primitive need no be in canonical form and should try to preserve</span>
<span class="sd">        the underlying structure if possible (i.e. expand_mul should not be</span>
<span class="sd">        applied to self).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; eq = 2 + 2*x + 2*y*(3 + 3*y)</span>

<span class="sd">        The as_content_primitive function is recursive and retains structure:</span>

<span class="sd">        &gt;&gt;&gt; eq.as_content_primitive()</span>
<span class="sd">        (2, x + 3*y*(y + 1) + 1)</span>

<span class="sd">        Integer powers will have Rationals extracted from the base:</span>

<span class="sd">        &gt;&gt;&gt; ((2 + 6*x)**2).as_content_primitive()</span>
<span class="sd">        (4, (3*x + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; ((2 + 6*x)**(2*y)).as_content_primitive()</span>
<span class="sd">        (1, (2*(3*x + 1))**(2*y))</span>

<span class="sd">        Terms may end up joining once their as_content_primitives are added:</span>

<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (11, x*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (9, x*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (1, 6.0*x*(y + 1) + 3*z*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()</span>
<span class="sd">        (121, x**2*(y + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()</span>
<span class="sd">        (1, 121.0*x**2*(y + 1)**2)</span>

<span class="sd">        Radical content can also be factored out of the primitive:</span>

<span class="sd">        &gt;&gt;&gt; (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)</span>
<span class="sd">        (2, sqrt(2)*(1 + 2*sqrt(5)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Expr.as_numer_denom"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_numer_denom">[docs]</a>    <span class="k">def</span> <span class="nf">as_numer_denom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;expression -&gt; a/b -&gt; a, b</span>

<span class="sd">        This is just a stub that should be defined by</span>
<span class="sd">        an object&#39;s class methods to get anything else.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        normal: return a/b instead of a, b</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_as_numer_denom</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span></div>

<div class="viewcode-block" id="Expr.normal"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.normal">[docs]</a>    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;canonicalize ratio, i.e. return numerator if denominator is 1&quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span></div>

<div class="viewcode-block" id="Expr.extract_multiplicatively"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.extract_multiplicatively">[docs]</a>    <span class="k">def</span> <span class="nf">extract_multiplicatively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None if it&#39;s not possible to make self in the form</span>
<span class="sd">        c * something in a nice way, i.e. preserving the properties</span>
<span class="sd">        of arguments of self.</span>

<span class="sd">        &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;, real=True)</span>

<span class="sd">        &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**2 * y)</span>
<span class="sd">        x*y**2</span>

<span class="sd">        &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**4 * y)</span>

<span class="sd">        &gt;&gt;&gt; (2*x).extract_multiplicatively(2)</span>
<span class="sd">        x</span>

<span class="sd">        &gt;&gt;&gt; (2*x).extract_multiplicatively(3)</span>

<span class="sd">        &gt;&gt;&gt; (Rational(1, 2)*x).extract_multiplicatively(3)</span>
<span class="sd">        x/6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">cc</span><span class="p">,</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">quotient</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">/</span> <span class="n">c</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">oo</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">oo</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="o">==</span> <span class="o">-</span><span class="n">oo</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">oo</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="n">oo</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">,</span> <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">newarg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newarg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                <span class="n">newarg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newarg</span>
                    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.extract_additively"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.extract_additively">[docs]</a>    <span class="k">def</span> <span class="nf">extract_additively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self - c if it&#39;s possible to subtract c from self and</span>
<span class="sd">        make all matching coefficients move towards zero, else return None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; e = 2*x + 3</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(x + 1)</span>
<span class="sd">        x + 2</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(3*x)</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(4)</span>
<span class="sd">        &gt;&gt;&gt; (y*(x + 1)).extract_additively(x + 1)</span>
<span class="sd">        &gt;&gt;&gt; ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)</span>
<span class="sd">        (x + 1)*(x + 2*y) + 3</span>

<span class="sd">        Sometimes auto-expansion will return a less simplified result</span>
<span class="sd">        than desired; gcd_terms might be used in such cases:</span>

<span class="sd">        &gt;&gt;&gt; (4*x*(y + 1) + y).extract_additively(x)</span>
<span class="sd">        4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y</span>
<span class="sd">        &gt;&gt;&gt; gcd_terms(_)</span>
<span class="sd">        x*(4*y + 3) + y</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        extract_multiplicatively</span>
<span class="sd">        coeff</span>
<span class="sd">        as_coefficient</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">nan</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">co</span> <span class="o">-</span> <span class="n">c</span>
            <span class="c1"># XXX should we match types? i.e should 3 - .1 succeed?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">co</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">co</span> <span class="ow">or</span>
                    <span class="n">co</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">co</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">diff</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="n">co</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">return</span> <span class="n">xa</span> <span class="o">+</span> <span class="n">t</span>

        <span class="c1"># handle the args[0].is_Number case separately</span>
        <span class="c1"># since we will have trouble looking for the coeff of</span>
        <span class="c1"># a number.</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="c1"># whole term as a term factor</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">xa0</span> <span class="o">=</span> <span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
            <span class="k">if</span> <span class="n">xa0</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">co</span><span class="o">*</span><span class="n">c</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">xa0</span> <span class="o">+</span> <span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">diff</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">None</span>
            <span class="c1"># term-wise</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">sh</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">xa2</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">return</span> <span class="n">xa</span> <span class="o">+</span> <span class="n">xa2</span>

        <span class="c1"># whole term as a term factor</span>
        <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">xa0</span> <span class="o">=</span> <span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
        <span class="k">if</span> <span class="n">xa0</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">co</span><span class="o">*</span><span class="n">c</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">xa0</span> <span class="o">+</span> <span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">diff</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="c1"># term-wise</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="n">ac</span><span class="p">,</span> <span class="n">at</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">coc</span><span class="p">,</span> <span class="n">cot</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">coc</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">ac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">self</span> <span class="o">-=</span> <span class="n">co</span><span class="o">*</span><span class="n">at</span>
            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cot</span> <span class="o">+</span> <span class="n">xa</span><span class="p">)</span><span class="o">*</span><span class="n">at</span><span class="p">)</span>
        <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">coeffs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.could_extract_minus_sign"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.could_extract_minus_sign">[docs]</a>    <span class="k">def</span> <span class="nf">could_extract_minus_sign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Canonical way to choose an element in the set {e, -e} where</span>
<span class="sd">        e is any expression. If the canonical element is e, we have</span>
<span class="sd">        e.could_extract_minus_sign() == True, else</span>
<span class="sd">        e.could_extract_minus_sign() == False.</span>

<span class="sd">        For any expression, the set ``{e.could_extract_minus_sign(),</span>
<span class="sd">        (-e).could_extract_minus_sign()}`` must be ``{True, False}``.</span>

<span class="sd">        &gt;&gt;&gt; (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">negative_self</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span>
        <span class="n">self_has_minus</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">negative_self_has_minus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">negative_self</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self_has_minus</span> <span class="o">!=</span> <span class="n">negative_self_has_minus</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self_has_minus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c1"># We choose the one with less arguments with minus signs</span>
                <span class="n">all_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()])</span>
                <span class="n">positive_args</span> <span class="o">=</span> <span class="n">all_args</span> <span class="o">-</span> <span class="n">negative_args</span>
                <span class="k">if</span> <span class="n">positive_args</span> <span class="o">&gt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">positive_args</span> <span class="o">&lt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="c1"># We choose the one with an odd number of minus signs</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
                <span class="n">arg_signs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">arg_signs</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">negative_args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="c1"># As a last resort, we choose the one with greater value of .sort_key()</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">negative_self</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span></div>

<div class="viewcode-block" id="Expr.extract_branch_factor"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.extract_branch_factor">[docs]</a>    <span class="k">def</span> <span class="nf">extract_branch_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_half</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.</span>
<span class="sd">        Return (z, n).</span>

<span class="sd">        &gt;&gt;&gt; exp_polar(I*pi).extract_branch_factor()</span>
<span class="sd">        (exp_polar(I*pi), 0)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(2*I*pi).extract_branch_factor()</span>
<span class="sd">        (1, 1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-pi*I).extract_branch_factor()</span>
<span class="sd">        (exp_polar(I*pi), -1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(3*pi*I + x).extract_branch_factor()</span>
<span class="sd">        (exp_polar(x + I*pi), 1)</span>
<span class="sd">        &gt;&gt;&gt; (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()</span>
<span class="sd">        (y*exp_polar(2*pi*x), -1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-I*pi/2).extract_branch_factor()</span>
<span class="sd">        (exp_polar(-I*pi/2), 0)</span>

<span class="sd">        If allow_half is True, also extract exp_polar(I*pi):</span>

<span class="sd">        &gt;&gt;&gt; exp_polar(I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 1/2)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(2*I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(3*I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 3/2)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, -1/2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.add</span> <span class="k">import</span> <span class="n">Add</span>
        <span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span>
        <span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">ceiling</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">exps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">):</span>
                <span class="n">exps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">exp</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">*=</span> <span class="n">arg</span>
        <span class="n">piimult</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">exps</span><span class="p">:</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">exps</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">exps</span> <span class="o">+=</span> <span class="n">exp</span><span class="o">.</span><span class="n">args</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">piimult</span> <span class="o">+=</span> <span class="n">coeff</span>
                    <span class="k">continue</span>
            <span class="n">extras</span> <span class="o">+=</span> <span class="p">[</span><span class="n">exp</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">piimult</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">piimult</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">piimult</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="o">*</span><span class="n">piimult</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="c1"># round down to nearest multiple of 2</span>
        <span class="n">branchfact</span> <span class="o">=</span> <span class="n">ceiling</span><span class="p">(</span><span class="n">coeff</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">branchfact</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">-</span> <span class="n">branchfact</span>
        <span class="k">if</span> <span class="n">allow_half</span><span class="p">:</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span>
        <span class="n">newexp</span> <span class="o">=</span> <span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">tail</span><span class="p">))</span> <span class="o">+</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">extras</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newexp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">*=</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">newexp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">n</span></div>

    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Expr.is_polynomial"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.is_polynomial">[docs]</a>    <span class="k">def</span> <span class="nf">is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return True if self is a polynomial in syms and False otherwise.</span>

<span class="sd">        This checks if self is an exact polynomial in syms.  This function</span>
<span class="sd">        returns False for expressions that are &quot;polynomials&quot; with symbolic</span>
<span class="sd">        exponents.  Thus, you should be able to apply polynomial algorithms to</span>
<span class="sd">        expressions for which this returns True, and Poly(expr, \*syms) should</span>
<span class="sd">        work if and only if expr.is_polynomial(\*syms) returns True. The</span>
<span class="sd">        polynomial does not have to be in expanded form.  If no symbols are</span>
<span class="sd">        given, all free symbols in the expression will be used.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, polynomial=True).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (2**x + 1).is_polynomial(x)</span>
<span class="sd">        False</span>


<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, nonnegative=True, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_polynomial(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a polynomial to</span>
<span class="sd">        become one.</span>

<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)</span>
<span class="sd">        &gt;&gt;&gt; a.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; b = (y**2 + 2*y + 1)/(y + 1)</span>
<span class="sd">        &gt;&gt;&gt; b.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; cancel(b)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; cancel(b).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_rational_function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="c1"># constant polynomial</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_polynomial</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Expr.is_rational_function"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.is_rational_function">[docs]</a>    <span class="k">def</span> <span class="nf">is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether function is a ratio of two polynomials in the given</span>
<span class="sd">        symbols, syms. When syms is not given, all free symbols will be used.</span>
<span class="sd">        The rational function does not have to be in expanded or in any kind of</span>
<span class="sd">        canonical form.</span>

<span class="sd">        This function returns False for expressions that are &quot;rational</span>
<span class="sd">        functions&quot; with symbolic exponents.  Thus, you should be able to call</span>
<span class="sd">        .as_numer_denom() and apply polynomial algorithms to the result for</span>
<span class="sd">        expressions for which this returns True.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, rational_function=True).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (x/y).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x**2).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x/sin(y)).is_rational_function(y)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_rational_function(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a rational function</span>
<span class="sd">        to become one.</span>

<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; a.is_rational_function(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        (y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_rational_function(y)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_algebraic_expr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="p">[</span><span class="n">nan</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">zoo</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="c1"># constant rational function</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_rational_function</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_eval_is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Expr.is_algebraic_expr"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.is_algebraic_expr">[docs]</a>    <span class="k">def</span> <span class="nf">is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This tests whether a given expression is algebraic or not, in the</span>
<span class="sd">        given symbols, syms. When syms is not given, all free symbols</span>
<span class="sd">        will be used. The rational function does not have to be in expanded</span>
<span class="sd">        or in any kind of canonical form.</span>

<span class="sd">        This function returns False for expressions that are &quot;algebraic</span>
<span class="sd">        expressions&quot; with symbolic exponents. This is a simple extension</span>
<span class="sd">        to the is_rational_function, including rational exponentiation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; sqrt(1 + x).is_rational_function()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; sqrt(1 + x).is_algebraic_expr()</span>
<span class="sd">        True</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be an algebraic</span>
<span class="sd">        expression to become one.</span>

<span class="sd">        &gt;&gt;&gt; a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)</span>
<span class="sd">        &gt;&gt;&gt; a.is_algebraic_expr(x)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_algebraic_expr()</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_rational_function</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        * https//en.wikipedia.org/wiki/Algebraic_expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="c1"># constant algebraic expression</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_algebraic_expr</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.is_hypergeometric"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.is_hypergeometric">[docs]</a>    <span class="k">def</span> <span class="nf">is_hypergeometric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if self is a hypergeometric term in k.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.simplify.simplify.hypersimp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">hypersimp</span>
        <span class="k">return</span> <span class="n">hypersimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_comparable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if self can be computed to a real number with precision.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (I*exp_polar(I*pi/2)).is_comparable</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (I*exp_polar(I*pi*2)).is_comparable</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_extended_real</span>
        <span class="k">if</span> <span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">is_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span>
        <span class="k">if</span> <span class="n">is_number</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="c1">###################################################################################</span>
    <span class="c1"># #################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ############### #</span>
    <span class="c1">###################################################################################</span>

<div class="viewcode-block" id="Expr.series"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.series">[docs]</a>    <span class="k">def</span> <span class="nf">series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Series expansion of &quot;self&quot; around ``x = x0`` yielding either terms of</span>
<span class="sd">        the series one by one (the lazy series given when n=None), else</span>
<span class="sd">        all the terms at once when n != None.</span>

<span class="sd">        Returns the series expansion of &quot;self&quot; around the point ``x = x0``</span>
<span class="sd">        with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).</span>

<span class="sd">        If ``x=None`` and ``self`` is univariate, the univariate symbol will</span>
<span class="sd">        be supplied, otherwise an error will be raised.</span>

<span class="sd">        &gt;&gt;&gt; cos(x).series()</span>
<span class="sd">        1 - x**2/2 + x**4/24 + O(x**6)</span>
<span class="sd">        &gt;&gt;&gt; cos(x).series(n=4)</span>
<span class="sd">        1 - x**2/2 + O(x**4)</span>
<span class="sd">        &gt;&gt;&gt; cos(x).series(x, x0=1, n=2)</span>
<span class="sd">        cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))</span>
<span class="sd">        &gt;&gt;&gt; e = cos(x + exp(y))</span>
<span class="sd">        &gt;&gt;&gt; e.series(y, n=2)</span>
<span class="sd">        cos(x + 1) - y*sin(x + 1) + O(y**2)</span>
<span class="sd">        &gt;&gt;&gt; e.series(x, n=2)</span>
<span class="sd">        cos(E**y) - x*sin(E**y) + O(x**2)</span>

<span class="sd">        If ``n=None`` then a generator of the series terms will be returned.</span>

<span class="sd">        &gt;&gt;&gt; term = cos(x).series(n=None)</span>
<span class="sd">        &gt;&gt;&gt; [next(term) for i in range(2)]</span>
<span class="sd">        [1, -x**2/2]</span>

<span class="sd">        For ``dir=+`` (default) the series is calculated from the right and</span>
<span class="sd">        for ``dir=-`` the series from the left. For smooth functions this</span>
<span class="sd">        flag will not alter the results.</span>

<span class="sd">        &gt;&gt;&gt; abs(x).series(dir=&quot;+&quot;)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; abs(x).series(dir=&quot;-&quot;)</span>
<span class="sd">        -x</span>

<span class="sd">        For rational expressions this method may return original expression.</span>

<span class="sd">        &gt;&gt;&gt; (1/x).series(x, n=8)</span>
<span class="sd">        1/x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span>
        <span class="kn">from</span> <span class="nn">..series</span> <span class="k">import</span> <span class="n">Order</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">collect</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">syms</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be given for multivariate functions.&#39;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;x is not a symbol&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;+-&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dir must be &#39;+&#39; or &#39;-&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="ow">in</span> <span class="p">[</span><span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">]:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="o">-</span><span class="n">oo</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="c1"># use rep to shift origin to x0 and change sign (if dir is negative)</span>
        <span class="c1"># and undo the process with rep2</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="n">x0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="o">-</span><span class="n">x0</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">rep</span><span class="p">})</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># lseries...</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">})</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># pragma: no branch</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">})</span>

        <span class="c1"># from here on it&#39;s x0=0 and dir=&#39;+&#39; handling</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># replace x with an x that has a positive assumption</span>
            <span class="n">xpos</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">xpos</span><span class="p">})</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xpos</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">rv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rv</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xpos</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># nseries handling</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="n">cur_order</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="c1"># Now make sure the requested order is returned</span>
            <span class="n">target_order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">ndo</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">target_order</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">cur_order</span><span class="p">):</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">ndo</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
                <span class="n">ndo</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">cur_order</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">target_order</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">==</span> <span class="n">s1</span><span class="p">:</span>
                <span class="n">target_order</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">removeO</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">target_order</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>  <span class="c1"># XXX parse_derivative of radsimp.py</span>
                <span class="k">return</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">target_order</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># lseries handling</span>
            <span class="k">def</span> <span class="nf">yield_lseries</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return terms of lseries one at a time.&quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">si</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">si</span>
                        <span class="k">continue</span>
                    <span class="c1"># yield terms 1 at a time if possible</span>
                    <span class="c1"># by increasing order until all the</span>
                    <span class="c1"># terms have been returned</span>
                    <span class="n">yielded</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
                    <span class="k">if</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                    <span class="n">ndid</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ndo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">do</span> <span class="o">=</span> <span class="p">(</span><span class="n">si</span> <span class="o">-</span> <span class="n">yielded</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                        <span class="n">o</span> <span class="o">*=</span> <span class="n">x</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">do</span> <span class="ow">or</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                            <span class="n">o</span>  <span class="c1"># XXX &quot;peephole&quot; optimization, http://bugs.python.org/issue2506</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">do</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">do</span>
                        <span class="k">if</span> <span class="n">ndid</span> <span class="o">==</span> <span class="n">ndo</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">yielded</span> <span class="o">+=</span> <span class="n">do</span>

            <span class="k">return</span> <span class="n">yield_lseries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span><span class="o">.</span><span class="n">_eval_lseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">))</span></div>

<div class="viewcode-block" id="Expr.taylor_term"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.taylor_term">[docs]</a>    <span class="k">def</span> <span class="nf">taylor_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">previous_terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;General method for the taylor term.</span>

<span class="sd">        This method is slow, because it differentiates n-times. Subclasses can</span>
<span class="sd">        redefine it to make it faster by using the &quot;previous_terms&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Dummy</span>
        <span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">factorial</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">})</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">_x</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.lseries"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.lseries">[docs]</a>    <span class="k">def</span> <span class="nf">lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrapper for series yielding an iterator of the terms of the series.</span>

<span class="sd">        Note: an infinite series will yield an infinite iterator. The following,</span>
<span class="sd">        for exaxmple, will never terminate. It will just keep printing terms</span>
<span class="sd">        of the sin(x) series::</span>

<span class="sd">          for term in sin(x).lseries(x):</span>
<span class="sd">              print term</span>

<span class="sd">        The advantage of lseries() over nseries() is that many times you are</span>
<span class="sd">        just interested in the next term in the series (i.e. the first term for</span>
<span class="sd">        example), but you don&#39;t know how many you should ask for in nseries()</span>
<span class="sd">        using the &quot;n&quot; parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        nseries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_eval_lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># default implementation of lseries is using nseries(), and adaptively</span>
        <span class="c1"># increasing the &quot;n&quot;. As you can see, it is not very efficient, because</span>
        <span class="c1"># we are calculating the series over and over again. Subclasses should</span>
        <span class="c1"># override this method and implement much more efficient yielding of</span>
        <span class="c1"># terms.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span>
            <span class="k">return</span>

        <span class="k">while</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">e</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">series</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">yield</span> <span class="n">series</span> <span class="o">-</span> <span class="n">e</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">series</span>

<div class="viewcode-block" id="Expr.nseries"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.nseries">[docs]</a>    <span class="k">def</span> <span class="nf">nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate &quot;n&quot; terms of series in x around 0</span>

<span class="sd">        This calculates n terms of series in the innermost expressions</span>
<span class="sd">        and then builds up the final series just by &quot;cross-multiplying&quot;</span>
<span class="sd">        everything out.</span>

<span class="sd">        Advantage -- it&#39;s fast, because we don&#39;t have to determine how many</span>
<span class="sd">        terms we need to calculate in advance.</span>

<span class="sd">        Disadvantage -- you may end up with less terms than you may have</span>
<span class="sd">        expected, but the O(x**n) term appended will always be correct and</span>
<span class="sd">        so the result, though perhaps shorter, will also be correct.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        x : Symbol</span>
<span class="sd">            variable for series expansion (positive and finite symbol)</span>
<span class="sd">        n : Integer, optional</span>
<span class="sd">            number of terms to calculate.  Default is 6.</span>
<span class="sd">        logx : Symbol, optional</span>
<span class="sd">            This can be used to replace any log(x) in the returned series</span>
<span class="sd">            with a symbolic value to avoid evaluating log(x) at 0.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        series</span>
<span class="sd">        lseries</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; sin(x).nseries(x)</span>
<span class="sd">        x - x**3/6 + x**5/120 + O(x**7)</span>
<span class="sd">        &gt;&gt;&gt; log(x + 1).nseries(x, 5)</span>
<span class="sd">        x - x**2/2 + x**3/3 - x**4/4 + O(x**5)</span>

<span class="sd">        Handling of the ``logx`` parameter --- in the following example the</span>
<span class="sd">        expansion fails since ``sin`` does not have an asymptotic expansion</span>
<span class="sd">        at -oo (the limit of log(x) as x approaches 0).</span>

<span class="sd">        &gt;&gt;&gt; e = sin(log(x))</span>
<span class="sd">        &gt;&gt;&gt; e.nseries(x)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        PoleError: ...</span>
<span class="sd">        &gt;&gt;&gt; logx = Symbol(&#39;logx&#39;)</span>
<span class="sd">        &gt;&gt;&gt; e.nseries(x, logx=logx)</span>
<span class="sd">        sin(logx)</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        This method call the helper method _eval_nseries.  Such methods</span>
<span class="sd">        should be implemented in subclasses.</span>

<span class="sd">        The series expansion code is an important part of the gruntz</span>
<span class="sd">        algorithm for determining limits. _eval_nseries has to return a</span>
<span class="sd">        generalized power series with coefficients in C(log(x), log)::</span>

<span class="sd">           c_0*x**e_0 + ... (finitely many terms)</span>

<span class="sd">        where e_i are numbers (not necessarily integers) and c_i involve</span>
<span class="sd">        only numbers, the function log, and log(x).  (This also means it</span>
<span class="sd">        must not contain log(x(1 + p)), this *has* to be expanded to</span>
<span class="sd">        log(x) + log(1 + p) if p.is_positive.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Dummy</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">collect</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">is_finite</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="p">})</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">p</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span></div>

<div class="viewcode-block" id="Expr.aseries"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.aseries">[docs]</a>    <span class="k">def</span> <span class="nf">aseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hir</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns asymptotic expansion for &quot;self&quot;.</span>

<span class="sd">        This is equivalent to ``self.series(x, oo, n)``</span>

<span class="sd">        Use the ``hir`` parameter to produce hierarchical series. It stops the recursion</span>
<span class="sd">        at an early level and may provide nicer and more useful results.</span>

<span class="sd">        If the most rapidly varying subexpression of a given expression f is f itself,</span>
<span class="sd">        the algorithm tries to find a normalized representation of the mrv set and rewrites f</span>
<span class="sd">        using this normalized representation.</span>
<span class="sd">        Use the ``bound`` parameter to give limit on rewriting coefficients in its normalized form.</span>

<span class="sd">        If the expansion contains an order term, it will be either ``O(x**(-n))`` or ``O(w**(-n))``</span>
<span class="sd">        where ``w`` belongs to the most rapidly varying expression of ``self``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; e = sin(1/x + exp(-x)) - sin(1/x)</span>
<span class="sd">        &gt;&gt;&gt; e.aseries(x)</span>
<span class="sd">        E**(-x)*(1/(24*x**4) - 1/(2*x**2) + 1 + O(x**(-6), (x, oo)))</span>
<span class="sd">        &gt;&gt;&gt; e.aseries(x, n=3, hir=True)</span>
<span class="sd">        -E**(-2*x)*sin(1/x)/2 + E**(-x)*cos(1/x) + O(E**(-3*x), (x, oo))</span>

<span class="sd">        &gt;&gt;&gt; e = exp(exp(x)/(1 - 1/x))</span>
<span class="sd">        &gt;&gt;&gt; e.aseries(x, bound=3)</span>
<span class="sd">        E**(E**x)*E**(E**x/x**2)*E**(E**x/x)*E**(-E**x + E**x/(1 - 1/x) - E**x/x - E**x/x**2)</span>
<span class="sd">        &gt;&gt;&gt; e.aseries(x)</span>
<span class="sd">        E**(E**x/(1 - 1/x))</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        This algorithm is directly induced from the limit computational algorithm</span>
<span class="sd">        provided by Gruntz [Gruntz96]_, p.90. It majorly uses the mrv and rewrite sub-routines.</span>
<span class="sd">        The overall idea of this algorithm is first to look for the most</span>
<span class="sd">        rapidly varying subexpression w of a given expression f and then expands f</span>
<span class="sd">        in a series in w. Then same thing is recursively done on the leading coefficient</span>
<span class="sd">        till we get constant coefficients.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        * https//en.wikipedia.org/wiki/Asymptotic_expansion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">Dummy</span>
        <span class="kn">from</span> <span class="nn">..series.gruntz</span> <span class="k">import</span> <span class="n">mrv</span><span class="p">,</span> <span class="n">rewrite</span>
        <span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
        <span class="kn">from</span> <span class="nn">..series</span> <span class="k">import</span> <span class="n">Order</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xpos</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">xpos</span><span class="p">})</span><span class="o">.</span><span class="n">aseries</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">hir</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xpos</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="n">mrv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">omega</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span><span class="o">.</span><span class="n">aseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">hir</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">getO</span><span class="p">():</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">o</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">logw</span> <span class="o">=</span> <span class="n">rewrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">omega</span><span class="p">:</span>
            <span class="c1"># Need to find a canonical representative</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">aseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">bound</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">})</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">}))</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exp</span> <span class="o">-</span> <span class="n">rep</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span><span class="o">/</span><span class="n">d</span>
            <span class="n">logw</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">rep</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="c1"># Hierarchical series: break after first recursion</span>
        <span class="k">if</span> <span class="n">hir</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">logw</span><span class="p">)})</span>

        <span class="n">o</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">removeO</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">as_coeff_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="n">gotO</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">expo</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">as_coeff_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">aseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">bound</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">gotO</span> <span class="ow">and</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">():</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">():</span>
                    <span class="n">gotO</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="n">d</span><span class="o">**</span><span class="n">expo</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span> <span class="ow">or</span> <span class="n">gotO</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">logw</span><span class="p">)})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">logw</span><span class="p">)})</span></div>

<div class="viewcode-block" id="Expr.limit"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.limit">[docs]</a>    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute limit x-&gt;xlim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..series.limits</span> <span class="k">import</span> <span class="n">limit</span>
        <span class="k">return</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.compute_leading_term"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.compute_leading_term">[docs]</a>    <span class="k">def</span> <span class="nf">compute_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;as_leading_term is only allowed for results of .series()</span>
<span class="sd">        This is a wrapper to compute a series first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Dummy</span>
        <span class="kn">from</span> <span class="nn">..functions</span> <span class="k">import</span> <span class="n">log</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">logx</span> <span class="k">if</span> <span class="n">logx</span> <span class="k">else</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;logx&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">d</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

            <span class="n">is_zero</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_zero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">is_zero</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Zero-decision problem for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">logx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span>

        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.as_leading_term"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_leading_term">[docs]</a>    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the leading (nonzero) term of the series expansion of self.</span>

<span class="sd">        The _eval_as_leading_term routines are used to do this, and they must</span>
<span class="sd">        always return a non-zero value.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; (1 + x + x**2).as_leading_term(x)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (1/x**2 + x + x**2).as_leading_term(x)</span>
<span class="sd">        x**(-2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">powsimp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expecting a Symbol but got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;as_leading_term(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                                  <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>  <span class="c1"># pragma: no cover</span></div>

    <span class="k">def</span> <span class="nf">_eval_as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Expr.as_coeff_exponent"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_coeff_exponent">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``c*x**e -&gt; c,e`` where x can be any symbolic expression.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">collect</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span></div>

<div class="viewcode-block" id="Expr.as_coeff_Mul"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_coeff_Mul">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficiently extract the coefficient of a product.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Expr.as_coeff_Add"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.as_coeff_Add">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficiently extract the coefficient of a summation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="bp">self</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">canonical_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping any variable defined in</span>
<span class="sd">        ``self.variables`` as underscore-suffixed numbers</span>
<span class="sd">        corresponding to their position in ``self.variables``. Enough</span>
<span class="sd">        underscores are added to ensure that there will be no clash with</span>
<span class="sd">        existing free symbols.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; Lambda(x, 2*x).canonical_variables</span>
<span class="sd">        {x: 0_}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">Symbol</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">u</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span>
        <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">V</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">i</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">u</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="o">.</span><span class="n">_assumptions</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">V</span><span class="p">)}</span>

    <span class="c1">###################################################################################</span>
    <span class="c1"># ################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ################## #</span>
    <span class="c1">###################################################################################</span>

<div class="viewcode-block" id="Expr.diff"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.diff">[docs]</a>    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for :func:`~diofant.core.function.diff`. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">diff</span>
        <span class="k">return</span> <span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1"># #################### EXPRESSION EXPANSION METHODS ##################### #</span>
    <span class="c1">###########################################################################</span>

    <span class="c1"># Relevant subclasses should override _eval_expand_hint() methods.  See</span>
    <span class="c1"># the docstring of expand() for more info.</span>

    <span class="k">def</span> <span class="nf">_eval_expand_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">real</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">imag</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_expand_hint</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.</span>

<span class="sd">        Returns ``(expr, hit)``, where expr is the (possibly) expanded</span>
<span class="sd">        ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and</span>
<span class="sd">        ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># XXX: Hack to support non-Basic args</span>
        <span class="c1">#              |</span>
        <span class="c1">#              V</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">sargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">arg</span><span class="p">,</span> <span class="n">arghit</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="n">hit</span> <span class="o">|=</span> <span class="n">arghit</span>
                <span class="n">sargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">sargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">):</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">)(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newexpr</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">newexpr</span><span class="p">,</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="n">hit</span>

<div class="viewcode-block" id="Expr.expand"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.expand">[docs]</a>    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">power_base</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expand an expression using hints.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.core.function.expand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify.radsimp</span> <span class="k">import</span> <span class="n">fraction</span>

        <span class="n">hints</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">power_base</span><span class="o">=</span><span class="n">power_base</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="n">power_exp</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="n">mul</span><span class="p">,</span>
                     <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="n">multinomial</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="n">basic</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;frac&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>
        <span class="k">elif</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;denom&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;numer&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span><span class="o">/</span><span class="n">d</span>

        <span class="c1"># Although the hints are sorted here, an earlier hint may get applied</span>
        <span class="c1"># at a given node in the expression tree before another because of how</span>
        <span class="c1"># the hints are applied.  e.g. expand(log(x*(y + z))) -&gt; log(x*y +</span>
        <span class="c1"># x*z) because while applying log at the top level, log and mul are</span>
        <span class="c1"># applied at the deeper level in the tree so that when the log at the</span>
        <span class="c1"># upper level gets applied, the mul has already been applied at the</span>
        <span class="c1"># lower level.</span>

        <span class="c1"># Additionally, because hints are only applied once, the expression</span>
        <span class="c1"># may not be expanded all the way.   For example, if mul is applied</span>
        <span class="c1"># before multinomial, x*(x + 1)**2 won&#39;t be expanded all the way.  For</span>
        <span class="c1"># now, we just use a special case to make multinomial run before mul,</span>
        <span class="c1"># so that at least polynomials will be expanded all the way.  In the</span>
        <span class="c1"># future, smarter heuristics should be applied.</span>
        <span class="c1"># TODO: Smarter heuristics</span>

        <span class="k">def</span> <span class="nf">_expand_hint_key</span><span class="p">(</span><span class="n">hint</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Make multinomial come before mul&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">hint</span> <span class="o">==</span> <span class="s1">&#39;mul&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;mulz&#39;</span>
            <span class="k">return</span> <span class="n">hint</span>

        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hints</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_expand_hint_key</span><span class="p">):</span>
            <span class="n">use_hint</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">use_hint</span><span class="p">:</span>
                <span class="n">hint</span> <span class="o">=</span> <span class="s1">&#39;_eval_expand_&#39;</span> <span class="o">+</span> <span class="n">hint</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">was</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;_eval_expand_multinomial&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mul&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;_eval_expand_mul&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;_eval_expand_log&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">modulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modulus</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">modulus</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">modulus</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">or</span> <span class="n">modulus</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;modulus must be a positive integer, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">modulus</span><span class="p">)</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">coeff</span> <span class="o">%=</span> <span class="n">modulus</span>

                <span class="k">if</span> <span class="n">coeff</span><span class="p">:</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">tail</span><span class="p">)</span>

            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1"># ################# GLOBAL ACTION VERB WRAPPER METHODS ################## #</span>
    <span class="c1">###########################################################################</span>

<div class="viewcode-block" id="Expr.integrate"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the integrate function in diofant.integrals&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..integrals</span> <span class="k">import</span> <span class="n">integrate</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.simplify"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the simplify function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">simplify</span>
        <span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">count_ops</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="n">measure</span> <span class="ow">or</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.nsimplify"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.nsimplify">[docs]</a>    <span class="k">def</span> <span class="nf">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="p">[],</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the nsimplify function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">nsimplify</span>
        <span class="k">return</span> <span class="n">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">full</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.collect"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.collect">[docs]</a>    <span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the collect function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">collect</span>
        <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.together"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.together">[docs]</a>    <span class="k">def</span> <span class="nf">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the together function in diofant.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..polys</span> <span class="k">import</span> <span class="n">together</span>
        <span class="k">return</span> <span class="n">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.apart"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.apart">[docs]</a>    <span class="k">def</span> <span class="nf">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the apart function in diofant.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..polys</span> <span class="k">import</span> <span class="n">apart</span>
        <span class="k">return</span> <span class="n">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.ratsimp"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.ratsimp">[docs]</a>    <span class="k">def</span> <span class="nf">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the ratsimp function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">ratsimp</span>
        <span class="k">return</span> <span class="n">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.trigsimp"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.trigsimp">[docs]</a>    <span class="k">def</span> <span class="nf">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the trigsimp function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">trigsimp</span>
        <span class="k">return</span> <span class="n">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.radsimp"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.radsimp">[docs]</a>    <span class="k">def</span> <span class="nf">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the radsimp function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">radsimp</span>
        <span class="k">return</span> <span class="n">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.powsimp"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.powsimp">[docs]</a>    <span class="k">def</span> <span class="nf">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the powsimp function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">powsimp</span>
        <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.combsimp"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.combsimp">[docs]</a>    <span class="k">def</span> <span class="nf">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the combsimp function in diofant.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..simplify</span> <span class="k">import</span> <span class="n">combsimp</span>
        <span class="k">return</span> <span class="n">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.factor"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.factor">[docs]</a>    <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the factor() function in diofant.polys.polytools&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..polys</span> <span class="k">import</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.cancel"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the cancel function in diofant.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..polys</span> <span class="k">import</span> <span class="n">cancel</span>
        <span class="k">return</span> <span class="n">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.invert"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.invert">[docs]</a>    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the multiplicative inverse of ``self`` mod ``g``</span>
<span class="sd">        where ``self`` (and ``g``) may be symbolic expressions).</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        diofant.core.numbers.mod_inverse</span>
<span class="sd">        diofant.polys.polytools.invert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..polys.polytools</span> <span class="k">import</span> <span class="n">invert</span>
        <span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">mod_inverse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;is_number&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mod_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expr.round"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.Expr.round">[docs]</a>    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return x rounded to the given decimal place.</span>

<span class="sd">        If a complex number would results, apply round to the real</span>
<span class="sd">        and imaginary components of the number.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; Float(10.5).round()</span>
<span class="sd">        11.</span>
<span class="sd">        &gt;&gt;&gt; pi.round()</span>
<span class="sd">        3.</span>
<span class="sd">        &gt;&gt;&gt; pi.round(2)</span>
<span class="sd">        3.14</span>
<span class="sd">        &gt;&gt;&gt; (2*pi + E*I).round()</span>
<span class="sd">        6.0 + 3.0*I</span>

<span class="sd">        The round method has a chopping effect:</span>

<span class="sd">        &gt;&gt;&gt; (2*pi + I/10).round()</span>
<span class="sd">        6.</span>
<span class="sd">        &gt;&gt;&gt; (pi/10 + 2*I).round()</span>
<span class="sd">        2.0*I</span>
<span class="sd">        &gt;&gt;&gt; (pi/10 + E*I).round(2)</span>
<span class="sd">        0.31 + 2.72*I</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Do not confuse the Python builtin function, round, with the</span>
<span class="sd">        Diofant method of the same name. The former always returns a float</span>
<span class="sd">        (or raises an error if applied to a complex value) while the</span>
<span class="sd">        latter returns either a Number or a complex number:</span>

<span class="sd">        &gt;&gt;&gt; isinstance(round(Integer(123), -2), Number)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; isinstance(Integer(123).round(-2), Number)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; isinstance((3*I).round(), Mul)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; isinstance((1 + 3*I).round(), Add)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">Float</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a number&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">zoo</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_extended_real</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">i</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">r</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">precs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">_prec</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Float</span><span class="p">)]</span>
        <span class="n">dps</span> <span class="o">=</span> <span class="n">prec_to_dps</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">precs</span><span class="p">))</span> <span class="k">if</span> <span class="n">precs</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="n">_mag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">allow</span> <span class="o">=</span> <span class="n">digits_needed</span> <span class="o">=</span> <span class="n">mag_first_dig</span> <span class="o">+</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">allow</span> <span class="o">&gt;</span> <span class="n">dps</span><span class="p">:</span>
            <span class="n">allow</span> <span class="o">=</span> <span class="n">dps</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># magnitude needed to bring digit p to units place</span>
        <span class="n">xwas</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mag</span><span class="p">)</span>  <span class="c1"># add the half for rounding</span>
        <span class="n">i10</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">mag</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">evalf</span><span class="p">((</span><span class="n">dps</span> <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">digits_needed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i10</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">xwas</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mag</span><span class="p">)</span>  <span class="c1"># should have gone the other way</span>
            <span class="n">i10</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">mag</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">evalf</span><span class="p">((</span><span class="n">dps</span> <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">digits_needed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="n">i10</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">i10</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">mag</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">/=</span> <span class="n">mag</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rv</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
            <span class="c1"># use str or else it won&#39;t be a float</span>
            <span class="k">return</span> <span class="n">Float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rv</span><span class="p">),</span> <span class="n">digits_needed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow</span> <span class="ow">and</span> <span class="n">rv</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">allow</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Float</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">allow</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AtomicExpr"><a class="viewcode-back" href="../../../modules/core.html#diofant.core.expr.AtomicExpr">[docs]</a><span class="k">class</span> <span class="nc">AtomicExpr</span><span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A parent class for object which are both atoms and Exprs.</span>

<span class="sd">    For example: Symbol, Number, Rational, Integer, ...</span>
<span class="sd">    But not: Add, Mul, Pow, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_number</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Atom</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<span class="k">def</span> <span class="nf">_mag</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return integer ``i`` such that .1 &lt;= x/10**i &lt; 1</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; _mag(Float(.1))</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(.01))</span>
<span class="sd">    -1</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(1234))</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">log10</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">Float</span>
    <span class="n">xpos</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xpos</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">xpos</span><span class="p">)))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">Float</span><span class="p">(</span><span class="n">mpf_log</span><span class="p">(</span><span class="n">xpos</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="mi">53</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
    <span class="c1"># check that we aren&#39;t off by 1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xpos</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">mag_first_dig</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">xpos</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">mag_first_dig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>
        <span class="n">mag_first_dig</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">mag_first_dig</span>


<span class="kn">from</span> <span class="nn">.mul</span> <span class="k">import</span> <span class="n">Mul</span>
<span class="kn">from</span> <span class="nn">.add</span> <span class="k">import</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">.power</span> <span class="k">import</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">expand_mul</span>
<span class="kn">from</span> <span class="nn">.mod</span> <span class="k">import</span> <span class="n">Mod</span>
<span class="kn">from</span> <span class="nn">.exprtools</span> <span class="k">import</span> <span class="n">factor_terms</span>
<span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">I</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">zoo</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2006-2018 SymPy Development Team, 2013-2018 Sergey B Kirpichev

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>